!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A0	rand.c	/^#define A0	/;"	d	file:
A1	rand.c	/^#define A1	/;"	d	file:
A2	rand.c	/^#define A2	/;"	d	file:
ACTIVE_EXPIRE_CYCLE_FAST	redis.h	/^#define ACTIVE_EXPIRE_CYCLE_FAST /;"	d
ACTIVE_EXPIRE_CYCLE_FAST_DURATION	redis.h	/^#define ACTIVE_EXPIRE_CYCLE_FAST_DURATION /;"	d
ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP	redis.h	/^#define ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP /;"	d
ACTIVE_EXPIRE_CYCLE_SLOW	redis.h	/^#define ACTIVE_EXPIRE_CYCLE_SLOW /;"	d
ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC	redis.h	/^#define ACTIVE_EXPIRE_CYCLE_SLOW_TIME_PERC /;"	d
ADDEQU	rand.c	/^#define ADDEQU(/;"	d	file:
AE_ALL_EVENTS	ae.h	/^#define AE_ALL_EVENTS /;"	d
AE_DONT_WAIT	ae.h	/^#define AE_DONT_WAIT /;"	d
AE_ERR	ae.h	/^#define AE_ERR /;"	d
AE_FILE_EVENTS	ae.h	/^#define AE_FILE_EVENTS /;"	d
AE_NOMORE	ae.h	/^#define AE_NOMORE /;"	d
AE_NONE	ae.h	/^#define AE_NONE /;"	d
AE_NOTUSED	ae.h	/^#define AE_NOTUSED(/;"	d
AE_OK	ae.h	/^#define AE_OK /;"	d
AE_READABLE	ae.h	/^#define AE_READABLE /;"	d
AE_TIME_EVENTS	ae.h	/^#define AE_TIME_EVENTS /;"	d
AE_WRITABLE	ae.h	/^#define AE_WRITABLE /;"	d
AF_LOCAL	anet.h	/^#define AF_LOCAL /;"	d
ALLOC	Makefile	/^	echo MALLOC=$(MALLOC) >> .make-settings$/;"	m
AL_START_HEAD	adlist.h	/^#define AL_START_HEAD /;"	d
AL_START_TAIL	adlist.h	/^#define AL_START_TAIL /;"	d
ANET_CONNECT_BE_BINDING	anet.c	/^#define ANET_CONNECT_BE_BINDING /;"	d	file:
ANET_CONNECT_NONBLOCK	anet.c	/^#define ANET_CONNECT_NONBLOCK /;"	d	file:
ANET_CONNECT_NONE	anet.c	/^#define ANET_CONNECT_NONE /;"	d	file:
ANET_ERR	anet.h	/^#define ANET_ERR /;"	d
ANET_ERR_LEN	anet.h	/^#define ANET_ERR_LEN /;"	d
ANET_H	anet.h	/^#define ANET_H$/;"	d
ANET_IP_ONLY	anet.h	/^#define ANET_IP_ONLY /;"	d
ANET_NONE	anet.h	/^#define ANET_NONE /;"	d
ANET_OK	anet.h	/^#define ANET_OK /;"	d
AOF_FSYNC_ALWAYS	redis.h	/^#define AOF_FSYNC_ALWAYS /;"	d
AOF_FSYNC_EVERYSEC	redis.h	/^#define AOF_FSYNC_EVERYSEC /;"	d
AOF_FSYNC_NO	redis.h	/^#define AOF_FSYNC_NO /;"	d
AOF_RW_BUF_BLOCK_SIZE	aof.c	/^#define AOF_RW_BUF_BLOCK_SIZE /;"	d	file:
AOF_WRITE_LOG_ERROR_RATE	aof.c	/^#define AOF_WRITE_LOG_ERROR_RATE /;"	d	file:
ARN	Makefile	/^	echo WARN=$(WARN) >> .make-settings$/;"	m
AVOID_ERRNO	lzfP.h	/^# define AVOID_ERRNO /;"	d
BIG_ENDIAN	config.h	/^#define	BIG_ENDIAN	/;"	d
BIG_ENDIAN	config.h	/^#define BIG_ENDIAN /;"	d
BINCOLOR	Makefile	/^BINCOLOR="\\033[37;1m"$/;"	m
BITOP_AND	bitops.c	/^#define BITOP_AND /;"	d	file:
BITOP_NOT	bitops.c	/^#define BITOP_NOT /;"	d	file:
BITOP_OR	bitops.c	/^#define BITOP_OR /;"	d	file:
BITOP_XOR	bitops.c	/^#define BITOP_XOR /;"	d	file:
BYTE_ORDER	config.h	/^#define BYTE_ORDER	/;"	d
BYTE_ORDER	config.h	/^#define BYTE_ORDER /;"	d
C	rand.c	/^#define C	/;"	d	file:
CARRY	rand.c	/^#define CARRY(/;"	d	file:
CCCOLOR	Makefile	/^CCCOLOR="\\033[34m"$/;"	m
CHECK_INPUT	lzfP.h	/^# define CHECK_INPUT /;"	d
CLIENTS_CRON_MIN_ITERATIONS	redis.c	/^#define CLIENTS_CRON_MIN_ITERATIONS /;"	d	file:
CLI_HELP_COMMAND	redis-cli.c	/^#define CLI_HELP_COMMAND /;"	d	file:
CLI_HELP_GROUP	redis-cli.c	/^#define CLI_HELP_GROUP /;"	d	file:
CLUSTERMSG_FLAG0_FORCEACK	cluster.h	/^#define CLUSTERMSG_FLAG0_FORCEACK /;"	d
CLUSTERMSG_FLAG0_PAUSED	cluster.h	/^#define CLUSTERMSG_FLAG0_PAUSED /;"	d
CLUSTERMSG_MIN_LEN	cluster.h	/^#define CLUSTERMSG_MIN_LEN /;"	d
CLUSTERMSG_TYPE_FAIL	cluster.h	/^#define CLUSTERMSG_TYPE_FAIL /;"	d
CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK	cluster.h	/^#define CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK /;"	d
CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST	cluster.h	/^#define CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST /;"	d
CLUSTERMSG_TYPE_MEET	cluster.h	/^#define CLUSTERMSG_TYPE_MEET /;"	d
CLUSTERMSG_TYPE_MFSTART	cluster.h	/^#define CLUSTERMSG_TYPE_MFSTART /;"	d
CLUSTERMSG_TYPE_PING	cluster.h	/^#define CLUSTERMSG_TYPE_PING /;"	d
CLUSTERMSG_TYPE_PONG	cluster.h	/^#define CLUSTERMSG_TYPE_PONG /;"	d
CLUSTERMSG_TYPE_PUBLISH	cluster.h	/^#define CLUSTERMSG_TYPE_PUBLISH /;"	d
CLUSTERMSG_TYPE_UPDATE	cluster.h	/^#define CLUSTERMSG_TYPE_UPDATE /;"	d
CLUSTER_BROADCAST_ALL	cluster.c	/^#define CLUSTER_BROADCAST_ALL /;"	d	file:
CLUSTER_BROADCAST_LOCAL_SLAVES	cluster.c	/^#define CLUSTER_BROADCAST_LOCAL_SLAVES /;"	d	file:
CLUSTER_PROTO_VER	cluster.h	/^#define CLUSTER_PROTO_VER /;"	d
CLUSTER_TODO_FSYNC_CONFIG	cluster.h	/^#define CLUSTER_TODO_FSYNC_CONFIG /;"	d
CLUSTER_TODO_HANDLE_FAILOVER	cluster.h	/^#define CLUSTER_TODO_HANDLE_FAILOVER /;"	d
CLUSTER_TODO_SAVE_CONFIG	cluster.h	/^#define CLUSTER_TODO_SAVE_CONFIG /;"	d
CLUSTER_TODO_UPDATE_STATE	cluster.h	/^#define CLUSTER_TODO_UPDATE_STATE /;"	d
CRC64_H	crc64.h	/^#define CRC64_H$/;"	d
CURR_OFFSET	redis-check-dump.c	/^#define CURR_OFFSET /;"	d	file:
ClusterNode	redis-trib.rb	/^class ClusterNode$/;"	c
DEBUG	Makefile	/^DEBUG=-g -ggdb$/;"	m
DEPENDENCY_TARGETS	Makefile	/^DEPENDENCY_TARGETS=hiredis linenoise lua$/;"	m
DFLAGS	Makefile	/^	echo LDFLAGS=$(LDFLAGS) >> .make-settings$/;"	m
DICT_ERR	dict.h	/^#define DICT_ERR /;"	d
DICT_HT_INITIAL_SIZE	dict.h	/^#define DICT_HT_INITIAL_SIZE /;"	d
DICT_NOTUSED	dict.h	/^#define DICT_NOTUSED(/;"	d
DICT_OK	dict.h	/^#define DICT_OK /;"	d
EDIS_CFLAGS	Makefile	/^	echo REDIS_CFLAGS=$(REDIS_CFLAGS) >> .make-settings$/;"	m
EDIS_LDFLAGS	Makefile	/^	echo REDIS_LDFLAGS=$(REDIS_LDFLAGS) >> .make-settings$/;"	m
ENDCOLOR	Makefile	/^ENDCOLOR="\\033[0m"$/;"	m
ERROR	redis-check-aof.c	/^#define ERROR(/;"	d	file:
ERROR	redis-check-dump.c	/^#define ERROR(/;"	d	file:
EVICTION_SAMPLES_ARRAY_SIZE	redis.c	/^#define EVICTION_SAMPLES_ARRAY_SIZE /;"	d	file:
FINAL_CFLAGS	Makefile	/^FINAL_CFLAGS=$(STD) $(WARN) $(OPT) $(DEBUG) $(CFLAGS) $(REDIS_CFLAGS)$/;"	m
FINAL_LDFLAGS	Makefile	/^FINAL_LDFLAGS=$(LDFLAGS) $(REDIS_LDFLAGS) $(DEBUG)$/;"	m
FINAL_LIBS	Makefile	/^FINAL_LIBS=-lm$/;"	m
FLAGS	Makefile	/^	echo CFLAGS=$(CFLAGS) >> .make-settings$/;"	m
FRST	lzf_c.c	/^# define FRST(/;"	d	file:
GNUC_VERSION	config.h	/^#define GNUC_VERSION /;"	d
HAVE_ATOMIC	config.h	/^#define HAVE_ATOMIC$/;"	d
HAVE_BACKTRACE	config.h	/^#define HAVE_BACKTRACE /;"	d
HAVE_EPOLL	config.h	/^#define HAVE_EPOLL /;"	d
HAVE_EVPORT	config.h	/^#define HAVE_EVPORT /;"	d
HAVE_KQUEUE	config.h	/^#define HAVE_KQUEUE /;"	d
HAVE_MALLOC_SIZE	zmalloc.h	/^#define HAVE_MALLOC_SIZE /;"	d
HAVE_PROC_MAPS	config.h	/^#define HAVE_PROC_MAPS /;"	d
HAVE_PROC_SMAPS	config.h	/^#define HAVE_PROC_SMAPS /;"	d
HAVE_PROC_SOMAXCONN	config.h	/^#define HAVE_PROC_SOMAXCONN /;"	d
HAVE_PROC_STAT	config.h	/^#define HAVE_PROC_STAT /;"	d
HAVE_SETPROCTITLE	setproctitle.c	/^#define HAVE_SETPROCTITLE /;"	d	file:
HAVE_SYNC_FILE_RANGE	config.h	/^#define HAVE_SYNC_FILE_RANGE /;"	d
HAVE_TASKINFO	config.h	/^#define HAVE_TASKINFO /;"	d
HIGH	rand.c	/^#define HIGH(/;"	d	file:
HI_BIT	rand.c	/^#define HI_BIT	/;"	d	file:
HLL_BITS	hyperloglog.c	/^#define HLL_BITS /;"	d	file:
HLL_DENSE	hyperloglog.c	/^#define HLL_DENSE /;"	d	file:
HLL_DENSE_GET_REGISTER	hyperloglog.c	/^#define HLL_DENSE_GET_REGISTER(/;"	d	file:
HLL_DENSE_SET_REGISTER	hyperloglog.c	/^#define HLL_DENSE_SET_REGISTER(/;"	d	file:
HLL_DENSE_SIZE	hyperloglog.c	/^#define HLL_DENSE_SIZE /;"	d	file:
HLL_HDR_SIZE	hyperloglog.c	/^#define HLL_HDR_SIZE /;"	d	file:
HLL_INVALIDATE_CACHE	hyperloglog.c	/^#define HLL_INVALIDATE_CACHE(/;"	d	file:
HLL_MAX_ENCODING	hyperloglog.c	/^#define HLL_MAX_ENCODING /;"	d	file:
HLL_P	hyperloglog.c	/^#define HLL_P /;"	d	file:
HLL_P_MASK	hyperloglog.c	/^#define HLL_P_MASK /;"	d	file:
HLL_RAW	hyperloglog.c	/^#define HLL_RAW /;"	d	file:
HLL_REGISTERS	hyperloglog.c	/^#define HLL_REGISTERS /;"	d	file:
HLL_REGISTER_MAX	hyperloglog.c	/^#define HLL_REGISTER_MAX /;"	d	file:
HLL_SPARSE	hyperloglog.c	/^#define HLL_SPARSE /;"	d	file:
HLL_SPARSE_IS_VAL	hyperloglog.c	/^#define HLL_SPARSE_IS_VAL(/;"	d	file:
HLL_SPARSE_IS_XZERO	hyperloglog.c	/^#define HLL_SPARSE_IS_XZERO(/;"	d	file:
HLL_SPARSE_IS_ZERO	hyperloglog.c	/^#define HLL_SPARSE_IS_ZERO(/;"	d	file:
HLL_SPARSE_VAL_BIT	hyperloglog.c	/^#define HLL_SPARSE_VAL_BIT /;"	d	file:
HLL_SPARSE_VAL_LEN	hyperloglog.c	/^#define HLL_SPARSE_VAL_LEN(/;"	d	file:
HLL_SPARSE_VAL_MAX_LEN	hyperloglog.c	/^#define HLL_SPARSE_VAL_MAX_LEN /;"	d	file:
HLL_SPARSE_VAL_MAX_VALUE	hyperloglog.c	/^#define HLL_SPARSE_VAL_MAX_VALUE /;"	d	file:
HLL_SPARSE_VAL_SET	hyperloglog.c	/^#define HLL_SPARSE_VAL_SET(/;"	d	file:
HLL_SPARSE_VAL_VALUE	hyperloglog.c	/^#define HLL_SPARSE_VAL_VALUE(/;"	d	file:
HLL_SPARSE_XZERO_BIT	hyperloglog.c	/^#define HLL_SPARSE_XZERO_BIT /;"	d	file:
HLL_SPARSE_XZERO_LEN	hyperloglog.c	/^#define HLL_SPARSE_XZERO_LEN(/;"	d	file:
HLL_SPARSE_XZERO_MAX_LEN	hyperloglog.c	/^#define HLL_SPARSE_XZERO_MAX_LEN /;"	d	file:
HLL_SPARSE_XZERO_SET	hyperloglog.c	/^#define HLL_SPARSE_XZERO_SET(/;"	d	file:
HLL_SPARSE_ZERO_LEN	hyperloglog.c	/^#define HLL_SPARSE_ZERO_LEN(/;"	d	file:
HLL_SPARSE_ZERO_MAX_LEN	hyperloglog.c	/^#define HLL_SPARSE_ZERO_MAX_LEN /;"	d	file:
HLL_SPARSE_ZERO_SET	hyperloglog.c	/^#define HLL_SPARSE_ZERO_SET(/;"	d	file:
HLL_TEST_CYCLES	hyperloglog.c	/^#define HLL_TEST_CYCLES /;"	d	file:
HLL_VALID_CACHE	hyperloglog.c	/^#define HLL_VALID_CACHE(/;"	d	file:
HLOG	lzfP.h	/^# define HLOG /;"	d
HSIZE	lzf_c.c	/^#define HSIZE /;"	d	file:
IDX	lzf_c.c	/^#  define IDX(/;"	d	file:
INIT_HTAB	lzfP.h	/^# define INIT_HTAB /;"	d
INIT_SETPROCTITLE_REPLACEMENT	config.h	/^#define INIT_SETPROCTITLE_REPLACEMENT$/;"	d
INSTALL	Makefile	/^	INSTALL=cp -pf$/;"	m
INSTALL	Makefile	/^INSTALL=install$/;"	m
INSTALL_BIN	Makefile	/^INSTALL_BIN=$(PREFIX)\/bin$/;"	m
INT24_MAX	ziplist.c	/^#define INT24_MAX /;"	d	file:
INT24_MIN	ziplist.c	/^#define INT24_MIN /;"	d	file:
INTSET_ENC_INT16	intset.c	/^#define INTSET_ENC_INT16 /;"	d	file:
INTSET_ENC_INT32	intset.c	/^#define INTSET_ENC_INT32 /;"	d	file:
INTSET_ENC_INT64	intset.c	/^#define INTSET_ENC_INT64 /;"	d	file:
LATENCY_DIST_DEFAULT_INTERVAL	redis-cli.c	/^#define LATENCY_DIST_DEFAULT_INTERVAL /;"	d	file:
LATENCY_GRAPH_COLS	latency.c	/^#define LATENCY_GRAPH_COLS /;"	d	file:
LATENCY_HISTORY_DEFAULT_INTERVAL	redis-cli.c	/^#define LATENCY_HISTORY_DEFAULT_INTERVAL /;"	d	file:
LATENCY_SAMPLE_RATE	redis-cli.c	/^#define LATENCY_SAMPLE_RATE /;"	d	file:
LATENCY_TS_LEN	latency.h	/^#define LATENCY_TS_LEN /;"	d
LINKCOLOR	Makefile	/^LINKCOLOR="\\033[34;1m"$/;"	m
LITTLE_ENDIAN	config.h	/^#define	LITTLE_ENDIAN	/;"	d
LITTLE_ENDIAN	config.h	/^#define LITTLE_ENDIAN /;"	d
LOW	rand.c	/^#define LOW(/;"	d	file:
LRUTestGenKey	redis-cli.c	/^void LRUTestGenKey(char *buf, size_t buflen) {$/;"	f	signature:(char *buf, size_t buflen)
LRUTestMode	redis-cli.c	/^static void LRUTestMode(void) {$/;"	f	file:	signature:(void)
LRU_CLOCK	redis.h	/^#define LRU_CLOCK(/;"	d
LRU_CYCLE_PERIOD	redis-cli.c	/^#define LRU_CYCLE_PERIOD /;"	d	file:
LRU_CYCLE_PIPELINE_SIZE	redis-cli.c	/^#define LRU_CYCLE_PIPELINE_SIZE /;"	d	file:
LUA_CMD_OBJCACHE_MAX_LEN	scripting.c	/^#define LUA_CMD_OBJCACHE_MAX_LEN /;"	d	file:
LUA_CMD_OBJCACHE_SIZE	scripting.c	/^#define LUA_CMD_OBJCACHE_SIZE /;"	d	file:
LUA_GC_CYCLE_PERIOD	scripting.c	/^    #define LUA_GC_CYCLE_PERIOD /;"	d	file:
LZFP_h	lzfP.h	/^#define LZFP_h$/;"	d
LZF_H	lzf.h	/^#define LZF_H$/;"	d
LZF_STATE	lzfP.h	/^typedef const u8 *LZF_STATE[1 << (HLOG)];$/;"	t
LZF_STATE_ARG	lzfP.h	/^# define LZF_STATE_ARG /;"	d
LZF_VERSION	lzf.h	/^#define LZF_VERSION /;"	d
MAKECOLOR	Makefile	/^MAKECOLOR="\\033[32;1m"$/;"	m
MALLOC	Makefile	/^	MALLOC=jemalloc$/;"	m
MALLOC	Makefile	/^	MALLOC=libc$/;"	m
MALLOC	Makefile	/^	MALLOC=tcmalloc$/;"	m
MALLOC	Makefile	/^	MALLOC=tcmalloc_minimal$/;"	m
MASK	rand.c	/^#define MASK	/;"	d	file:
MAX_ACCEPTS_PER_CALL	networking.c	/^#define MAX_ACCEPTS_PER_CALL /;"	d	file:
MAX_CLUSTER_ACCEPTS_PER_CALL	cluster.c	/^#define MAX_CLUSTER_ACCEPTS_PER_CALL /;"	d	file:
MAX_EVENT_BATCHSZ	ae_evport.c	/^#define MAX_EVENT_BATCHSZ /;"	d	file:
MAX_LIT	lzf_c.c	/^#define        MAX_LIT /;"	d	file:
MAX_OFF	lzf_c.c	/^#define        MAX_OFF /;"	d	file:
MAX_REF	lzf_c.c	/^#define        MAX_REF /;"	d	file:
MAX_TYPES_NUM	redis-check-dump.c	/^#define MAX_TYPES_NUM /;"	d	file:
MAX_TYPE_NAME_LEN	redis-check-dump.c	/^#define MAX_TYPE_NAME_LEN /;"	d	file:
MEMTEST_32BIT	memtest.c	/^#define MEMTEST_32BIT$/;"	d	file:
MEMTEST_64BIT	memtest.c	/^#define MEMTEST_64BIT$/;"	d	file:
MEMTEST_MAX_REGIONS	debug.c	/^#define MEMTEST_MAX_REGIONS /;"	d	file:
MIGRATE_SOCKET_CACHE_ITEMS	cluster.c	/^#define MIGRATE_SOCKET_CACHE_ITEMS /;"	d	file:
MIGRATE_SOCKET_CACHE_TTL	cluster.c	/^#define MIGRATE_SOCKET_CACHE_TTL /;"	d	file:
MUL	rand.c	/^#define MUL(/;"	d	file:
Makefile	Makefile	1;"	F
MurmurHash64A	hyperloglog.c	/^uint64_t MurmurHash64A (const void * key, int len, unsigned int seed) {$/;"	f	signature:(const void * key, int len, unsigned int seed)
N	rand.c	/^#define N	/;"	d	file:
NEXT	lzf_c.c	/^# define NEXT(/;"	d	file:
OPT	Makefile	/^OPT=$(OPTIMIZATION)$/;"	m
OPTIMIZATION	Makefile	/^OPTIMIZATION?=-O2$/;"	m
OPVAL_DIRTY_LL	t_zset.c	/^#define OPVAL_DIRTY_LL /;"	d	file:
OPVAL_DIRTY_ROBJ	t_zset.c	/^#define OPVAL_DIRTY_ROBJ /;"	d	file:
OPVAL_VALID_LL	t_zset.c	/^#define OPVAL_VALID_LL /;"	d	file:
OUTPUT_CSV	redis-cli.c	/^#define OUTPUT_CSV /;"	d	file:
OUTPUT_RAW	redis-cli.c	/^#define OUTPUT_RAW /;"	d	file:
OUTPUT_STANDARD	redis-cli.c	/^#define OUTPUT_STANDARD /;"	d	file:
PDP_ENDIAN	config.h	/^#define	PDP_ENDIAN	/;"	d
PIPEMODE_WRITE_LOOP_MAX_BYTES	redis-cli.c	/^#define PIPEMODE_WRITE_LOOP_MAX_BYTES /;"	d	file:
PREFIX	Makefile	/^PREFIX?=\/usr\/local$/;"	m
PREFIX_SIZE	zmalloc.c	/^#define PREFIX_SIZE /;"	d	file:
PSYNC_CONTINUE	replication.c	/^#define PSYNC_CONTINUE /;"	d	file:
PSYNC_FULLRESYNC	replication.c	/^#define PSYNC_FULLRESYNC /;"	d	file:
PSYNC_NOT_SUPPORTED	replication.c	/^#define PSYNC_NOT_SUPPORTED /;"	d	file:
PSYNC_WAIT_REPLY	replication.c	/^#define PSYNC_WAIT_REPLY /;"	d	file:
PSYNC_WRITE_ERROR	replication.c	/^#define PSYNC_WRITE_ERROR /;"	d	file:
PT	Makefile	/^	echo OPT=$(OPT) >> .make-settings$/;"	m
QUIET_CC	Makefile	/^QUIET_CC = @printf '    %b %b\\n' $(CCCOLOR)CC$(ENDCOLOR) $(SRCCOLOR)$@$(ENDCOLOR) 1>&2;$/;"	m
QUIET_INSTALL	Makefile	/^QUIET_INSTALL = @printf '    %b %b\\n' $(LINKCOLOR)INSTALL$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;$/;"	m
QUIET_LINK	Makefile	/^QUIET_LINK = @printf '    %b %b\\n' $(LINKCOLOR)LINK$(ENDCOLOR) $(BINCOLOR)$@$(ENDCOLOR) 1>&2;$/;"	m
R0	sha1.c	/^#define R0(/;"	d	file:
R1	sha1.c	/^#define R1(/;"	d	file:
R2	sha1.c	/^#define R2(/;"	d	file:
R3	sha1.c	/^#define R3(/;"	d	file:
R4	sha1.c	/^#define R4(/;"	d	file:
RANDPTR_INITIAL_SIZE	redis-benchmark.c	/^#define RANDPTR_INITIAL_SIZE /;"	d	file:
REDIS_AGGR_MAX	t_zset.c	/^#define REDIS_AGGR_MAX /;"	d	file:
REDIS_AGGR_MIN	t_zset.c	/^#define REDIS_AGGR_MIN /;"	d	file:
REDIS_AGGR_SUM	t_zset.c	/^#define REDIS_AGGR_SUM /;"	d	file:
REDIS_AOF_AUTOSYNC_BYTES	redis.h	/^#define REDIS_AOF_AUTOSYNC_BYTES /;"	d
REDIS_AOF_OFF	redis.h	/^#define REDIS_AOF_OFF /;"	d
REDIS_AOF_ON	redis.h	/^#define REDIS_AOF_ON /;"	d
REDIS_AOF_REWRITE_ITEMS_PER_CMD	redis.h	/^#define REDIS_AOF_REWRITE_ITEMS_PER_CMD /;"	d
REDIS_AOF_REWRITE_MIN_SIZE	redis.h	/^#define REDIS_AOF_REWRITE_MIN_SIZE /;"	d
REDIS_AOF_REWRITE_PERC	redis.h	/^#define REDIS_AOF_REWRITE_PERC /;"	d
REDIS_AOF_WAIT_REWRITE	redis.h	/^#define REDIS_AOF_WAIT_REWRITE /;"	d
REDIS_ASKING	redis.h	/^#define REDIS_ASKING /;"	d
REDIS_AUTHPASS_MAX_LEN	redis.h	/^#define REDIS_AUTHPASS_MAX_LEN /;"	d
REDIS_BENCHMARK_NAME	Makefile	/^REDIS_BENCHMARK_NAME=redis-benchmark$/;"	m
REDIS_BENCHMARK_OBJ	Makefile	/^REDIS_BENCHMARK_OBJ=ae.o anet.o redis-benchmark.o sds.o adlist.o zmalloc.o redis-benchmark.o$/;"	m
REDIS_BGSAVE_RETRY_DELAY	redis.h	/^#define REDIS_BGSAVE_RETRY_DELAY /;"	d
REDIS_BINDADDR_MAX	redis.h	/^#define REDIS_BINDADDR_MAX /;"	d
REDIS_BIND_ADDR	redis.h	/^#define REDIS_BIND_ADDR /;"	d
REDIS_BIO_AOF_FSYNC	bio.h	/^#define REDIS_BIO_AOF_FSYNC /;"	d
REDIS_BIO_CLOSE_FILE	bio.h	/^#define REDIS_BIO_CLOSE_FILE /;"	d
REDIS_BIO_NUM_OPS	bio.h	/^#define REDIS_BIO_NUM_OPS /;"	d
REDIS_BLOCKED	redis.h	/^#define REDIS_BLOCKED /;"	d
REDIS_BLOCKED_LIST	redis.h	/^#define REDIS_BLOCKED_LIST /;"	d
REDIS_BLOCKED_NONE	redis.h	/^#define REDIS_BLOCKED_NONE /;"	d
REDIS_BLOCKED_WAIT	redis.h	/^#define REDIS_BLOCKED_WAIT /;"	d
REDIS_BUILD_ID	release.h	/^#define REDIS_BUILD_ID /;"	d
REDIS_CALL_FULL	redis.h	/^#define REDIS_CALL_FULL /;"	d
REDIS_CALL_NONE	redis.h	/^#define REDIS_CALL_NONE /;"	d
REDIS_CALL_PROPAGATE	redis.h	/^#define REDIS_CALL_PROPAGATE /;"	d
REDIS_CALL_SLOWLOG	redis.h	/^#define REDIS_CALL_SLOWLOG /;"	d
REDIS_CALL_STATS	redis.h	/^#define REDIS_CALL_STATS /;"	d
REDIS_CC	Makefile	/^REDIS_CC=$(QUIET_CC)$(CC) $(FINAL_CFLAGS)$/;"	m
REDIS_CHECK_AOF_NAME	Makefile	/^REDIS_CHECK_AOF_NAME=redis-check-aof$/;"	m
REDIS_CHECK_AOF_OBJ	Makefile	/^REDIS_CHECK_AOF_OBJ=redis-check-aof.o$/;"	m
REDIS_CHECK_DUMP_NAME	Makefile	/^REDIS_CHECK_DUMP_NAME=redis-check-dump$/;"	m
REDIS_CHECK_DUMP_OBJ	Makefile	/^REDIS_CHECK_DUMP_OBJ=redis-check-dump.o lzf_c.o lzf_d.o crc64.o$/;"	m
REDIS_CLIENT_TYPE_COUNT	redis.h	/^#define REDIS_CLIENT_TYPE_COUNT /;"	d
REDIS_CLIENT_TYPE_NORMAL	redis.h	/^#define REDIS_CLIENT_TYPE_NORMAL /;"	d
REDIS_CLIENT_TYPE_PUBSUB	redis.h	/^#define REDIS_CLIENT_TYPE_PUBSUB /;"	d
REDIS_CLIENT_TYPE_SLAVE	redis.h	/^#define REDIS_CLIENT_TYPE_SLAVE /;"	d
REDIS_CLI_DEFAULT_PIPE_TIMEOUT	redis-cli.c	/^#define REDIS_CLI_DEFAULT_PIPE_TIMEOUT /;"	d	file:
REDIS_CLI_HISTFILE_DEFAULT	redis-cli.c	/^#define REDIS_CLI_HISTFILE_DEFAULT /;"	d	file:
REDIS_CLI_HISTFILE_ENV	redis-cli.c	/^#define REDIS_CLI_HISTFILE_ENV /;"	d	file:
REDIS_CLI_KEEPALIVE_INTERVAL	redis-cli.c	/^#define REDIS_CLI_KEEPALIVE_INTERVAL /;"	d	file:
REDIS_CLI_NAME	Makefile	/^REDIS_CLI_NAME=redis-cli$/;"	m
REDIS_CLI_OBJ	Makefile	/^REDIS_CLI_OBJ=anet.o sds.o adlist.o redis-cli.o zmalloc.o release.o anet.o ae.o crc64.o$/;"	m
REDIS_CLOSE_AFTER_REPLY	redis.h	/^#define REDIS_CLOSE_AFTER_REPLY /;"	d
REDIS_CLOSE_ASAP	redis.h	/^#define REDIS_CLOSE_ASAP /;"	d
REDIS_CLUSTER_BLACKLIST_TTL	cluster.c	/^#define REDIS_CLUSTER_BLACKLIST_TTL /;"	d	file:
REDIS_CLUSTER_CANT_FAILOVER_DATA_AGE	cluster.h	/^#define REDIS_CLUSTER_CANT_FAILOVER_DATA_AGE /;"	d
REDIS_CLUSTER_CANT_FAILOVER_EXPIRED	cluster.h	/^#define REDIS_CLUSTER_CANT_FAILOVER_EXPIRED /;"	d
REDIS_CLUSTER_CANT_FAILOVER_NONE	cluster.h	/^#define REDIS_CLUSTER_CANT_FAILOVER_NONE /;"	d
REDIS_CLUSTER_CANT_FAILOVER_RELOG_PERIOD	cluster.h	/^#define REDIS_CLUSTER_CANT_FAILOVER_RELOG_PERIOD /;"	d
REDIS_CLUSTER_CANT_FAILOVER_WAITING_DELAY	cluster.h	/^#define REDIS_CLUSTER_CANT_FAILOVER_WAITING_DELAY /;"	d
REDIS_CLUSTER_CANT_FAILOVER_WAITING_VOTES	cluster.h	/^#define REDIS_CLUSTER_CANT_FAILOVER_WAITING_VOTES /;"	d
REDIS_CLUSTER_DEFAULT_MIGRATION_BARRIER	cluster.h	/^#define REDIS_CLUSTER_DEFAULT_MIGRATION_BARRIER /;"	d
REDIS_CLUSTER_DEFAULT_NODE_TIMEOUT	cluster.h	/^#define REDIS_CLUSTER_DEFAULT_NODE_TIMEOUT /;"	d
REDIS_CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE	cluster.h	/^#define REDIS_CLUSTER_DEFAULT_REQUIRE_FULL_COVERAGE /;"	d
REDIS_CLUSTER_DEFAULT_SLAVE_VALIDITY	cluster.h	/^#define REDIS_CLUSTER_DEFAULT_SLAVE_VALIDITY /;"	d
REDIS_CLUSTER_FAIL	cluster.h	/^#define REDIS_CLUSTER_FAIL /;"	d
REDIS_CLUSTER_FAILOVER_DELAY	cluster.h	/^#define REDIS_CLUSTER_FAILOVER_DELAY /;"	d
REDIS_CLUSTER_FAIL_REPORT_VALIDITY_MULT	cluster.h	/^#define REDIS_CLUSTER_FAIL_REPORT_VALIDITY_MULT /;"	d
REDIS_CLUSTER_FAIL_UNDO_TIME_ADD	cluster.h	/^#define REDIS_CLUSTER_FAIL_UNDO_TIME_ADD /;"	d
REDIS_CLUSTER_FAIL_UNDO_TIME_MULT	cluster.h	/^#define REDIS_CLUSTER_FAIL_UNDO_TIME_MULT /;"	d
REDIS_CLUSTER_MAX_REJOIN_DELAY	cluster.c	/^#define REDIS_CLUSTER_MAX_REJOIN_DELAY /;"	d	file:
REDIS_CLUSTER_MF_PAUSE_MULT	cluster.h	/^#define REDIS_CLUSTER_MF_PAUSE_MULT /;"	d
REDIS_CLUSTER_MF_TIMEOUT	cluster.h	/^#define REDIS_CLUSTER_MF_TIMEOUT /;"	d
REDIS_CLUSTER_MIN_REJOIN_DELAY	cluster.c	/^#define REDIS_CLUSTER_MIN_REJOIN_DELAY /;"	d	file:
REDIS_CLUSTER_NAMELEN	cluster.h	/^#define REDIS_CLUSTER_NAMELEN /;"	d
REDIS_CLUSTER_OK	cluster.h	/^#define REDIS_CLUSTER_OK /;"	d
REDIS_CLUSTER_PORT_INCR	cluster.h	/^#define REDIS_CLUSTER_PORT_INCR /;"	d
REDIS_CLUSTER_REDIR_ASK	cluster.h	/^#define REDIS_CLUSTER_REDIR_ASK /;"	d
REDIS_CLUSTER_REDIR_CROSS_SLOT	cluster.h	/^#define REDIS_CLUSTER_REDIR_CROSS_SLOT /;"	d
REDIS_CLUSTER_REDIR_DOWN_STATE	cluster.h	/^#define REDIS_CLUSTER_REDIR_DOWN_STATE /;"	d
REDIS_CLUSTER_REDIR_DOWN_UNBOUND	cluster.h	/^#define REDIS_CLUSTER_REDIR_DOWN_UNBOUND /;"	d
REDIS_CLUSTER_REDIR_MOVED	cluster.h	/^#define REDIS_CLUSTER_REDIR_MOVED /;"	d
REDIS_CLUSTER_REDIR_NONE	cluster.h	/^#define REDIS_CLUSTER_REDIR_NONE /;"	d
REDIS_CLUSTER_REDIR_UNSTABLE	cluster.h	/^#define REDIS_CLUSTER_REDIR_UNSTABLE /;"	d
REDIS_CLUSTER_SLOTS	cluster.h	/^#define REDIS_CLUSTER_SLOTS /;"	d
REDIS_CLUSTER_WRITABLE_DELAY	cluster.c	/^#define REDIS_CLUSTER_WRITABLE_DELAY /;"	d	file:
REDIS_CMD_ADMIN	redis.h	/^#define REDIS_CMD_ADMIN /;"	d
REDIS_CMD_ASKING	redis.h	/^#define REDIS_CMD_ASKING /;"	d
REDIS_CMD_DENYOOM	redis.h	/^#define REDIS_CMD_DENYOOM /;"	d
REDIS_CMD_FAST	redis.h	/^#define REDIS_CMD_FAST /;"	d
REDIS_CMD_LOADING	redis.h	/^#define REDIS_CMD_LOADING /;"	d
REDIS_CMD_NOSCRIPT	redis.h	/^#define REDIS_CMD_NOSCRIPT /;"	d
REDIS_CMD_NOT_USED_1	redis.h	/^#define REDIS_CMD_NOT_USED_1 /;"	d
REDIS_CMD_PUBSUB	redis.h	/^#define REDIS_CMD_PUBSUB /;"	d
REDIS_CMD_RANDOM	redis.h	/^#define REDIS_CMD_RANDOM /;"	d
REDIS_CMD_READONLY	redis.h	/^#define REDIS_CMD_READONLY /;"	d
REDIS_CMD_SKIP_MONITOR	redis.h	/^#define REDIS_CMD_SKIP_MONITOR /;"	d
REDIS_CMD_SORT_FOR_SCRIPT	redis.h	/^#define REDIS_CMD_SORT_FOR_SCRIPT /;"	d
REDIS_CMD_STALE	redis.h	/^#define REDIS_CMD_STALE /;"	d
REDIS_CMD_WRITE	redis.h	/^#define REDIS_CMD_WRITE /;"	d
REDIS_COMPARE_BINARY	object.c	/^#define REDIS_COMPARE_BINARY /;"	d	file:
REDIS_COMPARE_COLL	object.c	/^#define REDIS_COMPARE_COLL /;"	d	file:
REDIS_CONFIGLINE_MAX	redis.h	/^#define REDIS_CONFIGLINE_MAX /;"	d
REDIS_CONFIG_REWRITE_SIGNATURE	config.c	/^#define REDIS_CONFIG_REWRITE_SIGNATURE /;"	d	file:
REDIS_DBCRON_DBS_PER_CALL	redis.h	/^#define REDIS_DBCRON_DBS_PER_CALL /;"	d
REDIS_DEBUG	redis.h	/^#define REDIS_DEBUG /;"	d
REDIS_DEFAULT_ACTIVE_REHASHING	redis.h	/^#define REDIS_DEFAULT_ACTIVE_REHASHING /;"	d
REDIS_DEFAULT_AOF_FILENAME	redis.h	/^#define REDIS_DEFAULT_AOF_FILENAME /;"	d
REDIS_DEFAULT_AOF_FSYNC	redis.h	/^#define REDIS_DEFAULT_AOF_FSYNC /;"	d
REDIS_DEFAULT_AOF_LOAD_TRUNCATED	redis.h	/^#define REDIS_DEFAULT_AOF_LOAD_TRUNCATED /;"	d
REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE	redis.h	/^#define REDIS_DEFAULT_AOF_NO_FSYNC_ON_REWRITE /;"	d
REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC	redis.h	/^#define REDIS_DEFAULT_AOF_REWRITE_INCREMENTAL_FSYNC /;"	d
REDIS_DEFAULT_CLUSTER_CONFIG_FILE	redis.h	/^#define REDIS_DEFAULT_CLUSTER_CONFIG_FILE /;"	d
REDIS_DEFAULT_DAEMONIZE	redis.h	/^#define REDIS_DEFAULT_DAEMONIZE /;"	d
REDIS_DEFAULT_DBNUM	redis.h	/^#define REDIS_DEFAULT_DBNUM /;"	d
REDIS_DEFAULT_HLL_SPARSE_MAX_BYTES	redis.h	/^#define REDIS_DEFAULT_HLL_SPARSE_MAX_BYTES /;"	d
REDIS_DEFAULT_HZ	redis.h	/^#define REDIS_DEFAULT_HZ /;"	d
REDIS_DEFAULT_LATENCY_MONITOR_THRESHOLD	redis.h	/^#define REDIS_DEFAULT_LATENCY_MONITOR_THRESHOLD /;"	d
REDIS_DEFAULT_LOGFILE	redis.h	/^#define REDIS_DEFAULT_LOGFILE /;"	d
REDIS_DEFAULT_MAXMEMORY	redis.h	/^#define REDIS_DEFAULT_MAXMEMORY /;"	d
REDIS_DEFAULT_MAXMEMORY_POLICY	redis.h	/^#define REDIS_DEFAULT_MAXMEMORY_POLICY /;"	d
REDIS_DEFAULT_MAXMEMORY_SAMPLES	redis.h	/^#define REDIS_DEFAULT_MAXMEMORY_SAMPLES /;"	d
REDIS_DEFAULT_MIN_SLAVES_MAX_LAG	redis.h	/^#define REDIS_DEFAULT_MIN_SLAVES_MAX_LAG /;"	d
REDIS_DEFAULT_MIN_SLAVES_TO_WRITE	redis.h	/^#define REDIS_DEFAULT_MIN_SLAVES_TO_WRITE /;"	d
REDIS_DEFAULT_PID_FILE	redis.h	/^#define REDIS_DEFAULT_PID_FILE /;"	d
REDIS_DEFAULT_RDB_CHECKSUM	redis.h	/^#define REDIS_DEFAULT_RDB_CHECKSUM /;"	d
REDIS_DEFAULT_RDB_COMPRESSION	redis.h	/^#define REDIS_DEFAULT_RDB_COMPRESSION /;"	d
REDIS_DEFAULT_RDB_FILENAME	redis.h	/^#define REDIS_DEFAULT_RDB_FILENAME /;"	d
REDIS_DEFAULT_REPL_BACKLOG_SIZE	redis.h	/^#define REDIS_DEFAULT_REPL_BACKLOG_SIZE /;"	d
REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT	redis.h	/^#define REDIS_DEFAULT_REPL_BACKLOG_TIME_LIMIT /;"	d
REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY	redis.h	/^#define REDIS_DEFAULT_REPL_DISABLE_TCP_NODELAY /;"	d
REDIS_DEFAULT_REPL_DISKLESS_SYNC	redis.h	/^#define REDIS_DEFAULT_REPL_DISKLESS_SYNC /;"	d
REDIS_DEFAULT_REPL_DISKLESS_SYNC_DELAY	redis.h	/^#define REDIS_DEFAULT_REPL_DISKLESS_SYNC_DELAY /;"	d
REDIS_DEFAULT_SLAVE_PRIORITY	redis.h	/^#define REDIS_DEFAULT_SLAVE_PRIORITY /;"	d
REDIS_DEFAULT_SLAVE_READ_ONLY	redis.h	/^#define REDIS_DEFAULT_SLAVE_READ_ONLY /;"	d
REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA	redis.h	/^#define REDIS_DEFAULT_SLAVE_SERVE_STALE_DATA /;"	d
REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR	redis.h	/^#define REDIS_DEFAULT_STOP_WRITES_ON_BGSAVE_ERROR /;"	d
REDIS_DEFAULT_SYSLOG_ENABLED	redis.h	/^#define REDIS_DEFAULT_SYSLOG_ENABLED /;"	d
REDIS_DEFAULT_SYSLOG_IDENT	redis.h	/^#define REDIS_DEFAULT_SYSLOG_IDENT /;"	d
REDIS_DEFAULT_TCP_KEEPALIVE	redis.h	/^#define REDIS_DEFAULT_TCP_KEEPALIVE /;"	d
REDIS_DEFAULT_UNIX_SOCKET_PERM	redis.h	/^#define REDIS_DEFAULT_UNIX_SOCKET_PERM /;"	d
REDIS_DEFAULT_VERBOSITY	redis.h	/^#define REDIS_DEFAULT_VERBOSITY /;"	d
REDIS_DIRTY_CAS	redis.h	/^#define REDIS_DIRTY_CAS /;"	d
REDIS_DIRTY_EXEC	redis.h	/^#define REDIS_DIRTY_EXEC /;"	d
REDIS_ENCODING_EMBSTR	redis.h	/^#define REDIS_ENCODING_EMBSTR /;"	d
REDIS_ENCODING_EMBSTR_SIZE_LIMIT	object.c	/^#define REDIS_ENCODING_EMBSTR_SIZE_LIMIT /;"	d	file:
REDIS_ENCODING_HT	redis-check-dump.c	/^#define REDIS_ENCODING_HT /;"	d	file:
REDIS_ENCODING_HT	redis.h	/^#define REDIS_ENCODING_HT /;"	d
REDIS_ENCODING_INT	redis-check-dump.c	/^#define REDIS_ENCODING_INT /;"	d	file:
REDIS_ENCODING_INT	redis.h	/^#define REDIS_ENCODING_INT /;"	d
REDIS_ENCODING_INTSET	redis.h	/^#define REDIS_ENCODING_INTSET /;"	d
REDIS_ENCODING_LINKEDLIST	redis.h	/^#define REDIS_ENCODING_LINKEDLIST /;"	d
REDIS_ENCODING_RAW	redis-check-dump.c	/^#define REDIS_ENCODING_RAW /;"	d	file:
REDIS_ENCODING_RAW	redis.h	/^#define REDIS_ENCODING_RAW /;"	d
REDIS_ENCODING_SKIPLIST	redis.h	/^#define REDIS_ENCODING_SKIPLIST /;"	d
REDIS_ENCODING_ZIPLIST	redis.h	/^#define REDIS_ENCODING_ZIPLIST /;"	d
REDIS_ENCODING_ZIPMAP	redis-check-dump.c	/^#define REDIS_ENCODING_ZIPMAP /;"	d	file:
REDIS_ENCODING_ZIPMAP	redis.h	/^#define REDIS_ENCODING_ZIPMAP /;"	d
REDIS_EOF	redis-check-dump.c	/^#define REDIS_EOF /;"	d	file:
REDIS_EOF_MARK_SIZE	redis.h	/^#define REDIS_EOF_MARK_SIZE /;"	d
REDIS_ERR	redis.h	/^#define REDIS_ERR /;"	d
REDIS_EVENTLOOP_FDSET_INCR	redis.h	/^#define REDIS_EVENTLOOP_FDSET_INCR /;"	d
REDIS_EVICTION_POOL_SIZE	redis.h	/^#define REDIS_EVICTION_POOL_SIZE /;"	d
REDIS_EXPIRETIME	redis-check-dump.c	/^#define REDIS_EXPIRETIME /;"	d	file:
REDIS_EXPIRETIME_MS	redis-check-dump.c	/^#define REDIS_EXPIRETIME_MS /;"	d	file:
REDIS_FORCE_AOF	redis.h	/^#define REDIS_FORCE_AOF /;"	d
REDIS_FORCE_REPL	redis.h	/^#define REDIS_FORCE_REPL /;"	d
REDIS_GIT_DIRTY	release.h	/^#define REDIS_GIT_DIRTY /;"	d
REDIS_GIT_SHA1	release.h	/^#define REDIS_GIT_SHA1 /;"	d
REDIS_HASH	redis-check-dump.c	/^#define REDIS_HASH /;"	d	file:
REDIS_HASH	redis.h	/^#define REDIS_HASH /;"	d
REDIS_HASH_KEY	redis.h	/^#define REDIS_HASH_KEY /;"	d
REDIS_HASH_MAX_ZIPLIST_ENTRIES	redis.h	/^#define REDIS_HASH_MAX_ZIPLIST_ENTRIES /;"	d
REDIS_HASH_MAX_ZIPLIST_VALUE	redis.h	/^#define REDIS_HASH_MAX_ZIPLIST_VALUE /;"	d
REDIS_HASH_VALUE	redis.h	/^#define REDIS_HASH_VALUE /;"	d
REDIS_HASH_ZIPLIST	redis-check-dump.c	/^#define REDIS_HASH_ZIPLIST /;"	d	file:
REDIS_HASH_ZIPMAP	redis-check-dump.c	/^#define REDIS_HASH_ZIPMAP /;"	d	file:
REDIS_HEAD	redis.h	/^#define REDIS_HEAD /;"	d
REDIS_HT_MINFILL	redis.h	/^#define REDIS_HT_MINFILL /;"	d
REDIS_INLINE_MAX_SIZE	redis.h	/^#define REDIS_INLINE_MAX_SIZE /;"	d
REDIS_INSTALL	Makefile	/^REDIS_INSTALL=$(QUIET_INSTALL)$(INSTALL)$/;"	m
REDIS_IOBUF_LEN	redis.h	/^#define REDIS_IOBUF_LEN /;"	d
REDIS_IP_STR_LEN	redis.h	/^#define REDIS_IP_STR_LEN /;"	d
REDIS_LD	Makefile	/^REDIS_LD=$(QUIET_LINK)$(CC) $(FINAL_LDFLAGS)$/;"	m
REDIS_LIST	redis-check-dump.c	/^#define REDIS_LIST /;"	d	file:
REDIS_LIST	redis.h	/^#define REDIS_LIST /;"	d
REDIS_LIST_MAX_ZIPLIST_ENTRIES	redis.h	/^#define REDIS_LIST_MAX_ZIPLIST_ENTRIES /;"	d
REDIS_LIST_MAX_ZIPLIST_VALUE	redis.h	/^#define REDIS_LIST_MAX_ZIPLIST_VALUE /;"	d
REDIS_LIST_ZIPLIST	redis-check-dump.c	/^#define REDIS_LIST_ZIPLIST /;"	d	file:
REDIS_LOG_RAW	redis.h	/^#define REDIS_LOG_RAW /;"	d
REDIS_LONGSTR_SIZE	redis.h	/^#define REDIS_LONGSTR_SIZE /;"	d
REDIS_LRAND48_MAX	rand.h	/^#define REDIS_LRAND48_MAX /;"	d
REDIS_LRU_BITS	redis.h	/^#define REDIS_LRU_BITS /;"	d
REDIS_LRU_CLOCK_MAX	redis.h	/^#define REDIS_LRU_CLOCK_MAX /;"	d
REDIS_LRU_CLOCK_RESOLUTION	redis.h	/^#define REDIS_LRU_CLOCK_RESOLUTION /;"	d
REDIS_LUA_CLIENT	redis.h	/^#define REDIS_LUA_CLIENT /;"	d
REDIS_LUA_TIME_LIMIT	redis.h	/^#define REDIS_LUA_TIME_LIMIT /;"	d
REDIS_MASTER	redis.h	/^#define REDIS_MASTER /;"	d
REDIS_MASTER_FORCE_REPLY	redis.h	/^#define REDIS_MASTER_FORCE_REPLY /;"	d
REDIS_MAXIDLETIME	redis.h	/^#define REDIS_MAXIDLETIME /;"	d
REDIS_MAXMEMORY_ALLKEYS_LRU	redis.h	/^#define REDIS_MAXMEMORY_ALLKEYS_LRU /;"	d
REDIS_MAXMEMORY_ALLKEYS_RANDOM	redis.h	/^#define REDIS_MAXMEMORY_ALLKEYS_RANDOM /;"	d
REDIS_MAXMEMORY_NO_EVICTION	redis.h	/^#define REDIS_MAXMEMORY_NO_EVICTION /;"	d
REDIS_MAXMEMORY_VOLATILE_LRU	redis.h	/^#define REDIS_MAXMEMORY_VOLATILE_LRU /;"	d
REDIS_MAXMEMORY_VOLATILE_RANDOM	redis.h	/^#define REDIS_MAXMEMORY_VOLATILE_RANDOM /;"	d
REDIS_MAXMEMORY_VOLATILE_TTL	redis.h	/^#define REDIS_MAXMEMORY_VOLATILE_TTL /;"	d
REDIS_MAX_CLIENTS	redis.h	/^#define REDIS_MAX_CLIENTS /;"	d
REDIS_MAX_HZ	redis.h	/^#define REDIS_MAX_HZ /;"	d
REDIS_MAX_LOGMSG_LEN	redis.h	/^#define REDIS_MAX_LOGMSG_LEN /;"	d
REDIS_MAX_QUERYBUF_LEN	redis.h	/^#define REDIS_MAX_QUERYBUF_LEN /;"	d
REDIS_MAX_WRITE_PER_EVENT	redis.h	/^#define REDIS_MAX_WRITE_PER_EVENT /;"	d
REDIS_MBULK_BIG_ARG	redis.h	/^#define REDIS_MBULK_BIG_ARG /;"	d
REDIS_METRIC_COMMAND	redis.h	/^#define REDIS_METRIC_COMMAND /;"	d
REDIS_METRIC_COUNT	redis.h	/^#define REDIS_METRIC_COUNT /;"	d
REDIS_METRIC_NET_INPUT	redis.h	/^#define REDIS_METRIC_NET_INPUT /;"	d
REDIS_METRIC_NET_OUTPUT	redis.h	/^#define REDIS_METRIC_NET_OUTPUT /;"	d
REDIS_METRIC_SAMPLES	redis.h	/^#define REDIS_METRIC_SAMPLES /;"	d
REDIS_MIN_HZ	redis.h	/^#define REDIS_MIN_HZ /;"	d
REDIS_MIN_RESERVED_FDS	redis.h	/^#define REDIS_MIN_RESERVED_FDS /;"	d
REDIS_MONITOR	redis.h	/^#define REDIS_MONITOR /;"	d
REDIS_MULTI	redis.h	/^#define REDIS_MULTI /;"	d
REDIS_NODE_FAIL	cluster.h	/^#define REDIS_NODE_FAIL /;"	d
REDIS_NODE_HANDSHAKE	cluster.h	/^#define REDIS_NODE_HANDSHAKE /;"	d
REDIS_NODE_MASTER	cluster.h	/^#define REDIS_NODE_MASTER /;"	d
REDIS_NODE_MEET	cluster.h	/^#define REDIS_NODE_MEET /;"	d
REDIS_NODE_MYSELF	cluster.h	/^#define REDIS_NODE_MYSELF /;"	d
REDIS_NODE_NOADDR	cluster.h	/^#define REDIS_NODE_NOADDR /;"	d
REDIS_NODE_NULL_NAME	cluster.h	/^#define REDIS_NODE_NULL_NAME /;"	d
REDIS_NODE_PFAIL	cluster.h	/^#define REDIS_NODE_PFAIL /;"	d
REDIS_NODE_PROMOTED	cluster.h	/^#define REDIS_NODE_PROMOTED /;"	d
REDIS_NODE_SLAVE	cluster.h	/^#define REDIS_NODE_SLAVE /;"	d
REDIS_NOTICE	redis.h	/^#define REDIS_NOTICE /;"	d
REDIS_NOTIFY_ALL	redis.h	/^#define REDIS_NOTIFY_ALL /;"	d
REDIS_NOTIFY_EVICTED	redis.h	/^#define REDIS_NOTIFY_EVICTED /;"	d
REDIS_NOTIFY_EXPIRED	redis.h	/^#define REDIS_NOTIFY_EXPIRED /;"	d
REDIS_NOTIFY_GENERIC	redis.h	/^#define REDIS_NOTIFY_GENERIC /;"	d
REDIS_NOTIFY_HASH	redis.h	/^#define REDIS_NOTIFY_HASH /;"	d
REDIS_NOTIFY_KEYEVENT	redis.h	/^#define REDIS_NOTIFY_KEYEVENT /;"	d
REDIS_NOTIFY_KEYSPACE	redis.h	/^#define REDIS_NOTIFY_KEYSPACE /;"	d
REDIS_NOTIFY_LIST	redis.h	/^#define REDIS_NOTIFY_LIST /;"	d
REDIS_NOTIFY_SET	redis.h	/^#define REDIS_NOTIFY_SET /;"	d
REDIS_NOTIFY_STRING	redis.h	/^#define REDIS_NOTIFY_STRING /;"	d
REDIS_NOTIFY_ZSET	redis.h	/^#define REDIS_NOTIFY_ZSET /;"	d
REDIS_NOTUSED	redis-benchmark.c	/^#define REDIS_NOTUSED(/;"	d	file:
REDIS_NOTUSED	redis-cli.c	/^#define REDIS_NOTUSED(/;"	d	file:
REDIS_NOTUSED	redis.h	/^#define REDIS_NOTUSED(/;"	d
REDIS_OK	redis.h	/^#define REDIS_OK /;"	d
REDIS_OP_DIFF	redis.h	/^#define REDIS_OP_DIFF /;"	d
REDIS_OP_DIFF	t_set.c	/^#define REDIS_OP_DIFF /;"	d	file:
REDIS_OP_INTER	redis.h	/^#define REDIS_OP_INTER /;"	d
REDIS_OP_INTER	t_set.c	/^#define REDIS_OP_INTER /;"	d	file:
REDIS_OP_UNION	redis.h	/^#define REDIS_OP_UNION /;"	d
REDIS_OP_UNION	t_set.c	/^#define REDIS_OP_UNION /;"	d	file:
REDIS_PEER_ID_LEN	redis.h	/^#define REDIS_PEER_ID_LEN /;"	d
REDIS_PRE_PSYNC	redis.h	/^#define REDIS_PRE_PSYNC /;"	d
REDIS_PROPAGATE_AOF	redis.h	/^#define REDIS_PROPAGATE_AOF /;"	d
REDIS_PROPAGATE_NONE	redis.h	/^#define REDIS_PROPAGATE_NONE /;"	d
REDIS_PROPAGATE_REPL	redis.h	/^#define REDIS_PROPAGATE_REPL /;"	d
REDIS_PUBSUB	redis.h	/^#define REDIS_PUBSUB /;"	d
REDIS_RANDOM_H	rand.h	/^#define REDIS_RANDOM_H$/;"	d
REDIS_RDB_14BITLEN	rdb.h	/^#define REDIS_RDB_14BITLEN /;"	d
REDIS_RDB_14BITLEN	redis-check-dump.c	/^#define REDIS_RDB_14BITLEN /;"	d	file:
REDIS_RDB_14BITLEN	redis.h	/^#define REDIS_RDB_14BITLEN /;"	d
REDIS_RDB_32BITLEN	rdb.h	/^#define REDIS_RDB_32BITLEN /;"	d
REDIS_RDB_32BITLEN	redis-check-dump.c	/^#define REDIS_RDB_32BITLEN /;"	d	file:
REDIS_RDB_32BITLEN	redis.h	/^#define REDIS_RDB_32BITLEN /;"	d
REDIS_RDB_6BITLEN	rdb.h	/^#define REDIS_RDB_6BITLEN /;"	d
REDIS_RDB_6BITLEN	redis-check-dump.c	/^#define REDIS_RDB_6BITLEN /;"	d	file:
REDIS_RDB_6BITLEN	redis.h	/^#define REDIS_RDB_6BITLEN /;"	d
REDIS_RDB_CHILD_TYPE_DISK	redis.h	/^#define REDIS_RDB_CHILD_TYPE_DISK /;"	d
REDIS_RDB_CHILD_TYPE_NONE	redis.h	/^#define REDIS_RDB_CHILD_TYPE_NONE /;"	d
REDIS_RDB_CHILD_TYPE_SOCKET	redis.h	/^#define REDIS_RDB_CHILD_TYPE_SOCKET /;"	d
REDIS_RDB_ENCVAL	rdb.h	/^#define REDIS_RDB_ENCVAL /;"	d
REDIS_RDB_ENCVAL	redis-check-dump.c	/^#define REDIS_RDB_ENCVAL /;"	d	file:
REDIS_RDB_ENCVAL	redis.h	/^#define REDIS_RDB_ENCVAL /;"	d
REDIS_RDB_ENC_INT16	rdb.h	/^#define REDIS_RDB_ENC_INT16 /;"	d
REDIS_RDB_ENC_INT16	redis-check-dump.c	/^#define REDIS_RDB_ENC_INT16 /;"	d	file:
REDIS_RDB_ENC_INT16	redis.h	/^#define REDIS_RDB_ENC_INT16 /;"	d
REDIS_RDB_ENC_INT32	rdb.h	/^#define REDIS_RDB_ENC_INT32 /;"	d
REDIS_RDB_ENC_INT32	redis-check-dump.c	/^#define REDIS_RDB_ENC_INT32 /;"	d	file:
REDIS_RDB_ENC_INT32	redis.h	/^#define REDIS_RDB_ENC_INT32 /;"	d
REDIS_RDB_ENC_INT8	rdb.h	/^#define REDIS_RDB_ENC_INT8 /;"	d
REDIS_RDB_ENC_INT8	redis-check-dump.c	/^#define REDIS_RDB_ENC_INT8 /;"	d	file:
REDIS_RDB_ENC_INT8	redis.h	/^#define REDIS_RDB_ENC_INT8 /;"	d
REDIS_RDB_ENC_LZF	rdb.h	/^#define REDIS_RDB_ENC_LZF /;"	d
REDIS_RDB_ENC_LZF	redis-check-dump.c	/^#define REDIS_RDB_ENC_LZF /;"	d	file:
REDIS_RDB_ENC_LZF	redis.h	/^#define REDIS_RDB_ENC_LZF /;"	d
REDIS_RDB_LENERR	rdb.h	/^#define REDIS_RDB_LENERR /;"	d
REDIS_RDB_LENERR	redis-check-dump.c	/^#define REDIS_RDB_LENERR /;"	d	file:
REDIS_RDB_LENERR	redis.h	/^#define REDIS_RDB_LENERR /;"	d
REDIS_RDB_OPCODE_EOF	rdb.h	/^#define REDIS_RDB_OPCODE_EOF /;"	d
REDIS_RDB_OPCODE_EXPIRETIME	rdb.h	/^#define REDIS_RDB_OPCODE_EXPIRETIME /;"	d
REDIS_RDB_OPCODE_EXPIRETIME_MS	rdb.h	/^#define REDIS_RDB_OPCODE_EXPIRETIME_MS /;"	d
REDIS_RDB_OPCODE_SELECTDB	rdb.h	/^#define REDIS_RDB_OPCODE_SELECTDB /;"	d
REDIS_RDB_TYPE_HASH	rdb.h	/^#define REDIS_RDB_TYPE_HASH /;"	d
REDIS_RDB_TYPE_HASH_ZIPLIST	rdb.h	/^#define REDIS_RDB_TYPE_HASH_ZIPLIST /;"	d
REDIS_RDB_TYPE_HASH_ZIPMAP	rdb.h	/^#define REDIS_RDB_TYPE_HASH_ZIPMAP /;"	d
REDIS_RDB_TYPE_LIST	rdb.h	/^#define REDIS_RDB_TYPE_LIST /;"	d
REDIS_RDB_TYPE_LIST_ZIPLIST	rdb.h	/^#define REDIS_RDB_TYPE_LIST_ZIPLIST /;"	d
REDIS_RDB_TYPE_SET	rdb.h	/^#define REDIS_RDB_TYPE_SET /;"	d
REDIS_RDB_TYPE_SET_INTSET	rdb.h	/^#define REDIS_RDB_TYPE_SET_INTSET /;"	d
REDIS_RDB_TYPE_STRING	rdb.h	/^#define REDIS_RDB_TYPE_STRING /;"	d
REDIS_RDB_TYPE_ZSET	rdb.h	/^#define REDIS_RDB_TYPE_ZSET /;"	d
REDIS_RDB_TYPE_ZSET_ZIPLIST	rdb.h	/^#define REDIS_RDB_TYPE_ZSET_ZIPLIST /;"	d
REDIS_RDB_VERSION	rdb.h	/^#define REDIS_RDB_VERSION /;"	d
REDIS_READONLY	redis.h	/^#define REDIS_READONLY /;"	d
REDIS_REPLY_CHUNK_BYTES	redis.h	/^#define REDIS_REPLY_CHUNK_BYTES /;"	d
REDIS_REPL_BACKLOG_MIN_SIZE	redis.h	/^#define REDIS_REPL_BACKLOG_MIN_SIZE /;"	d
REDIS_REPL_CONNECT	redis.h	/^#define REDIS_REPL_CONNECT /;"	d
REDIS_REPL_CONNECTED	redis.h	/^#define REDIS_REPL_CONNECTED /;"	d
REDIS_REPL_CONNECTING	redis.h	/^#define REDIS_REPL_CONNECTING /;"	d
REDIS_REPL_NONE	redis.h	/^#define REDIS_REPL_NONE /;"	d
REDIS_REPL_ONLINE	redis.h	/^#define REDIS_REPL_ONLINE /;"	d
REDIS_REPL_PING_SLAVE_PERIOD	redis.h	/^#define REDIS_REPL_PING_SLAVE_PERIOD /;"	d
REDIS_REPL_RECEIVE_AUTH	redis.h	/^#define REDIS_REPL_RECEIVE_AUTH /;"	d
REDIS_REPL_RECEIVE_CAPA	redis.h	/^#define REDIS_REPL_RECEIVE_CAPA /;"	d
REDIS_REPL_RECEIVE_PONG	redis.h	/^#define REDIS_REPL_RECEIVE_PONG /;"	d
REDIS_REPL_RECEIVE_PORT	redis.h	/^#define REDIS_REPL_RECEIVE_PORT /;"	d
REDIS_REPL_RECEIVE_PSYNC	redis.h	/^#define REDIS_REPL_RECEIVE_PSYNC /;"	d
REDIS_REPL_SEND_AUTH	redis.h	/^#define REDIS_REPL_SEND_AUTH /;"	d
REDIS_REPL_SEND_BULK	redis.h	/^#define REDIS_REPL_SEND_BULK /;"	d
REDIS_REPL_SEND_CAPA	redis.h	/^#define REDIS_REPL_SEND_CAPA /;"	d
REDIS_REPL_SEND_PORT	redis.h	/^#define REDIS_REPL_SEND_PORT /;"	d
REDIS_REPL_SEND_PSYNC	redis.h	/^#define REDIS_REPL_SEND_PSYNC /;"	d
REDIS_REPL_SYNCIO_TIMEOUT	redis.h	/^#define REDIS_REPL_SYNCIO_TIMEOUT /;"	d
REDIS_REPL_TIMEOUT	redis.h	/^#define REDIS_REPL_TIMEOUT /;"	d
REDIS_REPL_TRANSFER	redis.h	/^#define REDIS_REPL_TRANSFER /;"	d
REDIS_REPL_WAIT_BGSAVE_END	redis.h	/^#define REDIS_REPL_WAIT_BGSAVE_END /;"	d
REDIS_REPL_WAIT_BGSAVE_START	redis.h	/^#define REDIS_REPL_WAIT_BGSAVE_START /;"	d
REDIS_REQ_INLINE	redis.h	/^#define REDIS_REQ_INLINE /;"	d
REDIS_REQ_MULTIBULK	redis.h	/^#define REDIS_REQ_MULTIBULK /;"	d
REDIS_RUN_ID_SIZE	redis.h	/^#define REDIS_RUN_ID_SIZE /;"	d
REDIS_SELECTDB	redis-check-dump.c	/^#define REDIS_SELECTDB /;"	d	file:
REDIS_SENTINEL_NAME	Makefile	/^REDIS_SENTINEL_NAME=redis-sentinel$/;"	m
REDIS_SENTINEL_PORT	sentinel.c	/^#define REDIS_SENTINEL_PORT /;"	d	file:
REDIS_SERVERPORT	redis.h	/^#define REDIS_SERVERPORT /;"	d
REDIS_SERVER_NAME	Makefile	/^REDIS_SERVER_NAME=redis-server$/;"	m
REDIS_SERVER_OBJ	Makefile	/^REDIS_SERVER_OBJ=adlist.o ae.o anet.o dict.o redis.o sds.o zmalloc.o lzf_c.o lzf_d.o pqsort.o zipmap.o sha1.o ziplist.o release.o networking.o util.o object.o db.o replication.o rdb.o t_string.o t_list.o t_set.o t_zset.o t_hash.o config.o aof.o pubsub.o multi.o debug.o sort.o intset.o syncio.o cluster.o crc16.o endianconv.o slowlog.o scripting.o bio.o rio.o rand.o memtest.o crc64.o bitops.o sentinel.o notify.o setproctitle.o blocked.o hyperloglog.o latency.o sparkline.o$/;"	m
REDIS_SET	redis-check-dump.c	/^#define REDIS_SET /;"	d	file:
REDIS_SET	redis.h	/^#define REDIS_SET /;"	d
REDIS_SET_INTSET	redis-check-dump.c	/^#define REDIS_SET_INTSET /;"	d	file:
REDIS_SET_MAX_INTSET_ENTRIES	redis.h	/^#define REDIS_SET_MAX_INTSET_ENTRIES /;"	d
REDIS_SET_NO_FLAGS	t_string.c	/^#define REDIS_SET_NO_FLAGS /;"	d	file:
REDIS_SET_NX	t_string.c	/^#define REDIS_SET_NX /;"	d	file:
REDIS_SET_XX	t_string.c	/^#define REDIS_SET_XX /;"	d	file:
REDIS_SHARED_BULKHDR_LEN	redis.h	/^#define REDIS_SHARED_BULKHDR_LEN /;"	d
REDIS_SHARED_INTEGERS	redis.h	/^#define REDIS_SHARED_INTEGERS /;"	d
REDIS_SHARED_SELECT_CMDS	redis.h	/^#define REDIS_SHARED_SELECT_CMDS /;"	d
REDIS_SHUTDOWN_NOSAVE	redis.h	/^#define REDIS_SHUTDOWN_NOSAVE /;"	d
REDIS_SHUTDOWN_SAVE	redis.h	/^#define REDIS_SHUTDOWN_SAVE /;"	d
REDIS_SLAVE	redis.h	/^#define REDIS_SLAVE /;"	d
REDIS_SLOWLOG_LOG_SLOWER_THAN	redis.h	/^#define REDIS_SLOWLOG_LOG_SLOWER_THAN /;"	d
REDIS_SLOWLOG_MAX_LEN	redis.h	/^#define REDIS_SLOWLOG_MAX_LEN /;"	d
REDIS_SORTKEY_MAX	redis.h	/^#define REDIS_SORTKEY_MAX /;"	d
REDIS_SORT_ASC	redis.h	/^#define REDIS_SORT_ASC /;"	d
REDIS_SORT_DESC	redis.h	/^#define REDIS_SORT_DESC /;"	d
REDIS_SORT_GET	redis.h	/^#define REDIS_SORT_GET /;"	d
REDIS_STRING	redis-check-dump.c	/^#define REDIS_STRING /;"	d	file:
REDIS_STRING	redis.h	/^#define REDIS_STRING /;"	d
REDIS_SYNCIO_RESOLUTION	syncio.c	/^#define REDIS_SYNCIO_RESOLUTION /;"	d	file:
REDIS_TAIL	redis.h	/^#define REDIS_TAIL /;"	d
REDIS_TCP_BACKLOG	redis.h	/^#define REDIS_TCP_BACKLOG /;"	d
REDIS_THREAD_STACK_SIZE	bio.c	/^#define REDIS_THREAD_STACK_SIZE /;"	d	file:
REDIS_UNBLOCKED	redis.h	/^#define REDIS_UNBLOCKED /;"	d
REDIS_UNIX_SOCKET	redis.h	/^#define REDIS_UNIX_SOCKET /;"	d
REDIS_VERBOSE	redis.h	/^#define REDIS_VERBOSE /;"	d
REDIS_VERSION	version.h	/^#define REDIS_VERSION /;"	d
REDIS_WARNING	redis.h	/^#define REDIS_WARNING /;"	d
REDIS_ZSET	redis-check-dump.c	/^#define REDIS_ZSET /;"	d	file:
REDIS_ZSET	redis.h	/^#define REDIS_ZSET /;"	d
REDIS_ZSET_MAX_ZIPLIST_ENTRIES	redis.h	/^#define REDIS_ZSET_MAX_ZIPLIST_ENTRIES /;"	d
REDIS_ZSET_MAX_ZIPLIST_VALUE	redis.h	/^#define REDIS_ZSET_MAX_ZIPLIST_VALUE /;"	d
REDIS_ZSET_ZIPLIST	redis-check-dump.c	/^#define REDIS_ZSET_ZIPLIST /;"	d	file:
REPL_MAX_WRITTEN_BEFORE_FSYNC	replication.c	/^#define REPL_MAX_WRITTEN_BEFORE_FSYNC /;"	d	file:
REST	rand.c	/^#define REST(/;"	d	file:
REV_FINAL_CFLAGS	Makefile	/^	echo PREV_FINAL_CFLAGS=$(FINAL_CFLAGS) >> .make-settings$/;"	m
REV_FINAL_LDFLAGS	Makefile	/^	echo PREV_FINAL_LDFLAGS=$(FINAL_LDFLAGS) >> .make-settings$/;"	m
R_Nan	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_Nan	redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_Nan	redis.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x
R_NegInf	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_NegInf	redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_NegInf	redis.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x
R_PosInf	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_PosInf	redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_PosInf	redis.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x
R_Zero	redis-check-dump.c	/^static double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v	file:
R_Zero	redis.c	/^double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	v
R_Zero	redis.h	/^extern double R_Zero, R_PosInf, R_NegInf, R_Nan;$/;"	x
RedisClusterCRC16	redis-trib.rb	/^module RedisClusterCRC16$/;"	m	class:RedisTrib
RedisTrib	redis-trib.rb	/^class RedisTrib$/;"	c
SA_ONSTACK	debug.c	/^#define SA_ONSTACK /;"	d	file:
SDS_LLSTR_SIZE	sds.c	/^#define SDS_LLSTR_SIZE /;"	d	file:
SDS_MAX_PREALLOC	sds.h	/^#define SDS_MAX_PREALLOC /;"	d
SEED	rand.c	/^#define SEED(/;"	d	file:
SENTINEL_ASK_FORCED	sentinel.c	/^#define SENTINEL_ASK_FORCED /;"	d	file:
SENTINEL_ASK_PERIOD	sentinel.c	/^#define SENTINEL_ASK_PERIOD /;"	d	file:
SENTINEL_DEFAULT_DOWN_AFTER	sentinel.c	/^#define SENTINEL_DEFAULT_DOWN_AFTER /;"	d	file:
SENTINEL_DEFAULT_FAILOVER_TIMEOUT	sentinel.c	/^#define SENTINEL_DEFAULT_FAILOVER_TIMEOUT /;"	d	file:
SENTINEL_DEFAULT_PARALLEL_SYNCS	sentinel.c	/^#define SENTINEL_DEFAULT_PARALLEL_SYNCS /;"	d	file:
SENTINEL_DEFAULT_SLAVE_PRIORITY	sentinel.c	/^#define SENTINEL_DEFAULT_SLAVE_PRIORITY /;"	d	file:
SENTINEL_ELECTION_TIMEOUT	sentinel.c	/^#define SENTINEL_ELECTION_TIMEOUT /;"	d	file:
SENTINEL_FAILOVER_STATE_NONE	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_NONE /;"	d	file:
SENTINEL_FAILOVER_STATE_RECONF_SLAVES	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_RECONF_SLAVES /;"	d	file:
SENTINEL_FAILOVER_STATE_SELECT_SLAVE	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_SELECT_SLAVE /;"	d	file:
SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE /;"	d	file:
SENTINEL_FAILOVER_STATE_UPDATE_CONFIG	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_UPDATE_CONFIG /;"	d	file:
SENTINEL_FAILOVER_STATE_WAIT_PROMOTION	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_WAIT_PROMOTION /;"	d	file:
SENTINEL_FAILOVER_STATE_WAIT_START	sentinel.c	/^#define SENTINEL_FAILOVER_STATE_WAIT_START /;"	d	file:
SENTINEL_GENERATE_EVENT	sentinel.c	/^#define SENTINEL_GENERATE_EVENT /;"	d	file:
SENTINEL_HELLO_CHANNEL	sentinel.c	/^#define SENTINEL_HELLO_CHANNEL /;"	d	file:
SENTINEL_INFO_PERIOD	sentinel.c	/^#define SENTINEL_INFO_PERIOD /;"	d	file:
SENTINEL_ISQR_NOAUTH	sentinel.c	/^#define SENTINEL_ISQR_NOAUTH /;"	d	file:
SENTINEL_ISQR_NOQUORUM	sentinel.c	/^#define SENTINEL_ISQR_NOQUORUM /;"	d	file:
SENTINEL_ISQR_OK	sentinel.c	/^#define SENTINEL_ISQR_OK /;"	d	file:
SENTINEL_LEADER	sentinel.c	/^#define SENTINEL_LEADER /;"	d	file:
SENTINEL_MASTER_LINK_STATUS_DOWN	sentinel.c	/^#define SENTINEL_MASTER_LINK_STATUS_DOWN /;"	d	file:
SENTINEL_MASTER_LINK_STATUS_UP	sentinel.c	/^#define SENTINEL_MASTER_LINK_STATUS_UP /;"	d	file:
SENTINEL_MAX_DESYNC	sentinel.c	/^#define SENTINEL_MAX_DESYNC /;"	d	file:
SENTINEL_MAX_PENDING_COMMANDS	sentinel.c	/^#define SENTINEL_MAX_PENDING_COMMANDS /;"	d	file:
SENTINEL_MIN_LINK_RECONNECT_PERIOD	sentinel.c	/^#define SENTINEL_MIN_LINK_RECONNECT_PERIOD /;"	d	file:
SENTINEL_NO_FLAGS	sentinel.c	/^#define SENTINEL_NO_FLAGS /;"	d	file:
SENTINEL_OBSERVER	sentinel.c	/^#define SENTINEL_OBSERVER /;"	d	file:
SENTINEL_PING_PERIOD	sentinel.c	/^#define SENTINEL_PING_PERIOD /;"	d	file:
SENTINEL_PUBLISH_PERIOD	sentinel.c	/^#define SENTINEL_PUBLISH_PERIOD /;"	d	file:
SENTINEL_RESET_NO_SENTINELS	sentinel.c	/^#define SENTINEL_RESET_NO_SENTINELS /;"	d	file:
SENTINEL_SCRIPT_MAX_ARGS	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_ARGS /;"	d	file:
SENTINEL_SCRIPT_MAX_QUEUE	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_QUEUE /;"	d	file:
SENTINEL_SCRIPT_MAX_RETRY	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_RETRY /;"	d	file:
SENTINEL_SCRIPT_MAX_RUNNING	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_RUNNING /;"	d	file:
SENTINEL_SCRIPT_MAX_RUNTIME	sentinel.c	/^#define SENTINEL_SCRIPT_MAX_RUNTIME /;"	d	file:
SENTINEL_SCRIPT_NONE	sentinel.c	/^#define SENTINEL_SCRIPT_NONE /;"	d	file:
SENTINEL_SCRIPT_RETRY_DELAY	sentinel.c	/^#define SENTINEL_SCRIPT_RETRY_DELAY /;"	d	file:
SENTINEL_SCRIPT_RUNNING	sentinel.c	/^#define SENTINEL_SCRIPT_RUNNING /;"	d	file:
SENTINEL_SLAVE_RECONF_TIMEOUT	sentinel.c	/^#define SENTINEL_SLAVE_RECONF_TIMEOUT /;"	d	file:
SENTINEL_TILT_PERIOD	sentinel.c	/^#define SENTINEL_TILT_PERIOD /;"	d	file:
SENTINEL_TILT_TRIGGER	sentinel.c	/^#define SENTINEL_TILT_TRIGGER /;"	d	file:
SET3	rand.c	/^#define SET3(/;"	d	file:
SETLOW	rand.c	/^#define SETLOW(/;"	d	file:
SET_ERRNO	lzf_d.c	/^# define SET_ERRNO(/;"	d	file:
SHA1Final	sha1.c	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context)$/;"	f	signature:(unsigned char digest[20], SHA1_CTX* context)
SHA1Final	sha1.h	/^void SHA1Final(unsigned char digest[20], SHA1_CTX* context);$/;"	p	signature:(unsigned char digest[20], SHA1_CTX* context)
SHA1HANDSOFF	sha1.c	/^#define SHA1HANDSOFF$/;"	d	file:
SHA1Init	sha1.c	/^void SHA1Init(SHA1_CTX* context)$/;"	f	signature:(SHA1_CTX* context)
SHA1Init	sha1.h	/^void SHA1Init(SHA1_CTX* context);$/;"	p	signature:(SHA1_CTX* context)
SHA1Transform	sha1.c	/^void SHA1Transform(uint32_t state[5], const unsigned char buffer[64])$/;"	f	signature:(uint32_t state[5], const unsigned char buffer[64])
SHA1Transform	sha1.h	/^void SHA1Transform(uint32_t state[5], const unsigned char buffer[64]);$/;"	p	signature:(uint32_t state[5], const unsigned char buffer[64])
SHA1Update	sha1.c	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len)$/;"	f	signature:(SHA1_CTX* context, const unsigned char* data, uint32_t len)
SHA1Update	sha1.h	/^void SHA1Update(SHA1_CTX* context, const unsigned char* data, uint32_t len);$/;"	p	signature:(SHA1_CTX* context, const unsigned char* data, uint32_t len)
SHA1_CTX	sha1.h	/^} SHA1_CTX;$/;"	t	typeref:struct:__anon29
SHIFT_ERROR	redis-check-dump.c	/^#define SHIFT_ERROR(/;"	d	file:
SLAVE_CAPA_EOF	redis.h	/^#define SLAVE_CAPA_EOF /;"	d
SLAVE_CAPA_NONE	redis.h	/^#define SLAVE_CAPA_NONE /;"	d
SLOWLOG_ENTRY_MAX_ARGC	slowlog.h	/^#define SLOWLOG_ENTRY_MAX_ARGC /;"	d
SLOWLOG_ENTRY_MAX_STRING	slowlog.h	/^#define SLOWLOG_ENTRY_MAX_STRING /;"	d
SPARKLINE_FILL	sparkline.h	/^#define SPARKLINE_FILL /;"	d
SPARKLINE_LOG_SCALE	sparkline.h	/^#define SPARKLINE_LOG_SCALE /;"	d
SPARKLINE_NO_FLAGS	sparkline.h	/^#define SPARKLINE_NO_FLAGS /;"	d
SPT	setproctitle.c	/^} SPT;$/;"	v	typeref:struct:__anon28	file:
SPT_MAXTITLE	setproctitle.c	/^#define SPT_MAXTITLE /;"	d	file:
SPT_MIN	setproctitle.c	/^#define SPT_MIN(/;"	d	file:
SRANDMEMBER_SUB_STRATEGY_MUL	t_set.c	/^#define SRANDMEMBER_SUB_STRATEGY_MUL /;"	d	file:
SRCCOLOR	Makefile	/^SRCCOLOR="\\033[33m"$/;"	m
SRI_DISCONNECTED	sentinel.c	/^#define SRI_DISCONNECTED /;"	d	file:
SRI_FAILOVER_IN_PROGRESS	sentinel.c	/^#define SRI_FAILOVER_IN_PROGRESS /;"	d	file:
SRI_FORCE_FAILOVER	sentinel.c	/^#define SRI_FORCE_FAILOVER /;"	d	file:
SRI_MASTER	sentinel.c	/^#define SRI_MASTER /;"	d	file:
SRI_MASTER_DOWN	sentinel.c	/^#define SRI_MASTER_DOWN /;"	d	file:
SRI_O_DOWN	sentinel.c	/^#define SRI_O_DOWN /;"	d	file:
SRI_PROMOTED	sentinel.c	/^#define SRI_PROMOTED /;"	d	file:
SRI_RECONF_DONE	sentinel.c	/^#define SRI_RECONF_DONE /;"	d	file:
SRI_RECONF_INPROG	sentinel.c	/^#define SRI_RECONF_INPROG /;"	d	file:
SRI_RECONF_SENT	sentinel.c	/^#define SRI_RECONF_SENT /;"	d	file:
SRI_SCRIPT_KILL_SENT	sentinel.c	/^#define SRI_SCRIPT_KILL_SENT /;"	d	file:
SRI_SENTINEL	sentinel.c	/^#define SRI_SENTINEL /;"	d	file:
SRI_SLAVE	sentinel.c	/^#define SRI_SLAVE /;"	d	file:
SRI_S_DOWN	sentinel.c	/^#define SRI_S_DOWN /;"	d	file:
STANDALONE	lzfP.h	/^#define STANDALONE /;"	d
STD	Makefile	/^STD=-std=c99 -pedantic$/;"	m
STRICT_ALIGN	lzfP.h	/^#  define STRICT_ALIGN /;"	d
STRICT_ALIGN	lzfP.h	/^#  undef STRICT_ALIGN$/;"	d
STRICT_ALIGN	lzfP.h	/^# define STRICT_ALIGN /;"	d
SWAPINIT	pqsort.c	/^#define SWAPINIT(/;"	d	file:
SYNC_CMD_FULL	replication.c	/^#define SYNC_CMD_FULL /;"	d	file:
SYNC_CMD_READ	replication.c	/^#define SYNC_CMD_READ /;"	d	file:
SYNC_CMD_WRITE	replication.c	/^#define SYNC_CMD_WRITE /;"	d	file:
TD	Makefile	/^	echo STD=$(STD) >> .make-settings$/;"	m
THPGetAnonHugePagesSize	latency.c	/^int THPGetAnonHugePagesSize(void) {$/;"	f	signature:(void)
THPIsEnabled	latency.c	/^int THPIsEnabled(void) {$/;"	f	signature:(void)
THPIsEnabled	latency.h	/^int THPIsEnabled(void);$/;"	p	signature:(void)
TYPE_HASH	redis-cli.c	/^#define TYPE_HASH /;"	d	file:
TYPE_LIST	redis-cli.c	/^#define TYPE_LIST /;"	d	file:
TYPE_NONE	redis-cli.c	/^#define TYPE_NONE /;"	d	file:
TYPE_SET	redis-cli.c	/^#define TYPE_SET /;"	d	file:
TYPE_STRING	redis-cli.c	/^#define TYPE_STRING /;"	d	file:
TYPE_ZSET	redis-cli.c	/^#define TYPE_ZSET /;"	d	file:
ULONG_ONEZERO	memtest.c	/^#define ULONG_ONEZERO /;"	d	file:
ULONG_ZEROONE	memtest.c	/^#define ULONG_ZEROONE /;"	d	file:
ULTRA_FAST	lzfP.h	/^# define ULTRA_FAST /;"	d
UNIT_MILLISECONDS	redis.h	/^#define UNIT_MILLISECONDS /;"	d
UNIT_SECONDS	redis.h	/^#define UNIT_SECONDS /;"	d
USE_SETPROCTITLE	config.h	/^#define USE_SETPROCTITLE$/;"	d
VERY_FAST	lzfP.h	/^#  undef VERY_FAST$/;"	d
VERY_FAST	lzfP.h	/^# define VERY_FAST /;"	d
WARN	Makefile	/^WARN=-Wall -W$/;"	m
X0	rand.c	/^#define X0	/;"	d	file:
X1	rand.c	/^#define X1	/;"	d	file:
X2	rand.c	/^#define X2	/;"	d	file:
ZADD_CH	t_zset.c	/^#define ZADD_CH /;"	d	file:
ZADD_INCR	t_zset.c	/^#define ZADD_INCR /;"	d	file:
ZADD_NONE	t_zset.c	/^#define ZADD_NONE /;"	d	file:
ZADD_NX	t_zset.c	/^#define ZADD_NX /;"	d	file:
ZADD_XX	t_zset.c	/^#define ZADD_XX /;"	d	file:
ZIPLIST_BYTES	ziplist.c	/^#define ZIPLIST_BYTES(/;"	d	file:
ZIPLIST_ENTRY_END	ziplist.c	/^#define ZIPLIST_ENTRY_END(/;"	d	file:
ZIPLIST_ENTRY_HEAD	ziplist.c	/^#define ZIPLIST_ENTRY_HEAD(/;"	d	file:
ZIPLIST_ENTRY_TAIL	ziplist.c	/^#define ZIPLIST_ENTRY_TAIL(/;"	d	file:
ZIPLIST_HEAD	ziplist.h	/^#define ZIPLIST_HEAD /;"	d
ZIPLIST_HEADER_SIZE	ziplist.c	/^#define ZIPLIST_HEADER_SIZE /;"	d	file:
ZIPLIST_INCR_LENGTH	ziplist.c	/^#define ZIPLIST_INCR_LENGTH(/;"	d	file:
ZIPLIST_LENGTH	ziplist.c	/^#define ZIPLIST_LENGTH(/;"	d	file:
ZIPLIST_TAIL	ziplist.h	/^#define ZIPLIST_TAIL /;"	d
ZIPLIST_TAIL_OFFSET	ziplist.c	/^#define ZIPLIST_TAIL_OFFSET(/;"	d	file:
ZIPMAP_BIGLEN	zipmap.c	/^#define ZIPMAP_BIGLEN /;"	d	file:
ZIPMAP_END	zipmap.c	/^#define ZIPMAP_END /;"	d	file:
ZIPMAP_LEN_BYTES	zipmap.c	/^#define ZIPMAP_LEN_BYTES(/;"	d	file:
ZIPMAP_VALUE_MAX_FREE	zipmap.c	/^#define ZIPMAP_VALUE_MAX_FREE /;"	d	file:
ZIP_BIGLEN	ziplist.c	/^#define ZIP_BIGLEN /;"	d	file:
ZIP_DECODE_LENGTH	ziplist.c	/^#define ZIP_DECODE_LENGTH(/;"	d	file:
ZIP_DECODE_PREVLEN	ziplist.c	/^#define ZIP_DECODE_PREVLEN(/;"	d	file:
ZIP_DECODE_PREVLENSIZE	ziplist.c	/^#define ZIP_DECODE_PREVLENSIZE(/;"	d	file:
ZIP_END	ziplist.c	/^#define ZIP_END /;"	d	file:
ZIP_ENTRY_ENCODING	ziplist.c	/^#define ZIP_ENTRY_ENCODING(/;"	d	file:
ZIP_INT_16B	ziplist.c	/^#define ZIP_INT_16B /;"	d	file:
ZIP_INT_24B	ziplist.c	/^#define ZIP_INT_24B /;"	d	file:
ZIP_INT_32B	ziplist.c	/^#define ZIP_INT_32B /;"	d	file:
ZIP_INT_64B	ziplist.c	/^#define ZIP_INT_64B /;"	d	file:
ZIP_INT_8B	ziplist.c	/^#define ZIP_INT_8B /;"	d	file:
ZIP_INT_IMM_MASK	ziplist.c	/^#define ZIP_INT_IMM_MASK /;"	d	file:
ZIP_INT_IMM_MAX	ziplist.c	/^#define ZIP_INT_IMM_MAX /;"	d	file:
ZIP_INT_IMM_MIN	ziplist.c	/^#define ZIP_INT_IMM_MIN /;"	d	file:
ZIP_INT_IMM_VAL	ziplist.c	/^#define ZIP_INT_IMM_VAL(/;"	d	file:
ZIP_INT_MASK	ziplist.c	/^#define ZIP_INT_MASK /;"	d	file:
ZIP_IS_STR	ziplist.c	/^#define ZIP_IS_STR(/;"	d	file:
ZIP_STR_06B	ziplist.c	/^#define ZIP_STR_06B /;"	d	file:
ZIP_STR_14B	ziplist.c	/^#define ZIP_STR_14B /;"	d	file:
ZIP_STR_32B	ziplist.c	/^#define ZIP_STR_32B /;"	d	file:
ZIP_STR_MASK	ziplist.c	/^#define ZIP_STR_MASK /;"	d	file:
ZMALLOC_LIB	zmalloc.h	/^#define ZMALLOC_LIB /;"	d
ZRANGE_LEX	t_zset.c	/^#define ZRANGE_LEX /;"	d	file:
ZRANGE_RANK	t_zset.c	/^#define ZRANGE_RANK /;"	d	file:
ZRANGE_SCORE	t_zset.c	/^#define ZRANGE_SCORE /;"	d	file:
ZSKIPLIST_MAXLEVEL	redis.h	/^#define ZSKIPLIST_MAXLEVEL /;"	d
ZSKIPLIST_P	redis.h	/^#define ZSKIPLIST_P /;"	d
_ALL_SOURCE	fmacros.h	/^#define _ALL_SOURCE$/;"	d
_BSD_SOURCE	fmacros.h	/^#define _BSD_SOURCE$/;"	d
_DEFAULT_SOURCE	fmacros.h	/^#define _DEFAULT_SOURCE$/;"	d
_FILE_OFFSET_BITS	fmacros.h	/^#define _FILE_OFFSET_BITS /;"	d
_GNU_SOURCE	fmacros.h	/^#define _GNU_SOURCE$/;"	d
_GNU_SOURCE	setproctitle.c	/^#define _GNU_SOURCE$/;"	d	file:
_LARGEFILE_SOURCE	fmacros.h	/^#define _LARGEFILE_SOURCE$/;"	d
_POSIX_C_SOURCE	fmacros.h	/^#define _POSIX_C_SOURCE /;"	d
_REDIS_FMACRO_H	fmacros.h	/^#define _REDIS_FMACRO_H$/;"	d
_XOPEN_SOURCE	fmacros.h	/^#define _XOPEN_SOURCE /;"	d
_XOPEN_SOURCE	fmacros.h	/^#define _XOPEN_SOURCE$/;"	d
_ZIPMAP_H	zipmap.h	/^#define _ZIPMAP_H$/;"	d
__ADLIST_H__	adlist.h	/^#define __ADLIST_H__$/;"	d
__AE_H__	ae.h	/^#define __AE_H__$/;"	d
__CONFIG_H	config.h	/^#define __CONFIG_H$/;"	d
__DICT_H	dict.h	/^#define __DICT_H$/;"	d
__ENDIANCONV_H	endianconv.h	/^#define __ENDIANCONV_H$/;"	d
__INTSET_H	intset.h	/^#define __INTSET_H$/;"	d
__LATENCY_H	latency.h	/^#define __LATENCY_H$/;"	d
__PQSORT_H	pqsort.h	/^#define __PQSORT_H$/;"	d
__REDIS_ASSERT_H__	redisassert.h	/^#define __REDIS_ASSERT_H__$/;"	d
__REDIS_CLUSTER_H	cluster.h	/^#define __REDIS_CLUSTER_H$/;"	d
__REDIS_H	redis.h	/^#define __REDIS_H$/;"	d
__REDIS_HELP_H	help.h	/^#define __REDIS_HELP_H$/;"	d
__REDIS_RDB_H	rdb.h	/^#define __REDIS_RDB_H$/;"	d
__REDIS_RIO_H	rio.h	/^#define __REDIS_RIO_H$/;"	d
__REDIS_UTIL_H	util.h	/^#define __REDIS_UTIL_H$/;"	d
__SDS_H	sds.h	/^#define __SDS_H$/;"	d
__SPARKLINE_H	sparkline.h	/^#define __SPARKLINE_H$/;"	d
__TESTHELP_H	testhelp.h	/^#define __TESTHELP_H$/;"	d
__ZMALLOC_H	zmalloc.h	/^#define __ZMALLOC_H$/;"	d
__anon10::name	config.c	/^    const char     *name;$/;"	m	struct:__anon10	file:	access:public
__anon10::value	config.c	/^    const int       value;$/;"	m	struct:__anon10	file:	access:public
__anon12::data	redis-check-dump.c	/^    void *data;$/;"	m	struct:__anon12	file:	access:public
__anon12::offset	redis-check-dump.c	/^    size_t offset;$/;"	m	struct:__anon12	file:	access:public
__anon12::size	redis-check-dump.c	/^    size_t size;$/;"	m	struct:__anon12	file:	access:public
__anon13::error	redis-check-dump.c	/^    char error[16][1024];$/;"	m	struct:__anon13	file:	access:public
__anon13::level	redis-check-dump.c	/^    size_t level;$/;"	m	struct:__anon13	file:	access:public
__anon13::offset	redis-check-dump.c	/^    size_t offset[16];$/;"	m	struct:__anon13	file:	access:public
__anon14::key	redis-check-dump.c	/^    char* key;$/;"	m	struct:__anon14	file:	access:public
__anon14::success	redis-check-dump.c	/^    char success;$/;"	m	struct:__anon14	file:	access:public
__anon14::type	redis-check-dump.c	/^    int type;$/;"	m	struct:__anon14	file:	access:public
__anon15::argc	redis-cli.c	/^    int argc;$/;"	m	struct:__anon15	file:	access:public
__anon15::argv	redis-cli.c	/^    sds *argv;$/;"	m	struct:__anon15	file:	access:public
__anon15::full	redis-cli.c	/^    sds full;$/;"	m	struct:__anon15	file:	access:public
__anon15::org	redis-cli.c	/^    struct commandHelp *org;$/;"	m	struct:__anon15	typeref:struct:__anon15::commandHelp	file:	access:public
__anon15::type	redis-cli.c	/^    int type;$/;"	m	struct:__anon15	file:	access:public
__anon18::direction	redis.h	/^    unsigned char direction; \/* Iteration direction *\/$/;"	m	struct:__anon18	access:public
__anon18::encoding	redis.h	/^    unsigned char encoding;$/;"	m	struct:__anon18	access:public
__anon18::ln	redis.h	/^    listNode *ln;$/;"	m	struct:__anon18	access:public
__anon18::subject	redis.h	/^    robj *subject;$/;"	m	struct:__anon18	access:public
__anon18::zi	redis.h	/^    unsigned char *zi;$/;"	m	struct:__anon18	access:public
__anon19::li	redis.h	/^    listTypeIterator *li;$/;"	m	struct:__anon19	access:public
__anon19::ln	redis.h	/^    listNode *ln;       \/* Entry in linked list *\/$/;"	m	struct:__anon19	access:public
__anon19::zi	redis.h	/^    unsigned char *zi;  \/* Entry in ziplist *\/$/;"	m	struct:__anon19	access:public
__anon1::flags	cluster.h	/^    uint16_t flags;             \/* node->flags copy *\/$/;"	m	struct:__anon1	access:public
__anon1::ip	cluster.h	/^    char ip[REDIS_IP_STR_LEN];  \/* IP address last time it was seen *\/$/;"	m	struct:__anon1	access:public
__anon1::nodename	cluster.h	/^    char nodename[REDIS_CLUSTER_NAMELEN];$/;"	m	struct:__anon1	access:public
__anon1::notused1	cluster.h	/^    uint16_t notused1;          \/* Some room for future improvements. *\/$/;"	m	struct:__anon1	access:public
__anon1::notused2	cluster.h	/^    uint32_t notused2;$/;"	m	struct:__anon1	access:public
__anon1::ping_sent	cluster.h	/^    uint32_t ping_sent;$/;"	m	struct:__anon1	access:public
__anon1::pong_received	cluster.h	/^    uint32_t pong_received;$/;"	m	struct:__anon1	access:public
__anon1::port	cluster.h	/^    uint16_t port;              \/* port last time it was seen *\/$/;"	m	struct:__anon1	access:public
__anon20::di	redis.h	/^    dictIterator *di;$/;"	m	struct:__anon20	access:public
__anon20::encoding	redis.h	/^    int encoding;$/;"	m	struct:__anon20	access:public
__anon20::ii	redis.h	/^    int ii; \/* intset iterator *\/$/;"	m	struct:__anon20	access:public
__anon20::subject	redis.h	/^    robj *subject;$/;"	m	struct:__anon20	access:public
__anon21::de	redis.h	/^    dictEntry *de;$/;"	m	struct:__anon21	access:public
__anon21::di	redis.h	/^    dictIterator *di;$/;"	m	struct:__anon21	access:public
__anon21::encoding	redis.h	/^    int encoding;$/;"	m	struct:__anon21	access:public
__anon21::fptr	redis.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon21	access:public
__anon21::subject	redis.h	/^    robj *subject;$/;"	m	struct:__anon21	access:public
__anon21::vptr	redis.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon21	access:public
__anon22::max	redis.h	/^    double min, max;$/;"	m	struct:__anon22	access:public
__anon22::maxex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon22	access:public
__anon22::min	redis.h	/^    double min, max;$/;"	m	struct:__anon22	access:public
__anon22::minex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon22	access:public
__anon23::max	redis.h	/^    robj *min, *max;  \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon23	access:public
__anon23::maxex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon23	access:public
__anon23::min	redis.h	/^    robj *min, *max;  \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon23	access:public
__anon23::minex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon23	access:public
__anon28::arg0	setproctitle.c	/^	const char *arg0;$/;"	m	struct:__anon28	file:	access:public
__anon28::base	setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon28	file:	access:public
__anon28::end	setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon28	file:	access:public
__anon28::error	setproctitle.c	/^	int error;$/;"	m	struct:__anon28	file:	access:public
__anon28::nul	setproctitle.c	/^	char *nul;$/;"	m	struct:__anon28	file:	access:public
__anon28::reset	setproctitle.c	/^	_Bool reset;$/;"	m	struct:__anon28	file:	access:public
__anon29::buffer	sha1.h	/^    unsigned char buffer[64];$/;"	m	struct:__anon29	access:public
__anon29::count	sha1.h	/^    uint32_t count[2];$/;"	m	struct:__anon29	access:public
__anon29::state	sha1.h	/^    uint32_t state[5];$/;"	m	struct:__anon29	access:public
__anon2::nodename	cluster.h	/^    char nodename[REDIS_CLUSTER_NAMELEN];$/;"	m	struct:__anon2	access:public
__anon30::__anon31::_iterset	t_zset.c	/^        union _iterset {$/;"	u	union:__anon30::__anon31	file:	access:public
__anon30::__anon31::_iterset::__anon32::ii	t_zset.c	/^                int ii;$/;"	m	struct:__anon30::__anon31::_iterset::__anon32	file:	access:public
__anon30::__anon31::_iterset::__anon32::is	t_zset.c	/^                intset *is;$/;"	m	struct:__anon30::__anon31::_iterset::__anon32	file:	access:public
__anon30::__anon31::_iterset::__anon33::de	t_zset.c	/^                dictEntry *de;$/;"	m	struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
__anon30::__anon31::_iterset::__anon33::di	t_zset.c	/^                dictIterator *di;$/;"	m	struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
__anon30::__anon31::_iterset::__anon33::dict	t_zset.c	/^                dict *dict;$/;"	m	struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
__anon30::__anon31::_iterset::ht	t_zset.c	/^            } ht;$/;"	m	union:__anon30::__anon31::_iterset	typeref:struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
__anon30::__anon31::_iterset::is	t_zset.c	/^            } is;$/;"	m	union:__anon30::__anon31::_iterset	typeref:struct:__anon30::__anon31::_iterset::__anon32	file:	access:public
__anon30::__anon31::_iterzset	t_zset.c	/^        union _iterzset {$/;"	u	union:__anon30::__anon31	file:	access:public
__anon30::__anon31::_iterzset::__anon34::eptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
__anon30::__anon31::_iterzset::__anon34::sptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
__anon30::__anon31::_iterzset::__anon34::zl	t_zset.c	/^                unsigned char *zl;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
__anon30::__anon31::_iterzset::__anon35::node	t_zset.c	/^                zskiplistNode *node;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon35	file:	access:public
__anon30::__anon31::_iterzset::__anon35::zs	t_zset.c	/^                zset *zs;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon35	file:	access:public
__anon30::__anon31::_iterzset::sl	t_zset.c	/^            } sl;$/;"	m	union:__anon30::__anon31::_iterzset	typeref:struct:__anon30::__anon31::_iterzset::__anon35	file:	access:public
__anon30::__anon31::_iterzset::zl	t_zset.c	/^            } zl;$/;"	m	union:__anon30::__anon31::_iterzset	typeref:struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
__anon30::__anon31::set	t_zset.c	/^        } set;$/;"	m	union:__anon30::__anon31	typeref:union:__anon30::__anon31::_iterset	file:	access:public
__anon30::__anon31::zset	t_zset.c	/^        } zset;$/;"	m	union:__anon30::__anon31	typeref:union:__anon30::__anon31::_iterzset	file:	access:public
__anon30::encoding	t_zset.c	/^    int encoding;$/;"	m	struct:__anon30	file:	access:public
__anon30::iter	t_zset.c	/^    } iter;$/;"	m	struct:__anon30	typeref:union:__anon30::__anon31	file:	access:public
__anon30::subject	t_zset.c	/^    robj *subject;$/;"	m	struct:__anon30	file:	access:public
__anon30::type	t_zset.c	/^    int type; \/* Set, sorted set *\/$/;"	m	struct:__anon30	file:	access:public
__anon30::weight	t_zset.c	/^    double weight;$/;"	m	struct:__anon30	file:	access:public
__anon36::_buf	t_zset.c	/^    unsigned char _buf[32]; \/* Private buffer. *\/$/;"	m	struct:__anon36	file:	access:public
__anon36::ele	t_zset.c	/^    robj *ele;$/;"	m	struct:__anon36	file:	access:public
__anon36::elen	t_zset.c	/^    unsigned int elen;$/;"	m	struct:__anon36	file:	access:public
__anon36::ell	t_zset.c	/^    long long ell;$/;"	m	struct:__anon36	file:	access:public
__anon36::estr	t_zset.c	/^    unsigned char *estr;$/;"	m	struct:__anon36	file:	access:public
__anon36::flags	t_zset.c	/^    int flags;$/;"	m	struct:__anon36	file:	access:public
__anon36::score	t_zset.c	/^    double score;$/;"	m	struct:__anon36	file:	access:public
__anon3::bulk_data	cluster.h	/^    unsigned char bulk_data[8];$/;"	m	struct:__anon3	access:public
__anon3::channel_len	cluster.h	/^    uint32_t channel_len;$/;"	m	struct:__anon3	access:public
__anon3::message_len	cluster.h	/^    uint32_t message_len;$/;"	m	struct:__anon3	access:public
__anon4::configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Config epoch of the specified instance. *\/$/;"	m	struct:__anon4	access:public
__anon4::nodename	cluster.h	/^    char nodename[REDIS_CLUSTER_NAMELEN]; \/* Name of the slots owner. *\/$/;"	m	struct:__anon4	access:public
__anon4::slots	cluster.h	/^    unsigned char slots[REDIS_CLUSTER_SLOTS\/8]; \/* Slots bitmap. *\/$/;"	m	struct:__anon4	access:public
__anon9::configEpoch	cluster.h	/^    uint64_t configEpoch;   \/* The config epoch if it's a master, or the last$/;"	m	struct:__anon9	access:public
__anon9::count	cluster.h	/^    uint16_t count;     \/* Only used for some kind of messages. *\/$/;"	m	struct:__anon9	access:public
__anon9::currentEpoch	cluster.h	/^    uint64_t currentEpoch;  \/* The epoch accordingly to the sending node. *\/$/;"	m	struct:__anon9	access:public
__anon9::data	cluster.h	/^    union clusterMsgData data;$/;"	m	struct:__anon9	typeref:union:__anon9::clusterMsgData	access:public
__anon9::flags	cluster.h	/^    uint16_t flags;     \/* Sender node flags *\/$/;"	m	struct:__anon9	access:public
__anon9::mflags	cluster.h	/^    unsigned char mflags[3]; \/* Message flags: CLUSTERMSG_FLAG[012]_... *\/$/;"	m	struct:__anon9	access:public
__anon9::myslots	cluster.h	/^    unsigned char myslots[REDIS_CLUSTER_SLOTS\/8];$/;"	m	struct:__anon9	access:public
__anon9::notused0	cluster.h	/^    uint16_t notused0;  \/* 2 bytes not used. *\/$/;"	m	struct:__anon9	access:public
__anon9::notused1	cluster.h	/^    char notused1[32];  \/* 32 bytes reserved for future usage. *\/$/;"	m	struct:__anon9	access:public
__anon9::offset	cluster.h	/^    uint64_t offset;    \/* Master replication offset if node is a master or$/;"	m	struct:__anon9	access:public
__anon9::port	cluster.h	/^    uint16_t port;      \/* Sender TCP base port *\/$/;"	m	struct:__anon9	access:public
__anon9::sender	cluster.h	/^    char sender[REDIS_CLUSTER_NAMELEN]; \/* Name of the sender node *\/$/;"	m	struct:__anon9	access:public
__anon9::sig	cluster.h	/^    char sig[4];        \/* Siganture "RCmb" (Redis Cluster message bus). *\/$/;"	m	struct:__anon9	access:public
__anon9::slaveof	cluster.h	/^    char slaveof[REDIS_CLUSTER_NAMELEN];$/;"	m	struct:__anon9	access:public
__anon9::state	cluster.h	/^    unsigned char state; \/* Cluster state from the POV of the sender *\/$/;"	m	struct:__anon9	access:public
__anon9::totlen	cluster.h	/^    uint32_t totlen;    \/* Total length of this message *\/$/;"	m	struct:__anon9	access:public
__anon9::type	cluster.h	/^    uint16_t type;      \/* Message type *\/$/;"	m	struct:__anon9	access:public
__anon9::ver	cluster.h	/^    uint16_t ver;       \/* Protocol version, currently set to 0. *\/$/;"	m	struct:__anon9	access:public
__failed_tests	testhelp.h	/^int __failed_tests = 0;$/;"	v
__str	zmalloc.h	/^#define __str(/;"	d
__test_num	testhelp.h	/^int __test_num = 0;$/;"	v
__xstr	zmalloc.h	/^#define __xstr(/;"	d
__ziplistCascadeUpdate	ziplist.c	/^static unsigned char *__ziplistCascadeUpdate(unsigned char *zl, unsigned char *p) {$/;"	f	file:	signature:(unsigned char *zl, unsigned char *p)
__ziplistDelete	ziplist.c	/^static unsigned char *__ziplistDelete(unsigned char *zl, unsigned char *p, unsigned int num) {$/;"	f	file:	signature:(unsigned char *zl, unsigned char *p, unsigned int num)
__ziplistInsert	ziplist.c	/^static unsigned char *__ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f	file:	signature:(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)
_addReplyObjectToList	networking.c	/^void _addReplyObjectToList(redisClient *c, robj *o) {$/;"	f	signature:(redisClient *c, robj *o)
_addReplySdsToList	networking.c	/^void _addReplySdsToList(redisClient *c, sds s) {$/;"	f	signature:(redisClient *c, sds s)
_addReplyStringToList	networking.c	/^void _addReplyStringToList(redisClient *c, char *s, size_t len) {$/;"	f	signature:(redisClient *c, char *s, size_t len)
_addReplyToBuffer	networking.c	/^int _addReplyToBuffer(redisClient *c, char *s, size_t len) {$/;"	f	signature:(redisClient *c, char *s, size_t len)
_anetTcpServer	anet.c	/^static int _anetTcpServer(char *err, int port, char *bindaddr, int af, int backlog)$/;"	f	file:	signature:(char *err, int port, char *bindaddr, int af, int backlog)
_assert	intset.c	/^void _assert(char *estr, char *file, int line) {$/;"	f	signature:(char *estr, char *file, int line)
_buf	t_zset.c	/^    unsigned char _buf[32]; \/* Private buffer. *\/$/;"	m	struct:__anon36	file:	access:public
_client	redis-benchmark.c	/^typedef struct _client {$/;"	s	file:
_client::context	redis-benchmark.c	/^    redisContext *context;$/;"	m	struct:_client	file:	access:public
_client::latency	redis-benchmark.c	/^    long long latency;      \/* Request latency *\/$/;"	m	struct:_client	file:	access:public
_client::obuf	redis-benchmark.c	/^    sds obuf;$/;"	m	struct:_client	file:	access:public
_client::pending	redis-benchmark.c	/^    int pending;            \/* Number of pending requests (replies to consume) *\/$/;"	m	struct:_client	file:	access:public
_client::prefix_pending	redis-benchmark.c	/^    int prefix_pending;     \/* If non-zero, number of pending prefix commands. Commands$/;"	m	struct:_client	file:	access:public
_client::prefixlen	redis-benchmark.c	/^    int prefixlen;          \/* Size in bytes of the pending prefix commands *\/$/;"	m	struct:_client	file:	access:public
_client::randfree	redis-benchmark.c	/^    size_t randfree;        \/* Number of unused pointers in client->randptr *\/$/;"	m	struct:_client	file:	access:public
_client::randlen	redis-benchmark.c	/^    size_t randlen;         \/* Number of pointers in client->randptr *\/$/;"	m	struct:_client	file:	access:public
_client::randptr	redis-benchmark.c	/^    char **randptr;         \/* Pointers to :rand: strings inside the command buf *\/$/;"	m	struct:_client	file:	access:public
_client::start	redis-benchmark.c	/^    long long start;        \/* Start time of a request *\/$/;"	m	struct:_client	file:	access:public
_client::written	redis-benchmark.c	/^    unsigned int written;   \/* Bytes of 'obuf' already written *\/$/;"	m	struct:_client	file:	access:public
_dictClear	dict.c	/^int _dictClear(dict *d, dictht *ht, void(callback)(void *)) {$/;"	f	signature:(dict *d, dictht *ht, void(callback)(void *))
_dictExpandIfNeeded	dict.c	/^static int _dictExpandIfNeeded(dict *d)$/;"	f	file:	signature:(dict *d)
_dictExpandIfNeeded	dict.c	/^static int _dictExpandIfNeeded(dict *ht);$/;"	p	file:	signature:(dict *ht)
_dictInit	dict.c	/^int _dictInit(dict *d, dictType *type,$/;"	f	signature:(dict *d, dictType *type, void *privDataPtr)
_dictInit	dict.c	/^static int _dictInit(dict *ht, dictType *type, void *privDataPtr);$/;"	p	file:	signature:(dict *ht, dictType *type, void *privDataPtr)
_dictKeyIndex	dict.c	/^static int _dictKeyIndex(dict *d, const void *key)$/;"	f	file:	signature:(dict *d, const void *key)
_dictKeyIndex	dict.c	/^static int _dictKeyIndex(dict *ht, const void *key);$/;"	p	file:	signature:(dict *ht, const void *key)
_dictNextPower	dict.c	/^static unsigned long _dictNextPower(unsigned long size)$/;"	f	file:	signature:(unsigned long size)
_dictNextPower	dict.c	/^static unsigned long _dictNextPower(unsigned long size);$/;"	p	file:	signature:(unsigned long size)
_dictRehashStep	dict.c	/^static void _dictRehashStep(dict *d) {$/;"	f	file:	signature:(dict *d)
_dictReset	dict.c	/^static void _dictReset(dictht *ht)$/;"	f	file:	signature:(dictht *ht)
_intsetGet	intset.c	/^static int64_t _intsetGet(intset *is, int pos) {$/;"	f	file:	signature:(intset *is, int pos)
_intsetGetEncoded	intset.c	/^static int64_t _intsetGetEncoded(intset *is, int pos, uint8_t enc) {$/;"	f	file:	signature:(intset *is, int pos, uint8_t enc)
_intsetSet	intset.c	/^static void _intsetSet(intset *is, int pos, int64_t value) {$/;"	f	file:	signature:(intset *is, int pos, int64_t value)
_intsetValueEncoding	intset.c	/^static uint8_t _intsetValueEncoding(int64_t v) {$/;"	f	file:	signature:(int64_t v)
_iterset	t_zset.c	/^        union _iterset {$/;"	u	union:__anon30::__anon31	file:	access:public
_iterzset	t_zset.c	/^        union _iterzset {$/;"	u	union:__anon30::__anon31	file:	access:public
_pqsort	pqsort.c	/^_pqsort(void *a, size_t n, size_t es,$/;"	f	file:	signature:(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *), void *lrange, void *rrange)
_redisAssert	debug.c	/^void _redisAssert(char *estr, char *file, int line) {$/;"	f	signature:(char *estr, char *file, int line)
_redisAssert	redis.h	/^void _redisAssert(char *estr, char *file, int line);$/;"	p	signature:(char *estr, char *file, int line)
_redisAssert	redisassert.h	/^void _redisAssert(char *estr, char *file, int line);$/;"	p	signature:(char *estr, char *file, int line)
_redisAssertPrintClientInfo	debug.c	/^void _redisAssertPrintClientInfo(redisClient *c) {$/;"	f	signature:(redisClient *c)
_redisAssertPrintObject	debug.c	/^void _redisAssertPrintObject(robj *o) {$/;"	f	signature:(robj *o)
_redisAssertWithInfo	debug.c	/^void _redisAssertWithInfo(redisClient *c, robj *o, char *estr, char *file, int line) {$/;"	f	signature:(redisClient *c, robj *o, char *estr, char *file, int line)
_redisAssertWithInfo	redis.h	/^void _redisAssertWithInfo(redisClient *c, robj *o, char *estr, char *file, int line);$/;"	p	signature:(redisClient *c, robj *o, char *estr, char *file, int line)
_redisPanic	debug.c	/^void _redisPanic(char *msg, char *file, int line) {$/;"	f	signature:(char *msg, char *file, int line)
_redisPanic	redis.h	/^void _redisPanic(char *msg, char *file, int line);$/;"	p	signature:(char *msg, char *file, int line)
_redisSortObject	redis.h	/^typedef struct _redisSortObject {$/;"	s
_redisSortObject::__anon17::cmpobj	redis.h	/^        robj *cmpobj;$/;"	m	union:_redisSortObject::__anon17	access:public
_redisSortObject::__anon17::score	redis.h	/^        double score;$/;"	m	union:_redisSortObject::__anon17	access:public
_redisSortObject::obj	redis.h	/^    robj *obj;$/;"	m	struct:_redisSortObject	access:public
_redisSortObject::u	redis.h	/^    } u;$/;"	m	struct:_redisSortObject	typeref:union:_redisSortObject::__anon17	access:public
_redisSortOperation	redis.h	/^typedef struct _redisSortOperation {$/;"	s
_redisSortOperation::pattern	redis.h	/^    robj *pattern;$/;"	m	struct:_redisSortOperation	access:public
_redisSortOperation::type	redis.h	/^    int type;$/;"	m	struct:_redisSortOperation	access:public
_rfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:	access:public
_rio	rio.h	/^struct _rio {$/;"	s
_rio::__anon24::__anon25::pos	rio.h	/^            off_t pos;$/;"	m	struct:_rio::__anon24::__anon25	access:public
_rio::__anon24::__anon25::ptr	rio.h	/^            sds ptr;$/;"	m	struct:_rio::__anon24::__anon25	access:public
_rio::__anon24::__anon26::autosync	rio.h	/^            off_t autosync; \/* fsync after 'autosync' bytes written. *\/$/;"	m	struct:_rio::__anon24::__anon26	access:public
_rio::__anon24::__anon26::buffered	rio.h	/^            off_t buffered; \/* Bytes written since last fsync. *\/$/;"	m	struct:_rio::__anon24::__anon26	access:public
_rio::__anon24::__anon26::fp	rio.h	/^            FILE *fp;$/;"	m	struct:_rio::__anon24::__anon26	access:public
_rio::__anon24::__anon27::buf	rio.h	/^            sds buf;$/;"	m	struct:_rio::__anon24::__anon27	access:public
_rio::__anon24::__anon27::fds	rio.h	/^            int *fds;       \/* File descriptors. *\/$/;"	m	struct:_rio::__anon24::__anon27	access:public
_rio::__anon24::__anon27::numfds	rio.h	/^            int numfds;$/;"	m	struct:_rio::__anon24::__anon27	access:public
_rio::__anon24::__anon27::pos	rio.h	/^            off_t pos;$/;"	m	struct:_rio::__anon24::__anon27	access:public
_rio::__anon24::__anon27::state	rio.h	/^            int *state;     \/* Error state of each fd. 0 (if ok) or errno. *\/$/;"	m	struct:_rio::__anon24::__anon27	access:public
_rio::__anon24::buffer	rio.h	/^        } buffer;$/;"	m	union:_rio::__anon24	typeref:struct:_rio::__anon24::__anon25	access:public
_rio::__anon24::fdset	rio.h	/^        } fdset;$/;"	m	union:_rio::__anon24	typeref:struct:_rio::__anon24::__anon27	access:public
_rio::__anon24::file	rio.h	/^        } file;$/;"	m	union:_rio::__anon24	typeref:struct:_rio::__anon24::__anon26	access:public
_rio::cksum	rio.h	/^    uint64_t cksum;$/;"	m	struct:_rio	access:public
_rio::flush	rio.h	/^    int (*flush)(struct _rio *);$/;"	m	struct:_rio	access:public
_rio::io	rio.h	/^    } io;$/;"	m	struct:_rio	typeref:union:_rio::__anon24	access:public
_rio::max_processing_chunk	rio.h	/^    size_t max_processing_chunk;$/;"	m	struct:_rio	access:public
_rio::processed_bytes	rio.h	/^    size_t processed_bytes;$/;"	m	struct:_rio	access:public
_rio::read	rio.h	/^    size_t (*read)(struct _rio *, void *buf, size_t len);$/;"	m	struct:_rio	access:public
_rio::tell	rio.h	/^    off_t (*tell)(struct _rio *);$/;"	m	struct:_rio	access:public
_rio::update_cksum	rio.h	/^    void (*update_cksum)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio	access:public
_rio::write	rio.h	/^    size_t (*write)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio	access:public
_wfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:	access:public
a	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
about	cluster.h	/^        clusterMsgDataFail about;$/;"	m	struct:clusterMsgData::__anon6	access:public
acceptCommonHandler	networking.c	/^static void acceptCommonHandler(int fd, int flags) {$/;"	f	file:	signature:(int fd, int flags)
acceptHandler	redis.h	/^void acceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptTcpHandler	networking.c	/^void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptTcpHandler	redis.h	/^void acceptTcpHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptUnixHandler	networking.c	/^void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
acceptUnixHandler	redis.h	/^void acceptUnixHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
activeExpireCycle	redis.c	/^void activeExpireCycle(int type) {$/;"	f	signature:(int type)
activeExpireCycleTryExpire	redis.c	/^int activeExpireCycleTryExpire(redisDb *db, dictEntry *de, long long now) {$/;"	f	signature:(redisDb *db, dictEntry *de, long long now)
active_expire_enabled	redis.h	/^    int active_expire_enabled;      \/* Can be disabled for testing purposes. *\/$/;"	m	struct:redisServer	access:public
activerehashing	redis.h	/^    int activerehashing;        \/* Incremental rehash in serverCron() *\/$/;"	m	struct:redisServer	access:public
addDeferredMultiBulkLength	networking.c	/^void *addDeferredMultiBulkLength(redisClient *c) {$/;"	f	signature:(redisClient *c)
addDeferredMultiBulkLength	redis.h	/^void *addDeferredMultiBulkLength(redisClient *c);$/;"	p	signature:(redisClient *c)
addHashFieldToReply	t_hash.c	/^static void addHashFieldToReply(redisClient *c, robj *o, robj *field) {$/;"	f	file:	signature:(redisClient *c, robj *o, robj *field)
addHashIteratorCursorToReply	t_hash.c	/^static void addHashIteratorCursorToReply(redisClient *c, hashTypeIterator *hi, int what) {$/;"	f	file:	signature:(redisClient *c, hashTypeIterator *hi, int what)
addReply	networking.c	/^void addReply(redisClient *c, robj *obj) {$/;"	f	signature:(redisClient *c, robj *obj)
addReply	redis.h	/^void addReply(redisClient *c, robj *obj);$/;"	p	signature:(redisClient *c, robj *obj)
addReplyBulk	networking.c	/^void addReplyBulk(redisClient *c, robj *obj) {$/;"	f	signature:(redisClient *c, robj *obj)
addReplyBulk	redis.h	/^void addReplyBulk(redisClient *c, robj *obj);$/;"	p	signature:(redisClient *c, robj *obj)
addReplyBulkCBuffer	networking.c	/^void addReplyBulkCBuffer(redisClient *c, void *p, size_t len) {$/;"	f	signature:(redisClient *c, void *p, size_t len)
addReplyBulkCBuffer	redis.h	/^void addReplyBulkCBuffer(redisClient *c, void *p, size_t len);$/;"	p	signature:(redisClient *c, void *p, size_t len)
addReplyBulkCString	networking.c	/^void addReplyBulkCString(redisClient *c, char *s) {$/;"	f	signature:(redisClient *c, char *s)
addReplyBulkCString	redis.h	/^void addReplyBulkCString(redisClient *c, char *s);$/;"	p	signature:(redisClient *c, char *s)
addReplyBulkLen	networking.c	/^void addReplyBulkLen(redisClient *c, robj *obj) {$/;"	f	signature:(redisClient *c, robj *obj)
addReplyBulkLongLong	networking.c	/^void addReplyBulkLongLong(redisClient *c, long long ll) {$/;"	f	signature:(redisClient *c, long long ll)
addReplyBulkLongLong	redis.h	/^void addReplyBulkLongLong(redisClient *c, long long ll);$/;"	p	signature:(redisClient *c, long long ll)
addReplyCommand	redis.c	/^void addReplyCommand(redisClient *c, struct redisCommand *cmd) {$/;"	f	signature:(redisClient *c, struct redisCommand *cmd)
addReplyCommandFlag	redis.c	/^int addReplyCommandFlag(redisClient *c, struct redisCommand *cmd, int f, char *reply) {$/;"	f	signature:(redisClient *c, struct redisCommand *cmd, int f, char *reply)
addReplyDictOfRedisInstances	sentinel.c	/^void addReplyDictOfRedisInstances(redisClient *c, dict *instances) {$/;"	f	signature:(redisClient *c, dict *instances)
addReplyDouble	networking.c	/^void addReplyDouble(redisClient *c, double d) {$/;"	f	signature:(redisClient *c, double d)
addReplyDouble	redis.h	/^void addReplyDouble(redisClient *c, double d);$/;"	p	signature:(redisClient *c, double d)
addReplyError	networking.c	/^void addReplyError(redisClient *c, char *err) {$/;"	f	signature:(redisClient *c, char *err)
addReplyError	redis.h	/^void addReplyError(redisClient *c, char *err);$/;"	p	signature:(redisClient *c, char *err)
addReplyErrorFormat	networking.c	/^void addReplyErrorFormat(redisClient *c, const char *fmt, ...) {$/;"	f	signature:(redisClient *c, const char *fmt, ...)
addReplyErrorFormat	redis.h	/^void addReplyErrorFormat(redisClient *c, const char *fmt, ...)$/;"	p	signature:(redisClient *c, const char *fmt, ...)
addReplyErrorFormat	redis.h	/^void addReplyErrorFormat(redisClient *c, const char *fmt, ...);$/;"	p	signature:(redisClient *c, const char *fmt, ...)
addReplyErrorLength	networking.c	/^void addReplyErrorLength(redisClient *c, char *s, size_t len) {$/;"	f	signature:(redisClient *c, char *s, size_t len)
addReplyLongLong	networking.c	/^void addReplyLongLong(redisClient *c, long long ll) {$/;"	f	signature:(redisClient *c, long long ll)
addReplyLongLong	redis.h	/^void addReplyLongLong(redisClient *c, long long ll);$/;"	p	signature:(redisClient *c, long long ll)
addReplyLongLongWithPrefix	networking.c	/^void addReplyLongLongWithPrefix(redisClient *c, long long ll, char prefix) {$/;"	f	signature:(redisClient *c, long long ll, char prefix)
addReplyMultiBulkLen	networking.c	/^void addReplyMultiBulkLen(redisClient *c, long length) {$/;"	f	signature:(redisClient *c, long length)
addReplyMultiBulkLen	redis.h	/^void addReplyMultiBulkLen(redisClient *c, long length);$/;"	p	signature:(redisClient *c, long length)
addReplyReplicationBacklog	replication.c	/^long long addReplyReplicationBacklog(redisClient *c, long long offset) {$/;"	f	signature:(redisClient *c, long long offset)
addReplySds	networking.c	/^void addReplySds(redisClient *c, sds s) {$/;"	f	signature:(redisClient *c, sds s)
addReplySds	redis.h	/^void addReplySds(redisClient *c, sds s);$/;"	p	signature:(redisClient *c, sds s)
addReplySentinelRedisInstance	sentinel.c	/^void addReplySentinelRedisInstance(redisClient *c, sentinelRedisInstance *ri) {$/;"	f	signature:(redisClient *c, sentinelRedisInstance *ri)
addReplyStatus	networking.c	/^void addReplyStatus(redisClient *c, char *status) {$/;"	f	signature:(redisClient *c, char *status)
addReplyStatus	redis.h	/^void addReplyStatus(redisClient *c, char *status);$/;"	p	signature:(redisClient *c, char *status)
addReplyStatusFormat	networking.c	/^void addReplyStatusFormat(redisClient *c, const char *fmt, ...) {$/;"	f	signature:(redisClient *c, const char *fmt, ...)
addReplyStatusFormat	redis.h	/^void addReplyStatusFormat(redisClient *c, const char *fmt, ...)$/;"	p	signature:(redisClient *c, const char *fmt, ...)
addReplyStatusFormat	redis.h	/^void addReplyStatusFormat(redisClient *c, const char *fmt, ...);$/;"	p	signature:(redisClient *c, const char *fmt, ...)
addReplyStatusLength	networking.c	/^void addReplyStatusLength(redisClient *c, char *s, size_t len) {$/;"	f	signature:(redisClient *c, char *s, size_t len)
addReplyString	networking.c	/^void addReplyString(redisClient *c, char *s, size_t len) {$/;"	f	signature:(redisClient *c, char *s, size_t len)
add_node	redis-trib.rb	/^    def add_node(node)$/;"	f	class:RedisTrib
add_slots	redis-trib.rb	/^    def add_slots(slots)$/;"	f	class:ClusterNode
addnode_cluster_cmd	redis-trib.rb	/^    def addnode_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
addr	sentinel.c	/^    sentinelAddr *addr; \/* Master host. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
adjustOpenFilesLimit	redis.c	/^void adjustOpenFilesLimit(void) {$/;"	f	signature:(void)
adjustOpenFilesLimit	redis.h	/^void adjustOpenFilesLimit(void);$/;"	p	signature:(void)
adlist.c	adlist.c	1;"	F
adlist.h	adlist.h	1;"	F
ae.c	ae.c	1;"	F
ae.h	ae.h	1;"	F
aeAddMillisecondsToNow	ae.c	/^static void aeAddMillisecondsToNow(long long milliseconds, long *sec, long *ms) {$/;"	f	file:	signature:(long long milliseconds, long *sec, long *ms)
aeApiAddEvent	ae_epoll.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAddEvent	ae_evport.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAddEvent	ae_kqueue.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAddEvent	ae_select.c	/^static int aeApiAddEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiAssociate	ae_evport.c	/^static int aeApiAssociate(const char *where, int portfd, int fd, int mask) {$/;"	f	file:	signature:(const char *where, int portfd, int fd, int mask)
aeApiCreate	ae_epoll.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiCreate	ae_evport.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiCreate	ae_kqueue.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiCreate	ae_select.c	/^static int aeApiCreate(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiDelEvent	ae_epoll.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int delmask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int delmask)
aeApiDelEvent	ae_evport.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiDelEvent	ae_kqueue.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiDelEvent	ae_select.c	/^static void aeApiDelEvent(aeEventLoop *eventLoop, int fd, int mask) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeApiFree	ae_epoll.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiFree	ae_evport.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiFree	ae_kqueue.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiFree	ae_select.c	/^static void aeApiFree(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeApiLookupPending	ae_evport.c	/^static int aeApiLookupPending(aeApiState *state, int fd) {$/;"	f	file:	signature:(aeApiState *state, int fd)
aeApiName	ae_epoll.c	/^static char *aeApiName(void) {$/;"	f	file:	signature:(void)
aeApiName	ae_evport.c	/^static char *aeApiName(void) {$/;"	f	file:	signature:(void)
aeApiName	ae_kqueue.c	/^static char *aeApiName(void) {$/;"	f	file:	signature:(void)
aeApiName	ae_select.c	/^static char *aeApiName(void) {$/;"	f	file:	signature:(void)
aeApiPoll	ae_epoll.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiPoll	ae_evport.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiPoll	ae_kqueue.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiPoll	ae_select.c	/^static int aeApiPoll(aeEventLoop *eventLoop, struct timeval *tvp) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, struct timeval *tvp)
aeApiResize	ae_epoll.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiResize	ae_evport.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiResize	ae_kqueue.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiResize	ae_select.c	/^static int aeApiResize(aeEventLoop *eventLoop, int setsize) {$/;"	f	file:	signature:(aeEventLoop *eventLoop, int setsize)
aeApiState	ae_epoll.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_epoll.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_evport.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_evport.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_kqueue.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_kqueue.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState	ae_select.c	/^typedef struct aeApiState {$/;"	s	file:
aeApiState	ae_select.c	/^} aeApiState;$/;"	t	typeref:struct:aeApiState	file:
aeApiState::_rfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:	access:public
aeApiState::_wfds	ae_select.c	/^    fd_set _rfds, _wfds;$/;"	m	struct:aeApiState	file:	access:public
aeApiState::epfd	ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:	access:public
aeApiState::events	ae_epoll.c	/^    struct epoll_event *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:	access:public
aeApiState::events	ae_kqueue.c	/^    struct kevent *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:	access:public
aeApiState::kqfd	ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:	access:public
aeApiState::npending	ae_evport.c	/^    int     npending;                           \/* # of pending fds *\/$/;"	m	struct:aeApiState	file:	access:public
aeApiState::pending_fds	ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	struct:aeApiState	file:	access:public
aeApiState::pending_masks	ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	struct:aeApiState	file:	access:public
aeApiState::portfd	ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	struct:aeApiState	file:	access:public
aeApiState::rfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:	access:public
aeApiState::wfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:	access:public
aeBeforeSleepProc	ae.h	/^typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);$/;"	t
aeCreateEventLoop	ae.c	/^aeEventLoop *aeCreateEventLoop(int setsize) {$/;"	f	signature:(int setsize)
aeCreateEventLoop	ae.h	/^aeEventLoop *aeCreateEventLoop(int setsize);$/;"	p	signature:(int setsize)
aeCreateFileEvent	ae.c	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	f	signature:(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)
aeCreateFileEvent	ae.h	/^int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,$/;"	p	signature:(aeEventLoop *eventLoop, int fd, int mask, aeFileProc *proc, void *clientData)
aeCreateTimeEvent	ae.c	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	f	signature:(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc)
aeCreateTimeEvent	ae.h	/^long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,$/;"	p	signature:(aeEventLoop *eventLoop, long long milliseconds, aeTimeProc *proc, void *clientData, aeEventFinalizerProc *finalizerProc)
aeDeleteEventLoop	ae.c	/^void aeDeleteEventLoop(aeEventLoop *eventLoop) {$/;"	f	signature:(aeEventLoop *eventLoop)
aeDeleteEventLoop	ae.h	/^void aeDeleteEventLoop(aeEventLoop *eventLoop);$/;"	p	signature:(aeEventLoop *eventLoop)
aeDeleteFileEvent	ae.c	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask)$/;"	f	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeDeleteFileEvent	ae.h	/^void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);$/;"	p	signature:(aeEventLoop *eventLoop, int fd, int mask)
aeDeleteTimeEvent	ae.c	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id)$/;"	f	signature:(aeEventLoop *eventLoop, long long id)
aeDeleteTimeEvent	ae.h	/^int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);$/;"	p	signature:(aeEventLoop *eventLoop, long long id)
aeEventFinalizerProc	ae.h	/^typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);$/;"	t
aeEventLoop	ae.h	/^struct aeEventLoop;$/;"	x
aeEventLoop	ae.h	/^typedef struct aeEventLoop {$/;"	s
aeEventLoop	ae.h	/^} aeEventLoop;$/;"	t	typeref:struct:aeEventLoop
aeEventLoop::apidata	ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::beforesleep	ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::events	ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::fired	ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::lastTime	ae.h	/^    time_t lastTime;     \/* Used to detect system clock skew *\/$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::maxfd	ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::setsize	ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::stop	ae.h	/^    int stop;$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::timeEventHead	ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop	access:public
aeEventLoop::timeEventNextId	ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop	access:public
aeFileEvent	ae.h	/^typedef struct aeFileEvent {$/;"	s
aeFileEvent	ae.h	/^} aeFileEvent;$/;"	t	typeref:struct:aeFileEvent
aeFileEvent::clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent	access:public
aeFileEvent::mask	ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent	access:public
aeFileEvent::rfileProc	ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent	access:public
aeFileEvent::wfileProc	ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent	access:public
aeFileProc	ae.h	/^typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);$/;"	t
aeFiredEvent	ae.h	/^typedef struct aeFiredEvent {$/;"	s
aeFiredEvent	ae.h	/^} aeFiredEvent;$/;"	t	typeref:struct:aeFiredEvent
aeFiredEvent::fd	ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent	access:public
aeFiredEvent::mask	ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent	access:public
aeGetApiName	ae.c	/^char *aeGetApiName(void) {$/;"	f	signature:(void)
aeGetApiName	ae.h	/^char *aeGetApiName(void);$/;"	p	signature:(void)
aeGetFileEvents	ae.c	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd) {$/;"	f	signature:(aeEventLoop *eventLoop, int fd)
aeGetFileEvents	ae.h	/^int aeGetFileEvents(aeEventLoop *eventLoop, int fd);$/;"	p	signature:(aeEventLoop *eventLoop, int fd)
aeGetSetSize	ae.c	/^int aeGetSetSize(aeEventLoop *eventLoop) {$/;"	f	signature:(aeEventLoop *eventLoop)
aeGetSetSize	ae.h	/^int aeGetSetSize(aeEventLoop *eventLoop);$/;"	p	signature:(aeEventLoop *eventLoop)
aeGetTime	ae.c	/^static void aeGetTime(long *seconds, long *milliseconds)$/;"	f	file:	signature:(long *seconds, long *milliseconds)
aeMain	ae.c	/^void aeMain(aeEventLoop *eventLoop) {$/;"	f	signature:(aeEventLoop *eventLoop)
aeMain	ae.h	/^void aeMain(aeEventLoop *eventLoop);$/;"	p	signature:(aeEventLoop *eventLoop)
aeProcessEvents	ae.c	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags)$/;"	f	signature:(aeEventLoop *eventLoop, int flags)
aeProcessEvents	ae.h	/^int aeProcessEvents(aeEventLoop *eventLoop, int flags);$/;"	p	signature:(aeEventLoop *eventLoop, int flags)
aeResizeSetSize	ae.c	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize) {$/;"	f	signature:(aeEventLoop *eventLoop, int setsize)
aeResizeSetSize	ae.h	/^int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);$/;"	p	signature:(aeEventLoop *eventLoop, int setsize)
aeSearchNearestTimer	ae.c	/^static aeTimeEvent *aeSearchNearestTimer(aeEventLoop *eventLoop)$/;"	f	file:	signature:(aeEventLoop *eventLoop)
aeSetBeforeSleepProc	ae.c	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep) {$/;"	f	signature:(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)
aeSetBeforeSleepProc	ae.h	/^void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);$/;"	p	signature:(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)
aeStop	ae.c	/^void aeStop(aeEventLoop *eventLoop) {$/;"	f	signature:(aeEventLoop *eventLoop)
aeStop	ae.h	/^void aeStop(aeEventLoop *eventLoop);$/;"	p	signature:(aeEventLoop *eventLoop)
aeTimeEvent	ae.h	/^typedef struct aeTimeEvent {$/;"	s
aeTimeEvent	ae.h	/^} aeTimeEvent;$/;"	t	typeref:struct:aeTimeEvent
aeTimeEvent::clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent	access:public
aeTimeEvent::finalizerProc	ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent	access:public
aeTimeEvent::id	ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent	access:public
aeTimeEvent::next	ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent	access:public
aeTimeEvent::timeProc	ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent	access:public
aeTimeEvent::when_ms	ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent	access:public
aeTimeEvent::when_sec	ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent	access:public
aeTimeProc	ae.h	/^typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);$/;"	t
aeWait	ae.c	/^int aeWait(int fd, int mask, long long milliseconds) {$/;"	f	signature:(int fd, int mask, long long milliseconds)
aeWait	ae.h	/^int aeWait(int fd, int mask, long long milliseconds);$/;"	p	signature:(int fd, int mask, long long milliseconds)
ae_epoll.c	ae_epoll.c	1;"	F
ae_evport.c	ae_evport.c	1;"	F
ae_kqueue.c	ae_kqueue.c	1;"	F
ae_select.c	ae_select.c	1;"	F
all_time_high	latency.h	/^    uint32_t all_time_high; \/* Absolute max observed since latest reset. *\/$/;"	m	struct:latencyStats	access:public
alloc_slots	redis-trib.rb	/^    def alloc_slots$/;"	f	class:RedisTrib
alsoPropagate	redis.c	/^void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target)
alsoPropagate	redis.h	/^void alsoPropagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target);$/;"	p	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int target)
also_propagate	redis.h	/^    redisOpArray also_propagate;    \/* Additional command to propagate. *\/$/;"	m	struct:redisServer	access:public
analyzeLatencyForEvent	latency.c	/^void analyzeLatencyForEvent(char *event, struct latencyStats *ls) {$/;"	f	signature:(char *event, struct latencyStats *ls)
anet.c	anet.c	1;"	F
anet.h	anet.h	1;"	F
anetBlock	anet.c	/^int anetBlock(char *err, int fd) {$/;"	f	signature:(char *err, int fd)
anetBlock	anet.h	/^int anetBlock(char *err, int fd);$/;"	p	signature:(char *err, int fd)
anetCreateSocket	anet.c	/^static int anetCreateSocket(char *err, int domain) {$/;"	f	file:	signature:(char *err, int domain)
anetDisableTcpNoDelay	anet.c	/^int anetDisableTcpNoDelay(char *err, int fd)$/;"	f	signature:(char *err, int fd)
anetDisableTcpNoDelay	anet.h	/^int anetDisableTcpNoDelay(char *err, int fd);$/;"	p	signature:(char *err, int fd)
anetEnableTcpNoDelay	anet.c	/^int anetEnableTcpNoDelay(char *err, int fd)$/;"	f	signature:(char *err, int fd)
anetEnableTcpNoDelay	anet.h	/^int anetEnableTcpNoDelay(char *err, int fd);$/;"	p	signature:(char *err, int fd)
anetGenericAccept	anet.c	/^static int anetGenericAccept(char *err, int s, struct sockaddr *sa, socklen_t *len) {$/;"	f	file:	signature:(char *err, int s, struct sockaddr *sa, socklen_t *len)
anetGenericResolve	anet.c	/^int anetGenericResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len,$/;"	f	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len, int flags)
anetKeepAlive	anet.c	/^int anetKeepAlive(char *err, int fd, int interval)$/;"	f	signature:(char *err, int fd, int interval)
anetKeepAlive	anet.h	/^int anetKeepAlive(char *err, int fd, int interval);$/;"	p	signature:(char *err, int fd, int interval)
anetListen	anet.c	/^static int anetListen(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog) {$/;"	f	file:	signature:(char *err, int s, struct sockaddr *sa, socklen_t len, int backlog)
anetNonBlock	anet.c	/^int anetNonBlock(char *err, int fd) {$/;"	f	signature:(char *err, int fd)
anetNonBlock	anet.h	/^int anetNonBlock(char *err, int fd);$/;"	p	signature:(char *err, int fd)
anetPeerToString	anet.c	/^int anetPeerToString(int fd, char *ip, size_t ip_len, int *port) {$/;"	f	signature:(int fd, char *ip, size_t ip_len, int *port)
anetPeerToString	anet.h	/^int anetPeerToString(int fd, char *ip, size_t ip_len, int *port);$/;"	p	signature:(int fd, char *ip, size_t ip_len, int *port)
anetRead	anet.c	/^int anetRead(int fd, char *buf, int count)$/;"	f	signature:(int fd, char *buf, int count)
anetRead	anet.h	/^int anetRead(int fd, char *buf, int count);$/;"	p	signature:(int fd, char *buf, int count)
anetResolve	anet.c	/^int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len) {$/;"	f	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetResolve	anet.h	/^int anetResolve(char *err, char *host, char *ipbuf, size_t ipbuf_len);$/;"	p	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetResolveIP	anet.c	/^int anetResolveIP(char *err, char *host, char *ipbuf, size_t ipbuf_len) {$/;"	f	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetResolveIP	anet.h	/^int anetResolveIP(char *err, char *host, char *ipbuf, size_t ipbuf_len);$/;"	p	signature:(char *err, char *host, char *ipbuf, size_t ipbuf_len)
anetSendTimeout	anet.c	/^int anetSendTimeout(char *err, int fd, long long ms) {$/;"	f	signature:(char *err, int fd, long long ms)
anetSendTimeout	anet.h	/^int anetSendTimeout(char *err, int fd, long long ms);$/;"	p	signature:(char *err, int fd, long long ms)
anetSetBlock	anet.c	/^int anetSetBlock(char *err, int fd, int non_block) {$/;"	f	signature:(char *err, int fd, int non_block)
anetSetError	anet.c	/^static void anetSetError(char *err, const char *fmt, ...)$/;"	f	file:	signature:(char *err, const char *fmt, ...)
anetSetReuseAddr	anet.c	/^static int anetSetReuseAddr(char *err, int fd) {$/;"	f	file:	signature:(char *err, int fd)
anetSetSendBuffer	anet.c	/^int anetSetSendBuffer(char *err, int fd, int buffsize)$/;"	f	signature:(char *err, int fd, int buffsize)
anetSetTcpNoDelay	anet.c	/^static int anetSetTcpNoDelay(char *err, int fd, int val)$/;"	f	file:	signature:(char *err, int fd, int val)
anetSockName	anet.c	/^int anetSockName(int fd, char *ip, size_t ip_len, int *port) {$/;"	f	signature:(int fd, char *ip, size_t ip_len, int *port)
anetSockName	anet.h	/^int anetSockName(int fd, char *ip, size_t ip_len, int *port);$/;"	p	signature:(int fd, char *ip, size_t ip_len, int *port)
anetTcp6Server	anet.c	/^int anetTcp6Server(char *err, int port, char *bindaddr, int backlog)$/;"	f	signature:(char *err, int port, char *bindaddr, int backlog)
anetTcp6Server	anet.h	/^int anetTcp6Server(char *err, int port, char *bindaddr, int backlog);$/;"	p	signature:(char *err, int port, char *bindaddr, int backlog)
anetTcpAccept	anet.c	/^int anetTcpAccept(char *err, int s, char *ip, size_t ip_len, int *port) {$/;"	f	signature:(char *err, int s, char *ip, size_t ip_len, int *port)
anetTcpAccept	anet.h	/^int anetTcpAccept(char *err, int serversock, char *ip, size_t ip_len, int *port);$/;"	p	signature:(char *err, int serversock, char *ip, size_t ip_len, int *port)
anetTcpConnect	anet.c	/^int anetTcpConnect(char *err, char *addr, int port)$/;"	f	signature:(char *err, char *addr, int port)
anetTcpConnect	anet.h	/^int anetTcpConnect(char *err, char *addr, int port);$/;"	p	signature:(char *err, char *addr, int port)
anetTcpGenericConnect	anet.c	/^static int anetTcpGenericConnect(char *err, char *addr, int port,$/;"	f	file:	signature:(char *err, char *addr, int port, char *source_addr, int flags)
anetTcpKeepAlive	anet.c	/^int anetTcpKeepAlive(char *err, int fd)$/;"	f	signature:(char *err, int fd)
anetTcpKeepAlive	anet.h	/^int anetTcpKeepAlive(char *err, int fd);$/;"	p	signature:(char *err, int fd)
anetTcpNonBlockBestEffortBindConnect	anet.c	/^int anetTcpNonBlockBestEffortBindConnect(char *err, char *addr, int port,$/;"	f	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockBestEffortBindConnect	anet.h	/^int anetTcpNonBlockBestEffortBindConnect(char *err, char *addr, int port, char *source_addr);$/;"	p	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockBindConnect	anet.c	/^int anetTcpNonBlockBindConnect(char *err, char *addr, int port,$/;"	f	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockBindConnect	anet.h	/^int anetTcpNonBlockBindConnect(char *err, char *addr, int port, char *source_addr);$/;"	p	signature:(char *err, char *addr, int port, char *source_addr)
anetTcpNonBlockConnect	anet.c	/^int anetTcpNonBlockConnect(char *err, char *addr, int port)$/;"	f	signature:(char *err, char *addr, int port)
anetTcpNonBlockConnect	anet.h	/^int anetTcpNonBlockConnect(char *err, char *addr, int port);$/;"	p	signature:(char *err, char *addr, int port)
anetTcpServer	anet.c	/^int anetTcpServer(char *err, int port, char *bindaddr, int backlog)$/;"	f	signature:(char *err, int port, char *bindaddr, int backlog)
anetTcpServer	anet.h	/^int anetTcpServer(char *err, int port, char *bindaddr, int backlog);$/;"	p	signature:(char *err, int port, char *bindaddr, int backlog)
anetUnixAccept	anet.c	/^int anetUnixAccept(char *err, int s) {$/;"	f	signature:(char *err, int s)
anetUnixAccept	anet.h	/^int anetUnixAccept(char *err, int serversock);$/;"	p	signature:(char *err, int serversock)
anetUnixConnect	anet.c	/^int anetUnixConnect(char *err, char *path)$/;"	f	signature:(char *err, char *path)
anetUnixConnect	anet.h	/^int anetUnixConnect(char *err, char *path);$/;"	p	signature:(char *err, char *path)
anetUnixGenericConnect	anet.c	/^int anetUnixGenericConnect(char *err, char *path, int flags)$/;"	f	signature:(char *err, char *path, int flags)
anetUnixNonBlockConnect	anet.c	/^int anetUnixNonBlockConnect(char *err, char *path)$/;"	f	signature:(char *err, char *path)
anetUnixNonBlockConnect	anet.h	/^int anetUnixNonBlockConnect(char *err, char *path);$/;"	p	signature:(char *err, char *path)
anetUnixServer	anet.c	/^int anetUnixServer(char *err, char *path, mode_t perm, int backlog)$/;"	f	signature:(char *err, char *path, mode_t perm, int backlog)
anetUnixServer	anet.h	/^int anetUnixServer(char *err, char *path, mode_t perm, int backlog);$/;"	p	signature:(char *err, char *path, mode_t perm, int backlog)
anetV6Only	anet.c	/^static int anetV6Only(char *err, int s) {$/;"	f	file:	signature:(char *err, int s)
anetWrite	anet.c	/^int anetWrite(int fd, char *buf, int count)$/;"	f	signature:(int fd, char *buf, int count)
anetWrite	anet.h	/^int anetWrite(int fd, char *buf, int count);$/;"	p	signature:(int fd, char *buf, int count)
announce_ip	sentinel.c	/^    char *announce_ip;      \/* IP addr that is gossiped to other sentinels if$/;"	m	struct:sentinelState	file:	access:public
announce_port	sentinel.c	/^    int announce_port;      \/* Port that is gossiped to other sentinels if$/;"	m	struct:sentinelState	file:	access:public
aof.c	aof.c	1;"	F
aofChildPipeReadable	aof.c	/^void aofChildPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
aofChildWriteDiffData	aof.c	/^void aofChildWriteDiffData(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
aofClosePipes	aof.c	/^void aofClosePipes(void) {$/;"	f	signature:(void)
aofClosePipes	aof.c	/^void aofClosePipes(void);$/;"	p	file:	signature:(void)
aofCreatePipes	aof.c	/^int aofCreatePipes(void) {$/;"	f	signature:(void)
aofReadDiffFromParent	aof.c	/^ssize_t aofReadDiffFromParent(void) {$/;"	f	signature:(void)
aofRemoveTempFile	aof.c	/^void aofRemoveTempFile(pid_t childpid) {$/;"	f	signature:(pid_t childpid)
aofRemoveTempFile	redis.h	/^void aofRemoveTempFile(pid_t childpid);$/;"	p	signature:(pid_t childpid)
aofRewriteBufferAppend	aof.c	/^void aofRewriteBufferAppend(unsigned char *s, unsigned long len) {$/;"	f	signature:(unsigned char *s, unsigned long len)
aofRewriteBufferReset	aof.c	/^void aofRewriteBufferReset(void) {$/;"	f	signature:(void)
aofRewriteBufferReset	redis.h	/^void aofRewriteBufferReset(void);$/;"	p	signature:(void)
aofRewriteBufferSize	aof.c	/^unsigned long aofRewriteBufferSize(void) {$/;"	f	signature:(void)
aofRewriteBufferSize	redis.h	/^unsigned long aofRewriteBufferSize(void);$/;"	p	signature:(void)
aofRewriteBufferWrite	aof.c	/^ssize_t aofRewriteBufferWrite(int fd) {$/;"	f	signature:(int fd)
aofUpdateCurrentSize	aof.c	/^void aofUpdateCurrentSize(void) {$/;"	f	signature:(void)
aofUpdateCurrentSize	aof.c	/^void aofUpdateCurrentSize(void);$/;"	p	file:	signature:(void)
aof_background_fsync	aof.c	/^void aof_background_fsync(int fd) {$/;"	f	signature:(int fd)
aof_buf	redis.h	/^    sds aof_buf;      \/* AOF buffer, written before entering the event loop *\/$/;"	m	struct:redisServer	access:public
aof_child_diff	redis.h	/^    sds aof_child_diff;             \/* AOF diff accumulator child side. *\/$/;"	m	struct:redisServer	access:public
aof_child_pid	redis.h	/^    pid_t aof_child_pid;            \/* PID if rewriting process *\/$/;"	m	struct:redisServer	access:public
aof_current_size	redis.h	/^    off_t aof_current_size;         \/* AOF current size. *\/$/;"	m	struct:redisServer	access:public
aof_delayed_fsync	redis.h	/^    unsigned long aof_delayed_fsync;  \/* delayed AOF fsync() counter *\/$/;"	m	struct:redisServer	access:public
aof_fd	redis.h	/^    int aof_fd;       \/* File descriptor of currently selected AOF file *\/$/;"	m	struct:redisServer	access:public
aof_filename	redis.h	/^    char *aof_filename;             \/* Name of the AOF file *\/$/;"	m	struct:redisServer	access:public
aof_flush_postponed_start	redis.h	/^    time_t aof_flush_postponed_start; \/* UNIX time of postponed AOF flush *\/$/;"	m	struct:redisServer	access:public
aof_fsync	config.h	/^#define aof_fsync /;"	d
aof_fsync	redis.h	/^    int aof_fsync;                  \/* Kind of fsync() policy *\/$/;"	m	struct:redisServer	access:public
aof_last_fsync	redis.h	/^    time_t aof_last_fsync;            \/* UNIX time of last fsync() *\/$/;"	m	struct:redisServer	access:public
aof_last_write_errno	redis.h	/^    int aof_last_write_errno;       \/* Valid if aof_last_write_status is ERR *\/$/;"	m	struct:redisServer	access:public
aof_last_write_status	redis.h	/^    int aof_last_write_status;      \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer	access:public
aof_lastbgrewrite_status	redis.h	/^    int aof_lastbgrewrite_status;   \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer	access:public
aof_load_truncated	redis.h	/^    int aof_load_truncated;         \/* Don't stop on unexpected AOF EOF. *\/$/;"	m	struct:redisServer	access:public
aof_no_fsync_on_rewrite	redis.h	/^    int aof_no_fsync_on_rewrite;    \/* Don't fsync if a rewrite is in prog. *\/$/;"	m	struct:redisServer	access:public
aof_pipe_read_ack_from_child	redis.h	/^    int aof_pipe_read_ack_from_child;$/;"	m	struct:redisServer	access:public
aof_pipe_read_ack_from_parent	redis.h	/^    int aof_pipe_read_ack_from_parent;$/;"	m	struct:redisServer	access:public
aof_pipe_read_data_from_parent	redis.h	/^    int aof_pipe_read_data_from_parent;$/;"	m	struct:redisServer	access:public
aof_pipe_write_ack_to_child	redis.h	/^    int aof_pipe_write_ack_to_child;$/;"	m	struct:redisServer	access:public
aof_pipe_write_ack_to_parent	redis.h	/^    int aof_pipe_write_ack_to_parent;$/;"	m	struct:redisServer	access:public
aof_pipe_write_data_to_child	redis.h	/^    int aof_pipe_write_data_to_child;$/;"	m	struct:redisServer	access:public
aof_rewrite_base_size	redis.h	/^    off_t aof_rewrite_base_size;    \/* AOF size on latest startup or rewrite. *\/$/;"	m	struct:redisServer	access:public
aof_rewrite_buf_blocks	redis.h	/^    list *aof_rewrite_buf_blocks;   \/* Hold changes during an AOF rewrite. *\/$/;"	m	struct:redisServer	access:public
aof_rewrite_incremental_fsync	redis.h	/^    int aof_rewrite_incremental_fsync;\/* fsync incrementally while rewriting? *\/$/;"	m	struct:redisServer	access:public
aof_rewrite_min_size	redis.h	/^    off_t aof_rewrite_min_size;     \/* the AOF file is at least N bytes. *\/$/;"	m	struct:redisServer	access:public
aof_rewrite_perc	redis.h	/^    int aof_rewrite_perc;           \/* Rewrite AOF if % growth is > M and... *\/$/;"	m	struct:redisServer	access:public
aof_rewrite_scheduled	redis.h	/^    int aof_rewrite_scheduled;      \/* Rewrite once BGSAVE terminates. *\/$/;"	m	struct:redisServer	access:public
aof_rewrite_time_last	redis.h	/^    time_t aof_rewrite_time_last;   \/* Time used by last AOF rewrite run. *\/$/;"	m	struct:redisServer	access:public
aof_rewrite_time_start	redis.h	/^    time_t aof_rewrite_time_start;  \/* Current AOF rewrite start time. *\/$/;"	m	struct:redisServer	access:public
aof_selected_db	redis.h	/^    int aof_selected_db; \/* Currently selected DB in AOF *\/$/;"	m	struct:redisServer	access:public
aof_state	redis.h	/^    int aof_state;                  \/* REDIS_AOF_(ON|OFF|WAIT_REWRITE) *\/$/;"	m	struct:redisServer	access:public
aof_stop_sending_diff	redis.h	/^    int aof_stop_sending_diff;     \/* If true stop sending accumulated diffs$/;"	m	struct:redisServer	access:public
aofrwblock	aof.c	/^typedef struct aofrwblock {$/;"	s	file:
aofrwblock	aof.c	/^} aofrwblock;$/;"	t	typeref:struct:aofrwblock	file:
aofrwblock::buf	aof.c	/^    char buf[AOF_RW_BUF_BLOCK_SIZE];$/;"	m	struct:aofrwblock	file:	access:public
aofrwblock::free	aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:	access:public
aofrwblock::used	aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:	access:public
apidata	ae.h	/^    void *apidata; \/* This is used for polling API specific data *\/$/;"	m	struct:aeEventLoop	access:public
appendCommand	redis.h	/^void appendCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
appendCommand	t_string.c	/^void appendCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
appendServerSaveParams	config.c	/^void appendServerSaveParams(time_t seconds, int changes) {$/;"	f	signature:(time_t seconds, int changes)
appendServerSaveParams	redis.h	/^void appendServerSaveParams(time_t seconds, int changes);$/;"	p	signature:(time_t seconds, int changes)
arch_bits	redis.h	/^    int arch_bits;              \/* 32 or 64 depending on sizeof(long) *\/$/;"	m	struct:redisServer	access:public
arg0	setproctitle.c	/^	const char *arg0;$/;"	m	struct:__anon28	file:	access:public
arg1	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:	access:public
arg2	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:	access:public
arg3	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:	access:public
argc	redis-cli.c	/^    int argc;$/;"	m	struct:__anon15	file:	access:public
argc	redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp	access:public
argc	redis.h	/^    int argc;$/;"	m	struct:multiCmd	access:public
argc	redis.h	/^    int argc;$/;"	m	struct:redisClient	access:public
argc	slowlog.h	/^    int argc;$/;"	m	struct:slowlogEntry	access:public
argv	redis-cli.c	/^    sds *argv;$/;"	m	struct:__anon15	file:	access:public
argv	redis.h	/^    robj **argv;$/;"	m	struct:multiCmd	access:public
argv	redis.h	/^    robj **argv;$/;"	m	struct:redisClient	access:public
argv	redis.h	/^    robj **argv;$/;"	m	struct:redisOp	access:public
argv	sentinel.c	/^    char **argv;            \/* Arguments to call the script. *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
argv	slowlog.h	/^    robj **argv;$/;"	m	struct:slowlogEntry	access:public
arity	redis.h	/^    int arity;$/;"	m	struct:redisCommand	access:public
ascii_logo	asciilogo.h	/^char *ascii_logo =$/;"	v
asciilogo.h	asciilogo.h	1;"	F
askingCommand	cluster.c	/^void askingCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
askingCommand	redis.h	/^void askingCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
assert	intset.c	/^#define assert(/;"	d	file:
assert	redisassert.h	/^#define assert(/;"	d
assert_cluster	redis-trib.rb	/^    def assert_cluster$/;"	f	class:ClusterNode
assert_empty	redis-trib.rb	/^    def assert_empty$/;"	f	class:ClusterNode
assert_failed	redis.h	/^    char *assert_failed;$/;"	m	struct:redisServer	access:public
assert_file	redis.h	/^    char *assert_file;$/;"	m	struct:redisServer	access:public
assert_line	redis.h	/^    int assert_line;$/;"	m	struct:redisServer	access:public
assign_config_epoch	redis-trib.rb	/^    def assign_config_epoch$/;"	f	class:RedisTrib.alloc_slots
asyncCloseClientOnOutputBufferLimitReached	networking.c	/^void asyncCloseClientOnOutputBufferLimitReached(redisClient *c) {$/;"	f	signature:(redisClient *c)
asyncCloseClientOnOutputBufferLimitReached	redis.h	/^void asyncCloseClientOnOutputBufferLimitReached(redisClient *c);$/;"	p	signature:(redisClient *c)
auth	redis-benchmark.c	/^    char *auth;$/;"	m	struct:config	file:	access:public
auth	redis-cli.c	/^    char *auth;$/;"	m	struct:config	file:	access:public
authCommand	redis.c	/^void authCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
authCommand	redis.h	/^void authCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
auth_pass	sentinel.c	/^    char *auth_pass;    \/* Password to use for AUTH against master & slaves. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
authenticated	redis.h	/^    int authenticated;      \/* when requirepass is non-NULL *\/$/;"	m	struct:redisClient	access:public
autosync	rio.h	/^            off_t autosync; \/* fsync after 'autosync' bytes written. *\/$/;"	m	struct:_rio::__anon24::__anon26	access:public
avg	latency.h	/^    uint32_t avg;           \/* Average of current samples. *\/$/;"	m	struct:latencyStats	access:public
avg_ttl	redis.h	/^    long long avg_ttl;          \/* Average TTL, just for stats *\/$/;"	m	struct:redisDb	access:public
backgroundRewriteDoneHandler	aof.c	/^void backgroundRewriteDoneHandler(int exitcode, int bysignal) {$/;"	f	signature:(int exitcode, int bysignal)
backgroundRewriteDoneHandler	redis.h	/^void backgroundRewriteDoneHandler(int exitcode, int bysignal);$/;"	p	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandler	rdb.c	/^void backgroundSaveDoneHandler(int exitcode, int bysignal) {$/;"	f	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandler	rdb.h	/^void backgroundSaveDoneHandler(int exitcode, int bysignal);$/;"	p	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandlerDisk	rdb.c	/^void backgroundSaveDoneHandlerDisk(int exitcode, int bysignal) {$/;"	f	signature:(int exitcode, int bysignal)
backgroundSaveDoneHandlerSocket	rdb.c	/^void backgroundSaveDoneHandlerSocket(int exitcode, int bysignal) {$/;"	f	signature:(int exitcode, int bysignal)
backward	redis.h	/^    struct zskiplistNode *backward;$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode	access:public
base	setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon28	file:	access:public
beforeSleep	redis.c	/^void beforeSleep(struct aeEventLoop *eventLoop) {$/;"	f	signature:(struct aeEventLoop *eventLoop)
beforesleep	ae.h	/^    aeBeforeSleepProc *beforesleep;$/;"	m	struct:aeEventLoop	access:public
benchmark	redis-benchmark.c	/^static void benchmark(char *title, char *cmd, int len) {$/;"	f	file:	signature:(char *title, char *cmd, int len)
bgrewriteaofCommand	aof.c	/^void bgrewriteaofCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
bgrewriteaofCommand	redis.h	/^void bgrewriteaofCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
bgsaveCommand	rdb.c	/^void bgsaveCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
bgsaveCommand	redis.h	/^void bgsaveCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
bgsaveerr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
bigkeys	redis-cli.c	/^    int bigkeys;$/;"	m	struct:config	file:	access:public
bindaddr	redis.h	/^    char *bindaddr[REDIS_BINDADDR_MAX]; \/* Addresses we should bind to *\/$/;"	m	struct:redisServer	access:public
bindaddr_count	redis.h	/^    int bindaddr_count;         \/* Number of addresses in server.bindaddr[] *\/$/;"	m	struct:redisServer	access:public
bio.c	bio.c	1;"	F
bio.h	bio.h	1;"	F
bioCreateBackgroundJob	bio.c	/^void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3) {$/;"	f	signature:(int type, void *arg1, void *arg2, void *arg3)
bioCreateBackgroundJob	bio.h	/^void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3);$/;"	p	signature:(int type, void *arg1, void *arg2, void *arg3)
bioInit	bio.c	/^void bioInit(void) {$/;"	f	signature:(void)
bioInit	bio.h	/^void bioInit(void);$/;"	p	signature:(void)
bioKillThreads	bio.c	/^void bioKillThreads(void) {$/;"	f	signature:(void)
bioKillThreads	bio.h	/^void bioKillThreads(void);$/;"	p	signature:(void)
bioOlderJobOfType	bio.h	/^time_t bioOlderJobOfType(int type);$/;"	p	signature:(int type)
bioPendingJobsOfType	bio.c	/^unsigned long long bioPendingJobsOfType(int type) {$/;"	f	signature:(int type)
bioPendingJobsOfType	bio.h	/^unsigned long long bioPendingJobsOfType(int type);$/;"	p	signature:(int type)
bioProcessBackgroundJobs	bio.c	/^void *bioProcessBackgroundJobs(void *arg) {$/;"	f	signature:(void *arg)
bioProcessBackgroundJobs	bio.c	/^void *bioProcessBackgroundJobs(void *arg);$/;"	p	file:	signature:(void *arg)
bioWaitPendingJobsLE	bio.h	/^void bioWaitPendingJobsLE(int type, unsigned long long num);$/;"	p	signature:(int type, unsigned long long num)
bio_condvar	bio.c	/^static pthread_cond_t bio_condvar[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_job	bio.c	/^struct bio_job {$/;"	s	file:
bio_job::arg1	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:	access:public
bio_job::arg2	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:	access:public
bio_job::arg3	bio.c	/^    void *arg1, *arg2, *arg3;$/;"	m	struct:bio_job	file:	access:public
bio_job::time	bio.c	/^    time_t time; \/* Time at which the job was created. *\/$/;"	m	struct:bio_job	file:	access:public
bio_jobs	bio.c	/^static list *bio_jobs[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_mutex	bio.c	/^static pthread_mutex_t bio_mutex[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_pending	bio.c	/^static unsigned long long bio_pending[REDIS_BIO_NUM_OPS];$/;"	v	file:
bio_threads	bio.c	/^static pthread_t bio_threads[REDIS_BIO_NUM_OPS];$/;"	v	file:
bitcountCommand	bitops.c	/^void bitcountCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
bitcountCommand	redis.h	/^void bitcountCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
bitmapClearBit	cluster.c	/^void bitmapClearBit(unsigned char *bitmap, int pos) {$/;"	f	signature:(unsigned char *bitmap, int pos)
bitmapSetBit	cluster.c	/^void bitmapSetBit(unsigned char *bitmap, int pos) {$/;"	f	signature:(unsigned char *bitmap, int pos)
bitmapTestBit	cluster.c	/^int bitmapTestBit(unsigned char *bitmap, int pos) {$/;"	f	signature:(unsigned char *bitmap, int pos)
bitmapTestBit	cluster.c	/^int bitmapTestBit(unsigned char *bitmap, int pos);$/;"	p	file:	signature:(unsigned char *bitmap, int pos)
bitopCommand	bitops.c	/^void bitopCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
bitopCommand	redis.h	/^void bitopCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
bitops.c	bitops.c	1;"	F
bitposCommand	bitops.c	/^void bitposCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
bitposCommand	redis.h	/^void bitposCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
blk	sha1.c	/^#define blk(/;"	d	file:
blk0	sha1.c	/^#define blk0(/;"	d	file:
blockClient	blocked.c	/^void blockClient(redisClient *c, int btype) {$/;"	f	signature:(redisClient *c, int btype)
blockClient	redis.h	/^void blockClient(redisClient *c, int btype);$/;"	p	signature:(redisClient *c, int btype)
blockForKeys	t_list.c	/^void blockForKeys(redisClient *c, robj **keys, int numkeys, mstime_t timeout, robj *target) {$/;"	f	signature:(redisClient *c, robj **keys, int numkeys, mstime_t timeout, robj *target)
blocked.c	blocked.c	1;"	F
blockingPopGenericCommand	t_list.c	/^void blockingPopGenericCommand(redisClient *c, int where) {$/;"	f	signature:(redisClient *c, int where)
blockingState	redis.h	/^typedef struct blockingState {$/;"	s
blockingState	redis.h	/^} blockingState;$/;"	t	typeref:struct:blockingState
blockingState::keys	redis.h	/^    dict *keys;             \/* The keys we are waiting to terminate a blocking$/;"	m	struct:blockingState	access:public
blockingState::numreplicas	redis.h	/^    int numreplicas;        \/* Number of replicas we are waiting for ACK. *\/$/;"	m	struct:blockingState	access:public
blockingState::reploffset	redis.h	/^    long long reploffset;   \/* Replication offset to reach. *\/$/;"	m	struct:blockingState	access:public
blockingState::target	redis.h	/^    robj *target;           \/* The key that should receive the element,$/;"	m	struct:blockingState	access:public
blockingState::timeout	redis.h	/^    mstime_t timeout;       \/* Blocking operation timeout. If UNIX current time$/;"	m	struct:blockingState	access:public
blocking_keys	redis.h	/^    dict *blocking_keys;        \/* Keys with clients waiting for data (BLPOP) *\/$/;"	m	struct:redisDb	access:public
blpopCommand	redis.h	/^void blpopCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
blpopCommand	t_list.c	/^void blpopCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
bpop	redis.h	/^    blockingState bpop;     \/* blocking state *\/$/;"	m	struct:redisClient	access:public
bpop_blocked_clients	redis.h	/^    unsigned int bpop_blocked_clients; \/* Number of clients blocked by lists *\/$/;"	m	struct:redisServer	access:public
brpopCommand	redis.h	/^void brpopCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
brpopCommand	t_list.c	/^void brpopCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
brpoplpushCommand	redis.h	/^void brpoplpushCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
brpoplpushCommand	t_list.c	/^void brpoplpushCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
btype	redis.h	/^    int btype;              \/* Type of blocking op if REDIS_BLOCKED. *\/$/;"	m	struct:redisClient	access:public
buf	aof.c	/^    char buf[AOF_RW_BUF_BLOCK_SIZE];$/;"	m	struct:aofrwblock	file:	access:public
buf	redis.h	/^    char buf[REDIS_REPLY_CHUNK_BYTES];$/;"	m	struct:redisClient	access:public
buf	rio.h	/^            sds buf;$/;"	m	struct:_rio::__anon24::__anon27	access:public
buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr	access:public
buffer	rio.h	/^        } buffer;$/;"	m	union:_rio::__anon24	typeref:struct:_rio::__anon24::__anon25	access:public
buffer	sha1.h	/^    unsigned char buffer[64];$/;"	m	struct:__anon29	access:public
buffered	rio.h	/^            off_t buffered; \/* Bytes written since last fsync. *\/$/;"	m	struct:_rio::__anon24::__anon26	access:public
bufpos	redis.h	/^    int bufpos;$/;"	m	struct:redisClient	access:public
bugReportStart	debug.c	/^void bugReportStart(void) {$/;"	f	signature:(void)
bugReportStart	redis.h	/^void bugReportStart(void);$/;"	p	signature:(void)
bug_report_start	redis.h	/^    int bug_report_start; \/* True if bug report header was already logged. *\/$/;"	m	struct:redisServer	access:public
bulk_data	cluster.h	/^    unsigned char bulk_data[8];$/;"	m	struct:__anon3	access:public
bulkhdr	redis.h	/^    *bulkhdr[REDIS_SHARED_BULKHDR_LEN];  \/* "$<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct	access:public
bulklen	redis.h	/^    long bulklen;           \/* length of bulk argument in multi bulk request *\/$/;"	m	struct:redisClient	access:public
busykeyerr	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
bytesToHuman	redis-cli.c	/^void bytesToHuman(char *s, long long n) {$/;"	f	signature:(char *s, long long n)
bytesToHuman	redis.c	/^void bytesToHuman(char *s, unsigned long long n) {$/;"	f	signature:(char *s, unsigned long long n)
c	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
cached_master	redis.h	/^    redisClient *cached_master; \/* Cached master to be reused for PSYNC. *\/$/;"	m	struct:redisServer	access:public
call	redis.c	/^void call(redisClient *c, int flags) {$/;"	f	signature:(redisClient *c, int flags)
call	redis.h	/^void call(redisClient *c, int flags);$/;"	p	signature:(redisClient *c, int flags)
call_cluster_cmd	redis-trib.rb	/^    def call_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
calloc	redis.h	/^void *calloc(size_t count, size_t size) __attribute__ ((deprecated));$/;"	p	signature:(size_t count, size_t size)
calloc	zmalloc.c	/^#define calloc(/;"	d	file:
calls	redis.h	/^    long long microseconds, calls;$/;"	m	struct:redisCommand	access:public
cancelReplicationHandshake	replication.c	/^int cancelReplicationHandshake(void) {$/;"	f	signature:(void)
cant_failover_reason	cluster.h	/^    int cant_failover_reason;   \/* Why a slave is currently not able to$/;"	m	struct:clusterState	access:public
card	hyperloglog.c	/^    uint8_t card[8];    \/* Cached cardinality, little endian. *\/$/;"	m	struct:hllhdr	file:	access:public
catAppendOnlyExpireAtCommand	aof.c	/^sds catAppendOnlyExpireAtCommand(sds buf, struct redisCommand *cmd, robj *key, robj *seconds) {$/;"	f	signature:(sds buf, struct redisCommand *cmd, robj *key, robj *seconds)
catAppendOnlyGenericCommand	aof.c	/^sds catAppendOnlyGenericCommand(sds dst, int argc, robj **argv) {$/;"	f	signature:(sds dst, int argc, robj **argv)
catClientInfoString	networking.c	/^sds catClientInfoString(sds s, redisClient *client) {$/;"	f	signature:(sds s, redisClient *client)
catClientInfoString	redis.h	/^sds catClientInfoString(sds s, redisClient *client);$/;"	p	signature:(sds s, redisClient *client)
cc	sentinel.c	/^    redisAsyncContext *cc; \/* Hiredis context for commands. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
cc_conn_time	sentinel.c	/^    mstime_t cc_conn_time; \/* cc connection time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
cfd	redis.h	/^    int cfd[REDIS_BINDADDR_MAX];\/* Cluster bus listening socket *\/$/;"	m	struct:redisServer	access:public
cfd_count	redis.h	/^    int cfd_count;              \/* Used slots in cfd[] *\/$/;"	m	struct:redisServer	access:public
changes	redis.h	/^    int changes;$/;"	m	struct:saveparam	access:public
channel_len	cluster.h	/^    uint32_t channel_len;$/;"	m	struct:__anon3	access:public
character	redis-cli.c	/^    int character;   \/* Associated character in visualization. *\/$/;"	m	struct:distsamples	file:	access:public
charset	sparkline.c	/^static char charset[] = "_-`";$/;"	v	file:
charset_fill	sparkline.c	/^static char charset_fill[] = "_o#";$/;"	v	file:
charset_len	sparkline.c	/^static int charset_len = sizeof(charset)-1;$/;"	v	file:
checkClientOutputBufferLimits	networking.c	/^int checkClientOutputBufferLimits(redisClient *c) {$/;"	f	signature:(redisClient *c)
checkConsistency	intset.c	/^void checkConsistency(intset *is) {$/;"	f	signature:(intset *is)
checkForSentinelMode	redis.c	/^int checkForSentinelMode(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
checkStringLength	t_string.c	/^static int checkStringLength(redisClient *c, long long size) {$/;"	f	file:	signature:(redisClient *c, long long size)
checkTcpBacklogSettings	redis.c	/^void checkTcpBacklogSettings(void) {$/;"	f	signature:(void)
checkType	object.c	/^int checkType(redisClient *c, robj *o, int type) {$/;"	f	signature:(redisClient *c, robj *o, int type)
checkType	redis-check-dump.c	/^int checkType(unsigned char t) {$/;"	f	signature:(unsigned char t)
checkType	redis.h	/^int checkType(redisClient *c, robj *o, int type);$/;"	p	signature:(redisClient *c, robj *o, int type)
check_arity	redis-trib.rb	/^    def check_arity(req_args, num_args)$/;"	f	class:RedisTrib
check_cluster	redis-trib.rb	/^    def check_cluster$/;"	f	class:RedisTrib
check_cluster_cmd	redis-trib.rb	/^    def check_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
check_config_consistency	redis-trib.rb	/^    def check_config_consistency$/;"	f	class:RedisTrib
check_create_parameters	redis-trib.rb	/^    def check_create_parameters$/;"	f	class:RedisTrib.alloc_slots
check_open_slots	redis-trib.rb	/^    def check_open_slots$/;"	f	class:RedisTrib
check_slots_coverage	redis-trib.rb	/^    def check_slots_coverage$/;"	f	class:RedisTrib
cksum	rio.h	/^    uint64_t cksum;$/;"	m	struct:_rio	access:public
clearNodeFailureIfNeeded	cluster.c	/^void clearNodeFailureIfNeeded(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
cliAuth	redis-cli.c	/^static int cliAuth(void) {$/;"	f	file:	signature:(void)
cliConnect	redis-cli.c	/^static int cliConnect(int force) {$/;"	f	file:	signature:(int force)
cliFormatReplyCSV	redis-cli.c	/^static sds cliFormatReplyCSV(redisReply *r) {$/;"	f	file:	signature:(redisReply *r)
cliFormatReplyRaw	redis-cli.c	/^static sds cliFormatReplyRaw(redisReply *r) {$/;"	f	file:	signature:(redisReply *r)
cliFormatReplyTTY	redis-cli.c	/^static sds cliFormatReplyTTY(redisReply *r, char *prefix) {$/;"	f	file:	signature:(redisReply *r, char *prefix)
cliInitHelp	redis-cli.c	/^static void cliInitHelp(void) {$/;"	f	file:	signature:(void)
cliOutputCommandHelp	redis-cli.c	/^static void cliOutputCommandHelp(struct commandHelp *help, int group) {$/;"	f	file:	signature:(struct commandHelp *help, int group)
cliOutputGenericHelp	redis-cli.c	/^static void cliOutputGenericHelp(void) {$/;"	f	file:	signature:(void)
cliOutputHelp	redis-cli.c	/^static void cliOutputHelp(int argc, char **argv) {$/;"	f	file:	signature:(int argc, char **argv)
cliPrintContextError	redis-cli.c	/^static void cliPrintContextError(void) {$/;"	f	file:	signature:(void)
cliReadReply	redis-cli.c	/^static int cliReadReply(int output_raw_strings) {$/;"	f	file:	signature:(int output_raw_strings)
cliRefreshPrompt	redis-cli.c	/^static void cliRefreshPrompt(void) {$/;"	f	file:	signature:(void)
cliSelect	redis-cli.c	/^static int cliSelect(void) {$/;"	f	file:	signature:(void)
cliSendCommand	redis-cli.c	/^static int cliSendCommand(int argc, char **argv, int repeat) {$/;"	f	file:	signature:(int argc, char **argv, int repeat)
cliVersion	redis-cli.c	/^static sds cliVersion(void) {$/;"	f	file:	signature:(void)
client	redis-benchmark.c	/^} *client;$/;"	t	typeref:struct:_client	file:
client	redis.h	/^    redisClient *client;$/;"	m	struct:pubsubPattern	access:public
clientBufferLimitsConfig	redis.h	/^typedef struct clientBufferLimitsConfig {$/;"	s
clientBufferLimitsConfig	redis.h	/^} clientBufferLimitsConfig;$/;"	t	typeref:struct:clientBufferLimitsConfig
clientBufferLimitsConfig::hard_limit_bytes	redis.h	/^    unsigned long long hard_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig	access:public
clientBufferLimitsConfig::soft_limit_bytes	redis.h	/^    unsigned long long soft_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig	access:public
clientBufferLimitsConfig::soft_limit_seconds	redis.h	/^    time_t soft_limit_seconds;$/;"	m	struct:clientBufferLimitsConfig	access:public
clientBufferLimitsDefaults	config.c	/^clientBufferLimitsConfig clientBufferLimitsDefaults[REDIS_CLIENT_TYPE_COUNT] = {$/;"	v
clientBufferLimitsDefaults	redis.h	/^extern clientBufferLimitsConfig clientBufferLimitsDefaults[REDIS_CLIENT_TYPE_COUNT];$/;"	x
clientCommand	networking.c	/^void clientCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
clientCommand	redis.h	/^void clientCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeFileEvent	access:public
clientData	ae.h	/^    void *clientData;$/;"	m	struct:aeTimeEvent	access:public
clientDone	redis-benchmark.c	/^static void clientDone(client c) {$/;"	f	file:	signature:(client c)
clientSubscriptionsCount	pubsub.c	/^int clientSubscriptionsCount(redisClient *c) {$/;"	f	signature:(redisClient *c)
client_max_querybuf_len	redis.h	/^    size_t client_max_querybuf_len; \/* Limit for client query buffer length *\/$/;"	m	struct:redisServer	access:public
client_obuf_limits	redis.h	/^    clientBufferLimitsConfig client_obuf_limits[REDIS_CLIENT_TYPE_COUNT];$/;"	m	struct:redisServer	access:public
client_reconfig_script	sentinel.c	/^    char *client_reconfig_script;$/;"	m	struct:sentinelRedisInstance	file:	access:public
clients	redis-benchmark.c	/^    list *clients;$/;"	m	struct:config	file:	access:public
clients	redis.h	/^    list *clients;              \/* List of active clients *\/$/;"	m	struct:redisServer	access:public
clientsArePaused	networking.c	/^int clientsArePaused(void) {$/;"	f	signature:(void)
clientsArePaused	redis.h	/^int clientsArePaused(void);$/;"	p	signature:(void)
clientsCron	redis.c	/^void clientsCron(void) {$/;"	f	signature:(void)
clientsCronHandleTimeout	redis.c	/^int clientsCronHandleTimeout(redisClient *c, mstime_t now_ms) {$/;"	f	signature:(redisClient *c, mstime_t now_ms)
clientsCronResizeQueryBuffer	redis.c	/^int clientsCronResizeQueryBuffer(redisClient *c) {$/;"	f	signature:(redisClient *c)
clients_pause_end_time	redis.h	/^    mstime_t clients_pause_end_time; \/* Time when we undo clients_paused *\/$/;"	m	struct:redisServer	access:public
clients_paused	redis.h	/^    int clients_paused;         \/* True if clients are currently paused *\/$/;"	m	struct:redisServer	access:public
clients_to_close	redis.h	/^    list *clients_to_close;     \/* Clients to close asynchronously *\/$/;"	m	struct:redisServer	access:public
clients_waiting_acks	redis.h	/^    list *clients_waiting_acks;         \/* Clients waiting in WAIT command. *\/$/;"	m	struct:redisServer	access:public
closeListeningSockets	redis.c	/^void closeListeningSockets(int unlink_unix_socket) {$/;"	f	signature:(int unlink_unix_socket)
closeListeningSockets	redis.h	/^void closeListeningSockets(int unlink_unix_socket);$/;"	p	signature:(int unlink_unix_socket)
closeTimedoutClients	redis.h	/^void closeTimedoutClients(void);$/;"	p	signature:(void)
cluster	redis.h	/^    struct clusterState *cluster;  \/* State of the cluster *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::clusterState	access:public
cluster.c	cluster.c	1;"	F
cluster.h	cluster.h	1;"	F
clusterAcceptHandler	cluster.c	/^void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterAcceptHandler	cluster.c	/^void clusterAcceptHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterAddNode	cluster.c	/^int clusterAddNode(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterAddNode	cluster.c	/^int clusterAddNode(clusterNode *node);$/;"	p	file:	signature:(clusterNode *node)
clusterAddSlot	cluster.c	/^int clusterAddSlot(clusterNode *n, int slot) {$/;"	f	signature:(clusterNode *n, int slot)
clusterAddSlot	cluster.c	/^int clusterAddSlot(clusterNode *n, int slot);$/;"	p	file:	signature:(clusterNode *n, int slot)
clusterBeforeSleep	cluster.c	/^void clusterBeforeSleep(void) {$/;"	f	signature:(void)
clusterBeforeSleep	redis.h	/^void clusterBeforeSleep(void);$/;"	p	signature:(void)
clusterBlacklistAddNode	cluster.c	/^void clusterBlacklistAddNode(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterBlacklistCleanup	cluster.c	/^void clusterBlacklistCleanup(void) {$/;"	f	signature:(void)
clusterBlacklistExists	cluster.c	/^int clusterBlacklistExists(char *nodeid) {$/;"	f	signature:(char *nodeid)
clusterBroadcastMessage	cluster.c	/^void clusterBroadcastMessage(void *buf, size_t len) {$/;"	f	signature:(void *buf, size_t len)
clusterBroadcastPong	cluster.c	/^void clusterBroadcastPong(int target) {$/;"	f	signature:(int target)
clusterBuildMessageHdr	cluster.c	/^void clusterBuildMessageHdr(clusterMsg *hdr, int type) {$/;"	f	signature:(clusterMsg *hdr, int type)
clusterBumpConfigEpochWithoutConsensus	cluster.c	/^int clusterBumpConfigEpochWithoutConsensus(void) {$/;"	f	signature:(void)
clusterBumpConfigEpochWithoutConsensus	cluster.c	/^int clusterBumpConfigEpochWithoutConsensus(void);$/;"	p	file:	signature:(void)
clusterCloseAllSlots	cluster.c	/^void clusterCloseAllSlots(void) {$/;"	f	signature:(void)
clusterCloseAllSlots	cluster.c	/^void clusterCloseAllSlots(void);$/;"	p	file:	signature:(void)
clusterCommand	cluster.c	/^void clusterCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
clusterCommand	redis.h	/^void clusterCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
clusterCountNonFailingSlaves	cluster.c	/^int clusterCountNonFailingSlaves(clusterNode *n) {$/;"	f	signature:(clusterNode *n)
clusterCron	cluster.c	/^void clusterCron(void) {$/;"	f	signature:(void)
clusterCron	redis.h	/^void clusterCron(void);$/;"	p	signature:(void)
clusterDelNode	cluster.c	/^void clusterDelNode(clusterNode *delnode) {$/;"	f	signature:(clusterNode *delnode)
clusterDelNode	cluster.c	/^void clusterDelNode(clusterNode *delnode);$/;"	p	file:	signature:(clusterNode *delnode)
clusterDelNodeSlots	cluster.c	/^int clusterDelNodeSlots(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterDelNodeSlots	cluster.c	/^int clusterDelNodeSlots(clusterNode *node);$/;"	p	file:	signature:(clusterNode *node)
clusterDelSlot	cluster.c	/^int clusterDelSlot(int slot) {$/;"	f	signature:(int slot)
clusterDelSlot	cluster.c	/^int clusterDelSlot(int slot);$/;"	p	file:	signature:(int slot)
clusterDoBeforeSleep	cluster.c	/^void clusterDoBeforeSleep(int flags) {$/;"	f	signature:(int flags)
clusterDoBeforeSleep	cluster.c	/^void clusterDoBeforeSleep(int flags);$/;"	p	file:	signature:(int flags)
clusterFailoverReplaceYourMaster	cluster.c	/^void clusterFailoverReplaceYourMaster(void) {$/;"	f	signature:(void)
clusterGenNodeDescription	cluster.c	/^sds clusterGenNodeDescription(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterGenNodesDescription	cluster.c	/^sds clusterGenNodesDescription(int filter) {$/;"	f	signature:(int filter)
clusterGenNodesDescription	cluster.c	/^sds clusterGenNodesDescription(int filter);$/;"	p	file:	signature:(int filter)
clusterGetMaxEpoch	cluster.c	/^uint64_t clusterGetMaxEpoch(void) {$/;"	f	signature:(void)
clusterGetMaxEpoch	cluster.c	/^uint64_t clusterGetMaxEpoch(void);$/;"	p	file:	signature:(void)
clusterGetSlaveRank	cluster.c	/^int clusterGetSlaveRank(void) {$/;"	f	signature:(void)
clusterHandleConfigEpochCollision	cluster.c	/^void clusterHandleConfigEpochCollision(clusterNode *sender) {$/;"	f	signature:(clusterNode *sender)
clusterHandleManualFailover	cluster.c	/^void clusterHandleManualFailover(void) {$/;"	f	signature:(void)
clusterHandleSlaveFailover	cluster.c	/^void clusterHandleSlaveFailover(void) {$/;"	f	signature:(void)
clusterHandleSlaveFailover	cluster.c	/^void clusterHandleSlaveFailover(void);$/;"	p	file:	signature:(void)
clusterHandleSlaveMigration	cluster.c	/^void clusterHandleSlaveMigration(int max_slaves) {$/;"	f	signature:(int max_slaves)
clusterHandleSlaveMigration	cluster.c	/^void clusterHandleSlaveMigration(int max_slaves);$/;"	p	file:	signature:(int max_slaves)
clusterHandshakeInProgress	cluster.c	/^int clusterHandshakeInProgress(char *ip, int port) {$/;"	f	signature:(char *ip, int port)
clusterInit	cluster.c	/^void clusterInit(void) {$/;"	f	signature:(void)
clusterInit	redis.h	/^void clusterInit(void);$/;"	p	signature:(void)
clusterLink	cluster.h	/^typedef struct clusterLink {$/;"	s
clusterLink	cluster.h	/^} clusterLink;$/;"	t	typeref:struct:clusterLink
clusterLink::ctime	cluster.h	/^    mstime_t ctime;             \/* Link creation time *\/$/;"	m	struct:clusterLink	access:public
clusterLink::fd	cluster.h	/^    int fd;                     \/* TCP socket file descriptor *\/$/;"	m	struct:clusterLink	access:public
clusterLink::node	cluster.h	/^    struct clusterNode *node;   \/* Node related to this link if any, or NULL *\/$/;"	m	struct:clusterLink	typeref:struct:clusterLink::clusterNode	access:public
clusterLink::rcvbuf	cluster.h	/^    sds rcvbuf;                 \/* Packet reception buffer *\/$/;"	m	struct:clusterLink	access:public
clusterLink::sndbuf	cluster.h	/^    sds sndbuf;                 \/* Packet send buffer *\/$/;"	m	struct:clusterLink	access:public
clusterLoadConfig	cluster.c	/^int clusterLoadConfig(char *filename) {$/;"	f	signature:(char *filename)
clusterLockConfig	cluster.c	/^int clusterLockConfig(char *filename) {$/;"	f	signature:(char *filename)
clusterLogCantFailover	cluster.c	/^void clusterLogCantFailover(int reason) {$/;"	f	signature:(int reason)
clusterLookupNode	cluster.c	/^clusterNode *clusterLookupNode(char *name) {$/;"	f	signature:(char *name)
clusterLookupNode	cluster.c	/^clusterNode *clusterLookupNode(char *name);$/;"	p	file:	signature:(char *name)
clusterMsg	cluster.h	/^} clusterMsg;$/;"	t	typeref:struct:__anon9
clusterMsgData	cluster.h	/^union clusterMsgData {$/;"	u
clusterMsgData::__anon5::gossip	cluster.h	/^        clusterMsgDataGossip gossip[1];$/;"	m	struct:clusterMsgData::__anon5	access:public
clusterMsgData::__anon6::about	cluster.h	/^        clusterMsgDataFail about;$/;"	m	struct:clusterMsgData::__anon6	access:public
clusterMsgData::__anon7::msg	cluster.h	/^        clusterMsgDataPublish msg;$/;"	m	struct:clusterMsgData::__anon7	access:public
clusterMsgData::__anon8::nodecfg	cluster.h	/^        clusterMsgDataUpdate nodecfg;$/;"	m	struct:clusterMsgData::__anon8	access:public
clusterMsgData::fail	cluster.h	/^    } fail;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon6	access:public
clusterMsgData::ping	cluster.h	/^    } ping;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon5	access:public
clusterMsgData::publish	cluster.h	/^    } publish;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon7	access:public
clusterMsgData::update	cluster.h	/^    } update;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon8	access:public
clusterMsgDataFail	cluster.h	/^} clusterMsgDataFail;$/;"	t	typeref:struct:__anon2
clusterMsgDataGossip	cluster.h	/^} clusterMsgDataGossip;$/;"	t	typeref:struct:__anon1
clusterMsgDataPublish	cluster.h	/^} clusterMsgDataPublish;$/;"	t	typeref:struct:__anon3
clusterMsgDataUpdate	cluster.h	/^} clusterMsgDataUpdate;$/;"	t	typeref:struct:__anon4
clusterNode	cluster.h	/^struct clusterNode;$/;"	x
clusterNode	cluster.h	/^typedef struct clusterNode {$/;"	s
clusterNode	cluster.h	/^} clusterNode;$/;"	t	typeref:struct:clusterNode
clusterNode::configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Last configEpoch observed for this node *\/$/;"	m	struct:clusterNode	access:public
clusterNode::ctime	cluster.h	/^    mstime_t ctime; \/* Node object creation time. *\/$/;"	m	struct:clusterNode	access:public
clusterNode::fail_reports	cluster.h	/^    list *fail_reports;         \/* List of nodes signaling this as failing *\/$/;"	m	struct:clusterNode	access:public
clusterNode::fail_time	cluster.h	/^    mstime_t fail_time;      \/* Unix time when FAIL flag was set *\/$/;"	m	struct:clusterNode	access:public
clusterNode::flags	cluster.h	/^    int flags;      \/* REDIS_NODE_... *\/$/;"	m	struct:clusterNode	access:public
clusterNode::ip	cluster.h	/^    char ip[REDIS_IP_STR_LEN];  \/* Latest known IP address of this node *\/$/;"	m	struct:clusterNode	access:public
clusterNode::link	cluster.h	/^    clusterLink *link;          \/* TCP\/IP link with this node *\/$/;"	m	struct:clusterNode	access:public
clusterNode::name	cluster.h	/^    char name[REDIS_CLUSTER_NAMELEN]; \/* Node name, hex string, sha1-size *\/$/;"	m	struct:clusterNode	access:public
clusterNode::numslaves	cluster.h	/^    int numslaves;  \/* Number of slave nodes, if this is a master *\/$/;"	m	struct:clusterNode	access:public
clusterNode::numslots	cluster.h	/^    int numslots;   \/* Number of slots handled by this node *\/$/;"	m	struct:clusterNode	access:public
clusterNode::ping_sent	cluster.h	/^    mstime_t ping_sent;      \/* Unix time we sent latest ping *\/$/;"	m	struct:clusterNode	access:public
clusterNode::pong_received	cluster.h	/^    mstime_t pong_received;  \/* Unix time we received the pong *\/$/;"	m	struct:clusterNode	access:public
clusterNode::port	cluster.h	/^    int port;                   \/* Latest known port of this node *\/$/;"	m	struct:clusterNode	access:public
clusterNode::repl_offset	cluster.h	/^    long long repl_offset;      \/* Last known repl offset for this node. *\/$/;"	m	struct:clusterNode	access:public
clusterNode::repl_offset_time	cluster.h	/^    mstime_t repl_offset_time;  \/* Unix time we received offset for this node *\/$/;"	m	struct:clusterNode	access:public
clusterNode::slaveof	cluster.h	/^    struct clusterNode *slaveof; \/* pointer to the master node *\/$/;"	m	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
clusterNode::slaves	cluster.h	/^    struct clusterNode **slaves; \/* pointers to slave nodes *\/$/;"	m	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
clusterNode::slots	cluster.h	/^    unsigned char slots[REDIS_CLUSTER_SLOTS\/8]; \/* slots handled by this node *\/$/;"	m	struct:clusterNode	access:public
clusterNode::voted_time	cluster.h	/^    mstime_t voted_time;     \/* Last time we voted for a slave of this master *\/$/;"	m	struct:clusterNode	access:public
clusterNodeAddFailureReport	cluster.c	/^int clusterNodeAddFailureReport(clusterNode *failing, clusterNode *sender) {$/;"	f	signature:(clusterNode *failing, clusterNode *sender)
clusterNodeAddSlave	cluster.c	/^int clusterNodeAddSlave(clusterNode *master, clusterNode *slave) {$/;"	f	signature:(clusterNode *master, clusterNode *slave)
clusterNodeAddSlave	cluster.c	/^int clusterNodeAddSlave(clusterNode *master, clusterNode *slave);$/;"	p	file:	signature:(clusterNode *master, clusterNode *slave)
clusterNodeCleanupFailureReports	cluster.c	/^void clusterNodeCleanupFailureReports(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterNodeClearSlotBit	cluster.c	/^int clusterNodeClearSlotBit(clusterNode *n, int slot) {$/;"	f	signature:(clusterNode *n, int slot)
clusterNodeDelFailureReport	cluster.c	/^int clusterNodeDelFailureReport(clusterNode *node, clusterNode *sender) {$/;"	f	signature:(clusterNode *node, clusterNode *sender)
clusterNodeFailReport	cluster.h	/^typedef struct clusterNodeFailReport {$/;"	s
clusterNodeFailReport	cluster.h	/^} clusterNodeFailReport;$/;"	t	typeref:struct:clusterNodeFailReport
clusterNodeFailReport::node	cluster.h	/^    struct clusterNode *node;  \/* Node reporting the failure condition. *\/$/;"	m	struct:clusterNodeFailReport	typeref:struct:clusterNodeFailReport::clusterNode	access:public
clusterNodeFailReport::time	cluster.h	/^    mstime_t time;             \/* Time of the last report from this node. *\/$/;"	m	struct:clusterNodeFailReport	access:public
clusterNodeFailureReportsCount	cluster.c	/^int clusterNodeFailureReportsCount(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterNodeGetSlotBit	cluster.c	/^int clusterNodeGetSlotBit(clusterNode *n, int slot) {$/;"	f	signature:(clusterNode *n, int slot)
clusterNodeGetSlotBit	cluster.c	/^int clusterNodeGetSlotBit(clusterNode *n, int slot);$/;"	p	file:	signature:(clusterNode *n, int slot)
clusterNodeRemoveSlave	cluster.c	/^int clusterNodeRemoveSlave(clusterNode *master, clusterNode *slave) {$/;"	f	signature:(clusterNode *master, clusterNode *slave)
clusterNodeResetSlaves	cluster.c	/^void clusterNodeResetSlaves(clusterNode *n) {$/;"	f	signature:(clusterNode *n)
clusterNodeSetSlotBit	cluster.c	/^int clusterNodeSetSlotBit(clusterNode *n, int slot) {$/;"	f	signature:(clusterNode *n, int slot)
clusterNodeSetSlotBit	cluster.c	/^int clusterNodeSetSlotBit(clusterNode *n, int slot);$/;"	p	file:	signature:(clusterNode *n, int slot)
clusterNodesBlackListDictType	redis.c	/^dictType clusterNodesBlackListDictType = {$/;"	v
clusterNodesBlackListDictType	redis.h	/^extern dictType clusterNodesBlackListDictType;$/;"	x
clusterNodesDictType	redis.c	/^dictType clusterNodesDictType = {$/;"	v
clusterNodesDictType	redis.h	/^extern dictType clusterNodesDictType;$/;"	x
clusterProcessGossipSection	cluster.c	/^void clusterProcessGossipSection(clusterMsg *hdr, clusterLink *link) {$/;"	f	signature:(clusterMsg *hdr, clusterLink *link)
clusterProcessPacket	cluster.c	/^int clusterProcessPacket(clusterLink *link) {$/;"	f	signature:(clusterLink *link)
clusterPropagatePublish	cluster.c	/^void clusterPropagatePublish(robj *channel, robj *message) {$/;"	f	signature:(robj *channel, robj *message)
clusterPropagatePublish	redis.h	/^void clusterPropagatePublish(robj *channel, robj *message);$/;"	p	signature:(robj *channel, robj *message)
clusterReadHandler	cluster.c	/^void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterReadHandler	cluster.c	/^void clusterReadHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
clusterRedirectBlockedClientIfNeeded	cluster.c	/^int clusterRedirectBlockedClientIfNeeded(redisClient *c) {$/;"	f	signature:(redisClient *c)
clusterRedirectBlockedClientIfNeeded	cluster.h	/^int clusterRedirectBlockedClientIfNeeded(redisClient *c);$/;"	p	signature:(redisClient *c)
clusterRedirectClient	cluster.c	/^void clusterRedirectClient(redisClient *c, clusterNode *n, int hashslot, int error_code) {$/;"	f	signature:(redisClient *c, clusterNode *n, int hashslot, int error_code)
clusterRedirectClient	cluster.h	/^void clusterRedirectClient(redisClient *c, clusterNode *n, int hashslot, int error_code);$/;"	p	signature:(redisClient *c, clusterNode *n, int hashslot, int error_code)
clusterRenameNode	cluster.c	/^void clusterRenameNode(clusterNode *node, char *newname) {$/;"	f	signature:(clusterNode *node, char *newname)
clusterReplyMultiBulkSlots	cluster.c	/^void clusterReplyMultiBulkSlots(redisClient *c) {$/;"	f	signature:(redisClient *c)
clusterRequestFailoverAuth	cluster.c	/^void clusterRequestFailoverAuth(void) {$/;"	f	signature:(void)
clusterReset	cluster.c	/^void clusterReset(int hard) {$/;"	f	signature:(int hard)
clusterSaveConfig	cluster.c	/^int clusterSaveConfig(int do_fsync) {$/;"	f	signature:(int do_fsync)
clusterSaveConfigOrDie	cluster.c	/^void clusterSaveConfigOrDie(int do_fsync) {$/;"	f	signature:(int do_fsync)
clusterSendFail	cluster.c	/^void clusterSendFail(char *nodename) {$/;"	f	signature:(char *nodename)
clusterSendFail	cluster.c	/^void clusterSendFail(char *nodename);$/;"	p	file:	signature:(char *nodename)
clusterSendFailoverAuth	cluster.c	/^void clusterSendFailoverAuth(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterSendFailoverAuthIfNeeded	cluster.c	/^void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request) {$/;"	f	signature:(clusterNode *node, clusterMsg *request)
clusterSendFailoverAuthIfNeeded	cluster.c	/^void clusterSendFailoverAuthIfNeeded(clusterNode *node, clusterMsg *request);$/;"	p	file:	signature:(clusterNode *node, clusterMsg *request)
clusterSendMFStart	cluster.c	/^void clusterSendMFStart(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
clusterSendMessage	cluster.c	/^void clusterSendMessage(clusterLink *link, unsigned char *msg, size_t msglen) {$/;"	f	signature:(clusterLink *link, unsigned char *msg, size_t msglen)
clusterSendPing	cluster.c	/^void clusterSendPing(clusterLink *link, int type) {$/;"	f	signature:(clusterLink *link, int type)
clusterSendPing	cluster.c	/^void clusterSendPing(clusterLink *link, int type);$/;"	p	file:	signature:(clusterLink *link, int type)
clusterSendPublish	cluster.c	/^void clusterSendPublish(clusterLink *link, robj *channel, robj *message) {$/;"	f	signature:(clusterLink *link, robj *channel, robj *message)
clusterSendUpdate	cluster.c	/^void clusterSendUpdate(clusterLink *link, clusterNode *node) {$/;"	f	signature:(clusterLink *link, clusterNode *node)
clusterSendUpdate	cluster.c	/^void clusterSendUpdate(clusterLink *link, clusterNode *node);$/;"	p	file:	signature:(clusterLink *link, clusterNode *node)
clusterSetMaster	cluster.c	/^void clusterSetMaster(clusterNode *n) {$/;"	f	signature:(clusterNode *n)
clusterSetMaster	cluster.c	/^void clusterSetMaster(clusterNode *n);$/;"	p	file:	signature:(clusterNode *n)
clusterSetNodeAsMaster	cluster.c	/^void clusterSetNodeAsMaster(clusterNode *n) {$/;"	f	signature:(clusterNode *n)
clusterSetNodeAsMaster	cluster.c	/^void clusterSetNodeAsMaster(clusterNode *n);$/;"	p	file:	signature:(clusterNode *n)
clusterStartHandshake	cluster.c	/^int clusterStartHandshake(char *ip, int port) {$/;"	f	signature:(char *ip, int port)
clusterState	cluster.h	/^typedef struct clusterState {$/;"	s
clusterState	cluster.h	/^} clusterState;$/;"	t	typeref:struct:clusterState
clusterState	redis.h	/^struct clusterState;$/;"	x
clusterState::cant_failover_reason	cluster.h	/^    int cant_failover_reason;   \/* Why a slave is currently not able to$/;"	m	struct:clusterState	access:public
clusterState::currentEpoch	cluster.h	/^    uint64_t currentEpoch;$/;"	m	struct:clusterState	access:public
clusterState::failover_auth_count	cluster.h	/^    int failover_auth_count;    \/* Number of votes received so far. *\/$/;"	m	struct:clusterState	access:public
clusterState::failover_auth_epoch	cluster.h	/^    uint64_t failover_auth_epoch; \/* Epoch of the current election. *\/$/;"	m	struct:clusterState	access:public
clusterState::failover_auth_rank	cluster.h	/^    int failover_auth_rank;     \/* This slave rank for current auth request. *\/$/;"	m	struct:clusterState	access:public
clusterState::failover_auth_sent	cluster.h	/^    int failover_auth_sent;     \/* True if we already asked for votes. *\/$/;"	m	struct:clusterState	access:public
clusterState::failover_auth_time	cluster.h	/^    mstime_t failover_auth_time; \/* Time of previous or next election. *\/$/;"	m	struct:clusterState	access:public
clusterState::importing_slots_from	cluster.h	/^    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];$/;"	m	struct:clusterState	access:public
clusterState::lastVoteEpoch	cluster.h	/^    uint64_t lastVoteEpoch;     \/* Epoch of the last vote granted. *\/$/;"	m	struct:clusterState	access:public
clusterState::mf_can_start	cluster.h	/^    int mf_can_start;           \/* If non-zero signal that the manual failover$/;"	m	struct:clusterState	access:public
clusterState::mf_end	cluster.h	/^    mstime_t mf_end;            \/* Manual failover time limit (ms unixtime).$/;"	m	struct:clusterState	access:public
clusterState::mf_master_offset	cluster.h	/^    long long mf_master_offset; \/* Master offset the slave needs to start MF$/;"	m	struct:clusterState	access:public
clusterState::mf_slave	cluster.h	/^    clusterNode *mf_slave;      \/* Slave performing the manual failover. *\/$/;"	m	struct:clusterState	access:public
clusterState::migrating_slots_to	cluster.h	/^    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];$/;"	m	struct:clusterState	access:public
clusterState::myself	cluster.h	/^    clusterNode *myself;  \/* This node *\/$/;"	m	struct:clusterState	access:public
clusterState::nodes	cluster.h	/^    dict *nodes;          \/* Hash table of name -> clusterNode structures *\/$/;"	m	struct:clusterState	access:public
clusterState::nodes_black_list	cluster.h	/^    dict *nodes_black_list; \/* Nodes we don't re-add for a few seconds. *\/$/;"	m	struct:clusterState	access:public
clusterState::size	cluster.h	/^    int size;             \/* Num of master nodes with at least one slot *\/$/;"	m	struct:clusterState	access:public
clusterState::slots	cluster.h	/^    clusterNode *slots[REDIS_CLUSTER_SLOTS];$/;"	m	struct:clusterState	access:public
clusterState::slots_to_keys	cluster.h	/^    zskiplist *slots_to_keys;$/;"	m	struct:clusterState	access:public
clusterState::state	cluster.h	/^    int state;            \/* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... *\/$/;"	m	struct:clusterState	access:public
clusterState::stats_bus_messages_received	cluster.h	/^    long long stats_bus_messages_received; \/* Num of msg rcvd via cluster bus.*\/$/;"	m	struct:clusterState	access:public
clusterState::stats_bus_messages_sent	cluster.h	/^    long long stats_bus_messages_sent;  \/* Num of msg sent via cluster bus. *\/$/;"	m	struct:clusterState	access:public
clusterState::todo_before_sleep	cluster.h	/^    int todo_before_sleep; \/* Things to do in clusterBeforeSleep(). *\/$/;"	m	struct:clusterState	access:public
clusterUpdateSlotsConfigWith	cluster.c	/^void clusterUpdateSlotsConfigWith(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots) {$/;"	f	signature:(clusterNode *sender, uint64_t senderConfigEpoch, unsigned char *slots)
clusterUpdateState	cluster.c	/^void clusterUpdateState(void) {$/;"	f	signature:(void)
clusterUpdateState	cluster.c	/^void clusterUpdateState(void);$/;"	p	file:	signature:(void)
clusterWriteHandler	cluster.c	/^void clusterWriteHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
cluster_configfile	redis.h	/^    char *cluster_configfile; \/* Cluster auto-generated config file name. *\/$/;"	m	struct:redisServer	access:public
cluster_enabled	redis.h	/^    int cluster_enabled;      \/* Is cluster enabled? *\/$/;"	m	struct:redisServer	access:public
cluster_error	redis-trib.rb	/^    def cluster_error(msg)$/;"	f	class:RedisTrib
cluster_migration_barrier	redis.h	/^    int cluster_migration_barrier; \/* Cluster replicas migration barrier. *\/$/;"	m	struct:redisServer	access:public
cluster_mode	redis-cli.c	/^    int cluster_mode;$/;"	m	struct:config	file:	access:public
cluster_node_timeout	redis.h	/^    mstime_t cluster_node_timeout; \/* Cluster node timeout. *\/$/;"	m	struct:redisServer	access:public
cluster_reissue_command	redis-cli.c	/^    int cluster_reissue_command;$/;"	m	struct:config	file:	access:public
cluster_require_full_coverage	redis.h	/^    int cluster_require_full_coverage; \/* If true, put the cluster down if$/;"	m	struct:redisServer	access:public
cluster_slave_validity_factor	redis.h	/^    int cluster_slave_validity_factor; \/* Slave max data age for failover. *\/$/;"	m	struct:redisServer	access:public
cmd	redis.h	/^    struct redisCommand *cmd, *lastcmd;$/;"	m	struct:redisClient	typeref:struct:redisClient::redisCommand	access:public
cmd	redis.h	/^    struct redisCommand *cmd;$/;"	m	struct:multiCmd	typeref:struct:multiCmd::redisCommand	access:public
cmd	redis.h	/^    struct redisCommand *cmd;$/;"	m	struct:redisOp	typeref:struct:redisOp::redisCommand	access:public
cmpobj	redis.h	/^        robj *cmpobj;$/;"	m	union:_redisSortObject::__anon17	access:public
cnegone	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
collateStringObjects	object.c	/^int collateStringObjects(robj *a, robj *b) {$/;"	f	signature:(robj *a, robj *b)
collateStringObjects	redis.h	/^int collateStringObjects(robj *a, robj *b);$/;"	p	signature:(robj *a, robj *b)
colon	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
commandCommand	redis.c	/^void commandCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
commandCommand	redis.h	/^void commandCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
commandGroups	help.h	/^static char *commandGroups[] = {$/;"	v
commandHelp	help.h	/^struct commandHelp {$/;"	s
commandHelp	help.h	/^} commandHelp[] = {$/;"	v	typeref:struct:commandHelp
commandHelp::group	help.h	/^  int group;$/;"	m	struct:commandHelp	access:public
commandHelp::name	help.h	/^  char *name;$/;"	m	struct:commandHelp	access:public
commandHelp::params	help.h	/^  char *params;$/;"	m	struct:commandHelp	access:public
commandHelp::since	help.h	/^  char *since;$/;"	m	struct:commandHelp	access:public
commandHelp::summary	help.h	/^  char *summary;$/;"	m	struct:commandHelp	access:public
commandTableDictType	redis.c	/^dictType commandTableDictType = {$/;"	v
commands	redis.h	/^    dict *commands;             \/* Command table *\/$/;"	m	struct:redisServer	access:public
commands	redis.h	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	struct:multiState	access:public
compareLatency	redis-benchmark.c	/^static int compareLatency(const void *a, const void *b) {$/;"	f	file:	signature:(const void *a, const void *b)
compareSlavesForPromotion	sentinel.c	/^int compareSlavesForPromotion(const void *a, const void *b) {$/;"	f	signature:(const void *a, const void *b)
compareStringObjects	object.c	/^int compareStringObjects(robj *a, robj *b) {$/;"	f	signature:(robj *a, robj *b)
compareStringObjects	redis.h	/^int compareStringObjects(robj *a, robj *b);$/;"	p	signature:(robj *a, robj *b)
compareStringObjectsForLexRange	t_zset.c	/^int compareStringObjectsForLexRange(robj *a, robj *b) {$/;"	f	signature:(robj *a, robj *b)
compareStringObjectsWithFlags	object.c	/^int compareStringObjectsWithFlags(robj *a, robj *b, int flags) {$/;"	f	signature:(robj *a, robj *b, int flags)
completionCallback	redis-cli.c	/^static void completionCallback(const char *buf, linenoiseCompletions *lc) {$/;"	f	file:	signature:(const char *buf, linenoiseCompletions *lc)
computeDatasetDigest	debug.c	/^void computeDatasetDigest(unsigned char *final) {$/;"	f	signature:(unsigned char *final)
compute_reshard_table	redis-trib.rb	/^    def compute_reshard_table(sources,numslots)$/;"	f	class:RedisTrib.alloc_slots
compute_something_fast	redis-cli.c	/^unsigned long compute_something_fast(void) {$/;"	f	signature:(void)
cone	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
config	redis-benchmark.c	/^static struct config {$/;"	s	file:
config	redis-benchmark.c	/^} config;$/;"	v	typeref:struct:config	file:
config	redis-cli.c	/^static struct config {$/;"	s	file:
config	redis-cli.c	/^} config;$/;"	v	typeref:struct:config	file:
config.c	config.c	1;"	F
config.h	config.h	1;"	F
config::auth	redis-benchmark.c	/^    char *auth;$/;"	m	struct:config	file:	access:public
config::auth	redis-cli.c	/^    char *auth;$/;"	m	struct:config	file:	access:public
config::bigkeys	redis-cli.c	/^    int bigkeys;$/;"	m	struct:config	file:	access:public
config::clients	redis-benchmark.c	/^    list *clients;$/;"	m	struct:config	file:	access:public
config::cluster_mode	redis-cli.c	/^    int cluster_mode;$/;"	m	struct:config	file:	access:public
config::cluster_reissue_command	redis-cli.c	/^    int cluster_reissue_command;$/;"	m	struct:config	file:	access:public
config::csv	redis-benchmark.c	/^    int csv;$/;"	m	struct:config	file:	access:public
config::datasize	redis-benchmark.c	/^    int datasize;$/;"	m	struct:config	file:	access:public
config::dbnum	redis-benchmark.c	/^    int dbnum;$/;"	m	struct:config	file:	access:public
config::dbnum	redis-cli.c	/^    int dbnum;$/;"	m	struct:config	file:	access:public
config::dbnumstr	redis-benchmark.c	/^    sds dbnumstr;$/;"	m	struct:config	file:	access:public
config::el	redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	struct:config	file:	access:public
config::eval	redis-cli.c	/^    char *eval;$/;"	m	struct:config	file:	access:public
config::getrdb_mode	redis-cli.c	/^    int getrdb_mode;$/;"	m	struct:config	file:	access:public
config::hostip	redis-benchmark.c	/^    const char *hostip;$/;"	m	struct:config	file:	access:public
config::hostip	redis-cli.c	/^    char *hostip;$/;"	m	struct:config	file:	access:public
config::hostport	redis-benchmark.c	/^    int hostport;$/;"	m	struct:config	file:	access:public
config::hostport	redis-cli.c	/^    int hostport;$/;"	m	struct:config	file:	access:public
config::hostsocket	redis-benchmark.c	/^    const char *hostsocket;$/;"	m	struct:config	file:	access:public
config::hostsocket	redis-cli.c	/^    char *hostsocket;$/;"	m	struct:config	file:	access:public
config::idlemode	redis-benchmark.c	/^    int idlemode;$/;"	m	struct:config	file:	access:public
config::interactive	redis-cli.c	/^    int interactive;$/;"	m	struct:config	file:	access:public
config::interval	redis-cli.c	/^    long interval;$/;"	m	struct:config	file:	access:public
config::intrinsic_latency_duration	redis-cli.c	/^    int intrinsic_latency_duration;$/;"	m	struct:config	file:	access:public
config::intrinsic_latency_mode	redis-cli.c	/^    int intrinsic_latency_mode;$/;"	m	struct:config	file:	access:public
config::keepalive	redis-benchmark.c	/^    int keepalive;$/;"	m	struct:config	file:	access:public
config::keysize	redis-benchmark.c	/^    int keysize;$/;"	m	struct:config	file:	access:public
config::last_cmd_type	redis-cli.c	/^    int last_cmd_type;$/;"	m	struct:config	file:	access:public
config::latency	redis-benchmark.c	/^    long long *latency;$/;"	m	struct:config	file:	access:public
config::latency_dist_mode	redis-cli.c	/^    int latency_dist_mode;$/;"	m	struct:config	file:	access:public
config::latency_history	redis-cli.c	/^    int latency_history;$/;"	m	struct:config	file:	access:public
config::latency_mode	redis-cli.c	/^    int latency_mode;$/;"	m	struct:config	file:	access:public
config::liveclients	redis-benchmark.c	/^    int liveclients;$/;"	m	struct:config	file:	access:public
config::loop	redis-benchmark.c	/^    int loop;$/;"	m	struct:config	file:	access:public
config::lru_test_mode	redis-cli.c	/^    int lru_test_mode;$/;"	m	struct:config	file:	access:public
config::lru_test_sample_size	redis-cli.c	/^    long long lru_test_sample_size;$/;"	m	struct:config	file:	access:public
config::mb_delim	redis-cli.c	/^    sds mb_delim;$/;"	m	struct:config	file:	access:public
config::monitor_mode	redis-cli.c	/^    int monitor_mode;$/;"	m	struct:config	file:	access:public
config::numclients	redis-benchmark.c	/^    int numclients;$/;"	m	struct:config	file:	access:public
config::output	redis-cli.c	/^    int output; \/* output mode, see OUTPUT_* defines *\/$/;"	m	struct:config	file:	access:public
config::pattern	redis-cli.c	/^    char *pattern;$/;"	m	struct:config	file:	access:public
config::pipe_mode	redis-cli.c	/^    int pipe_mode;$/;"	m	struct:config	file:	access:public
config::pipe_timeout	redis-cli.c	/^    int pipe_timeout;$/;"	m	struct:config	file:	access:public
config::pipeline	redis-benchmark.c	/^    int pipeline;$/;"	m	struct:config	file:	access:public
config::prompt	redis-cli.c	/^    char prompt[128];$/;"	m	struct:config	file:	access:public
config::pubsub_mode	redis-cli.c	/^    int pubsub_mode;$/;"	m	struct:config	file:	access:public
config::quiet	redis-benchmark.c	/^    int quiet;$/;"	m	struct:config	file:	access:public
config::randomkeys	redis-benchmark.c	/^    int randomkeys;$/;"	m	struct:config	file:	access:public
config::randomkeys_keyspacelen	redis-benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	struct:config	file:	access:public
config::rdb_filename	redis-cli.c	/^    char *rdb_filename;$/;"	m	struct:config	file:	access:public
config::repeat	redis-cli.c	/^    long repeat;$/;"	m	struct:config	file:	access:public
config::requests	redis-benchmark.c	/^    int requests;$/;"	m	struct:config	file:	access:public
config::requests_finished	redis-benchmark.c	/^    int requests_finished;$/;"	m	struct:config	file:	access:public
config::requests_issued	redis-benchmark.c	/^    int requests_issued;$/;"	m	struct:config	file:	access:public
config::scan_mode	redis-cli.c	/^    int scan_mode;$/;"	m	struct:config	file:	access:public
config::shutdown	redis-cli.c	/^    int shutdown;$/;"	m	struct:config	file:	access:public
config::slave_mode	redis-cli.c	/^    int slave_mode;$/;"	m	struct:config	file:	access:public
config::start	redis-benchmark.c	/^    long long start;$/;"	m	struct:config	file:	access:public
config::stat_mode	redis-cli.c	/^    int stat_mode;$/;"	m	struct:config	file:	access:public
config::stdinarg	redis-cli.c	/^    int stdinarg; \/* get last arg from stdin. (-x option) *\/$/;"	m	struct:config	file:	access:public
config::tests	redis-benchmark.c	/^    char *tests;$/;"	m	struct:config	file:	access:public
config::title	redis-benchmark.c	/^    const char *title;$/;"	m	struct:config	file:	access:public
config::totlatency	redis-benchmark.c	/^    long long totlatency;$/;"	m	struct:config	file:	access:public
configCommand	config.c	/^void configCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
configCommand	redis.h	/^void configCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
configEpoch	cluster.h	/^    uint64_t configEpoch;   \/* The config epoch if it's a master, or the last$/;"	m	struct:__anon9	access:public
configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Config epoch of the specified instance. *\/$/;"	m	struct:__anon4	access:public
configEpoch	cluster.h	/^    uint64_t configEpoch; \/* Last configEpoch observed for this node *\/$/;"	m	struct:clusterNode	access:public
configGetCommand	config.c	/^void configGetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
configSetCommand	config.c	/^void configSetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
config_epoch	sentinel.c	/^    uint64_t config_epoch;  \/* Configuration epoch. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
config_get_bool_field	config.c	/^#define config_get_bool_field(/;"	d	file:
config_get_numerical_field	config.c	/^#define config_get_numerical_field(/;"	d	file:
config_get_string_field	config.c	/^#define config_get_string_field(/;"	d	file:
configfile	redis.h	/^    char *configfile;           \/* Absolute config file path, or NULL *\/$/;"	m	struct:redisServer	access:public
connect	redis-trib.rb	/^    def connect(o={})$/;"	f	class:ClusterNode
connectWithMaster	replication.c	/^int connectWithMaster(void) {$/;"	f	signature:(void)
consumeNewline	redis-check-aof.c	/^int consumeNewline(char *buf) {$/;"	f	signature:(char *buf)
contents	intset.h	/^    int8_t contents[];$/;"	m	struct:intset	access:public
context	redis-benchmark.c	/^    redisContext *context;$/;"	m	struct:_client	file:	access:public
context	redis-cli.c	/^static redisContext *context;$/;"	v	file:
context	sentinel.c	/^    redisAsyncContext *context;$/;"	m	struct:redisAeEvents	file:	access:public
convertToSds	redis-cli.c	/^static char **convertToSds(int count, char** args) {$/;"	f	file:	signature:(int count, char** args)
copyClientOutputBuffer	networking.c	/^void copyClientOutputBuffer(redisClient *dst, redisClient *src) {$/;"	f	signature:(redisClient *dst, redisClient *src)
copyClientOutputBuffer	redis.h	/^void copyClientOutputBuffer(redisClient *dst, redisClient *src);$/;"	p	signature:(redisClient *dst, redisClient *src)
count	cluster.h	/^    uint16_t count;     \/* Only used for some kind of messages. *\/$/;"	m	struct:__anon9	access:public
count	redis-cli.c	/^    long long count; \/* Number of samples in this interval. *\/$/;"	m	struct:distsamples	file:	access:public
count	redis.h	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	struct:multiState	access:public
count	sha1.h	/^    uint32_t count[2];$/;"	m	struct:__anon29	access:public
countKeysInSlot	db.c	/^unsigned int countKeysInSlot(unsigned int hashslot) {$/;"	f	signature:(unsigned int hashslot)
countKeysInSlot	redis.h	/^unsigned int countKeysInSlot(unsigned int hashslot);$/;"	p	signature:(unsigned int hashslot)
covered_slots	redis-trib.rb	/^    def covered_slots$/;"	f	class:RedisTrib
crc16	crc16.c	/^uint16_t crc16(const char *buf, int len) {$/;"	f	signature:(const char *buf, int len)
crc16	redis-trib.rb	/^    def RedisClusterCRC16.crc16(bytes)$/;"	F	class:RedisTrib.RedisClusterCRC16
crc16	redis.h	/^unsigned short crc16(const char *buf, int len);$/;"	p	signature:(const char *buf, int len)
crc16.c	crc16.c	1;"	F
crc16tab	crc16.c	/^static const uint16_t crc16tab[256]= {$/;"	v	file:
crc64	crc64.c	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l) {$/;"	f	signature:(uint64_t crc, const unsigned char *s, uint64_t l)
crc64	crc64.h	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);$/;"	p	signature:(uint64_t crc, const unsigned char *s, uint64_t l)
crc64	redis.h	/^uint64_t crc64(uint64_t crc, const unsigned char *s, uint64_t l);$/;"	p	signature:(uint64_t crc, const unsigned char *s, uint64_t l)
crc64.c	crc64.c	1;"	F
crc64.h	crc64.h	1;"	F
crc64_tab	crc64.c	/^static const uint64_t crc64_tab[256] = {$/;"	v	file:
createClient	networking.c	/^redisClient *createClient(int fd) {$/;"	f	signature:(int fd)
createClient	redis-benchmark.c	/^static client createClient(char *cmd, size_t len, client from) {$/;"	f	file:	signature:(char *cmd, size_t len, client from)
createClient	redis.h	/^redisClient *createClient(int fd);$/;"	p	signature:(int fd)
createClusterLink	cluster.c	/^clusterLink *createClusterLink(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
createClusterNode	cluster.c	/^clusterNode *createClusterNode(char *nodename, int flags) {$/;"	f	signature:(char *nodename, int flags)
createClusterNode	cluster.c	/^clusterNode *createClusterNode(char *nodename, int flags);$/;"	p	file:	signature:(char *nodename, int flags)
createDumpPayload	cluster.c	/^void createDumpPayload(rio *payload, robj *o) {$/;"	f	signature:(rio *payload, robj *o)
createEmbeddedStringObject	object.c	/^robj *createEmbeddedStringObject(char *ptr, size_t len) {$/;"	f	signature:(char *ptr, size_t len)
createEmbeddedStringObject	redis.h	/^robj *createEmbeddedStringObject(char *ptr, size_t len);$/;"	p	signature:(char *ptr, size_t len)
createFakeClient	aof.c	/^struct redisClient *createFakeClient(void) {$/;"	f	signature:(void)
createHLLObject	hyperloglog.c	/^robj *createHLLObject(void) {$/;"	f	signature:(void)
createHashObject	object.c	/^robj *createHashObject(void) {$/;"	f	signature:(void)
createHashObject	redis.h	/^robj *createHashObject(void);$/;"	p	signature:(void)
createIntList	ziplist.c	/^unsigned char *createIntList() {$/;"	f
createIntsetObject	object.c	/^robj *createIntsetObject(void) {$/;"	f	signature:(void)
createIntsetObject	redis.h	/^robj *createIntsetObject(void);$/;"	p	signature:(void)
createLatencyReport	latency.c	/^sds createLatencyReport(void) {$/;"	f	signature:(void)
createList	ziplist.c	/^unsigned char *createList() {$/;"	f
createListObject	object.c	/^robj *createListObject(void) {$/;"	f	signature:(void)
createListObject	redis.h	/^robj *createListObject(void);$/;"	p	signature:(void)
createMissingClients	redis-benchmark.c	/^static void createMissingClients(client c) {$/;"	f	file:	signature:(client c)
createMissingClients	redis-benchmark.c	/^static void createMissingClients(client c);$/;"	p	file:	signature:(client c)
createObject	object.c	/^robj *createObject(int type, void *ptr) {$/;"	f	signature:(int type, void *ptr)
createObject	redis.h	/^robj *createObject(int type, void *ptr);$/;"	p	signature:(int type, void *ptr)
createPidFile	redis.c	/^void createPidFile(void) {$/;"	f	signature:(void)
createRawStringObject	object.c	/^robj *createRawStringObject(char *ptr, size_t len) {$/;"	f	signature:(char *ptr, size_t len)
createRawStringObject	redis.h	/^robj *createRawStringObject(char *ptr, size_t len);$/;"	p	signature:(char *ptr, size_t len)
createReplicationBacklog	replication.c	/^void createReplicationBacklog(void) {$/;"	f	signature:(void)
createSentinelAddr	sentinel.c	/^sentinelAddr *createSentinelAddr(char *hostname, int port) {$/;"	f	signature:(char *hostname, int port)
createSentinelRedisInstance	sentinel.c	/^sentinelRedisInstance *createSentinelRedisInstance(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master) {$/;"	f	signature:(char *name, int flags, char *hostname, int port, int quorum, sentinelRedisInstance *master)
createSet	intset.c	/^intset *createSet(int bits, int size) {$/;"	f	signature:(int bits, int size)
createSetObject	object.c	/^robj *createSetObject(void) {$/;"	f	signature:(void)
createSetObject	redis.h	/^robj *createSetObject(void);$/;"	p	signature:(void)
createSharedObjects	redis.c	/^void createSharedObjects(void) {$/;"	f	signature:(void)
createSortOperation	sort.c	/^redisSortOperation *createSortOperation(int type, robj *pattern) {$/;"	f	signature:(int type, robj *pattern)
createSparklineSequence	sparkline.c	/^struct sequence *createSparklineSequence(void) {$/;"	f	signature:(void)
createSparklineSequence	sparkline.h	/^struct sequence *createSparklineSequence(void);$/;"	p	signature:(void)
createStringObject	object.c	/^robj *createStringObject(char *ptr, size_t len) {$/;"	f	signature:(char *ptr, size_t len)
createStringObject	redis.h	/^robj *createStringObject(char *ptr, size_t len);$/;"	p	signature:(char *ptr, size_t len)
createStringObjectFromLongDouble	object.c	/^robj *createStringObjectFromLongDouble(long double value, int humanfriendly) {$/;"	f	signature:(long double value, int humanfriendly)
createStringObjectFromLongDouble	redis.h	/^robj *createStringObjectFromLongDouble(long double value, int humanfriendly);$/;"	p	signature:(long double value, int humanfriendly)
createStringObjectFromLongLong	object.c	/^robj *createStringObjectFromLongLong(long long value) {$/;"	f	signature:(long long value)
createStringObjectFromLongLong	redis.h	/^robj *createStringObjectFromLongLong(long long value);$/;"	p	signature:(long long value)
createZiplistObject	object.c	/^robj *createZiplistObject(void) {$/;"	f	signature:(void)
createZiplistObject	redis.h	/^robj *createZiplistObject(void);$/;"	p	signature:(void)
createZsetObject	object.c	/^robj *createZsetObject(void) {$/;"	f	signature:(void)
createZsetObject	redis.h	/^robj *createZsetObject(void);$/;"	p	signature:(void)
createZsetZiplistObject	object.c	/^robj *createZsetZiplistObject(void) {$/;"	f	signature:(void)
createZsetZiplistObject	redis.h	/^robj *createZsetZiplistObject(void);$/;"	p	signature:(void)
create_cluster_cmd	redis-trib.rb	/^    def create_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
crlf	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
cronloops	redis.h	/^    int cronloops;              \/* Number of times the cron function run *\/$/;"	m	struct:redisServer	access:public
csv	redis-benchmark.c	/^    int csv;$/;"	m	struct:config	file:	access:public
ctime	cluster.h	/^    mstime_t ctime;             \/* Link creation time *\/$/;"	m	struct:clusterLink	access:public
ctime	cluster.h	/^    mstime_t ctime; \/* Node object creation time. *\/$/;"	m	struct:clusterNode	access:public
ctime	redis.h	/^    time_t ctime;           \/* Client creation time *\/$/;"	m	struct:redisClient	access:public
currentEpoch	cluster.h	/^    uint64_t currentEpoch;  \/* The epoch accordingly to the sending node. *\/$/;"	m	struct:__anon9	access:public
currentEpoch	cluster.h	/^    uint64_t currentEpoch;$/;"	m	struct:clusterState	access:public
current_client	redis.h	/^    redisClient *current_client; \/* Current client, only used on crash report *\/$/;"	m	struct:redisServer	access:public
current_epoch	sentinel.c	/^    uint64_t current_epoch;     \/* Current epoch. *\/$/;"	m	struct:sentinelState	file:	access:public
czero	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
d	dict.h	/^        double d;$/;"	m	union:dictEntry::__anon11	access:public
d	dict.h	/^    dict *d;$/;"	m	struct:dictIterator	access:public
d2string	util.c	/^int d2string(char *buf, size_t len, double value) {$/;"	f	signature:(char *buf, size_t len, double value)
d2string	util.h	/^int d2string(char *buf, size_t len, double value);$/;"	p	signature:(char *buf, size_t len, double value)
daemonize	redis.c	/^void daemonize(void) {$/;"	f	signature:(void)
daemonize	redis.h	/^    int daemonize;                  \/* True if running as a daemon *\/$/;"	m	struct:redisServer	access:public
data	cluster.h	/^    union clusterMsgData data;$/;"	m	struct:__anon9	typeref:union:__anon9::clusterMsgData	access:public
data	redis-check-dump.c	/^    void *data;$/;"	m	struct:__anon12	file:	access:public
databasesCron	redis.c	/^void databasesCron(void) {$/;"	f	signature:(void)
datasize	redis-benchmark.c	/^    int datasize;$/;"	m	struct:config	file:	access:public
db	multi.c	/^    redisDb *db;$/;"	m	struct:watchedKey	file:	access:public
db	redis.h	/^    redisDb *db;$/;"	m	struct:readyList	access:public
db	redis.h	/^    redisDb *db;$/;"	m	struct:redisClient	access:public
db	redis.h	/^    redisDb *db;$/;"	m	struct:redisServer	access:public
db.c	db.c	1;"	F
dbAdd	db.c	/^void dbAdd(redisDb *db, robj *key, robj *val) {$/;"	f	signature:(redisDb *db, robj *key, robj *val)
dbAdd	redis.h	/^void dbAdd(redisDb *db, robj *key, robj *val);$/;"	p	signature:(redisDb *db, robj *key, robj *val)
dbDelete	db.c	/^int dbDelete(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
dbDelete	redis.h	/^int dbDelete(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
dbDictType	redis.c	/^dictType dbDictType = {$/;"	v
dbDictType	redis.h	/^extern dictType dbDictType;$/;"	x
dbExists	db.c	/^int dbExists(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
dbExists	redis.h	/^int dbExists(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
dbOverwrite	db.c	/^void dbOverwrite(redisDb *db, robj *key, robj *val) {$/;"	f	signature:(redisDb *db, robj *key, robj *val)
dbOverwrite	redis.h	/^void dbOverwrite(redisDb *db, robj *key, robj *val);$/;"	p	signature:(redisDb *db, robj *key, robj *val)
dbRandomKey	db.c	/^robj *dbRandomKey(redisDb *db) {$/;"	f	signature:(redisDb *db)
dbRandomKey	redis.h	/^robj *dbRandomKey(redisDb *db);$/;"	p	signature:(redisDb *db)
dbUnshareStringValue	db.c	/^robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o) {$/;"	f	signature:(redisDb *db, robj *key, robj *o)
dbUnshareStringValue	redis.h	/^robj *dbUnshareStringValue(redisDb *db, robj *key, robj *o);$/;"	p	signature:(redisDb *db, robj *key, robj *o)
dbid	redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp	access:public
dbnum	redis-benchmark.c	/^    int dbnum;$/;"	m	struct:config	file:	access:public
dbnum	redis-cli.c	/^    int dbnum;$/;"	m	struct:config	file:	access:public
dbnum	redis.h	/^    int dbnum;                      \/* Total number of configured DBs *\/$/;"	m	struct:redisServer	access:public
dbnumstr	redis-benchmark.c	/^    sds dbnumstr;$/;"	m	struct:config	file:	access:public
dbsizeCommand	db.c	/^void dbsizeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
dbsizeCommand	redis.h	/^void dbsizeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
de	redis.h	/^    dictEntry *de;$/;"	m	struct:__anon21	access:public
de	t_zset.c	/^                dictEntry *de;$/;"	m	struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
debug	ziplist.c	/^#define debug(/;"	d	file:
debug.c	debug.c	1;"	F
debugCommand	debug.c	/^void debugCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
debugCommand	redis.h	/^void debugCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
decrCommand	redis.h	/^void decrCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
decrCommand	t_string.c	/^void decrCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
decrRefCount	object.c	/^void decrRefCount(robj *o) {$/;"	f	signature:(robj *o)
decrRefCount	redis.h	/^void decrRefCount(robj *o);$/;"	p	signature:(robj *o)
decrRefCountVoid	object.c	/^void decrRefCountVoid(void *o) {$/;"	f	signature:(void *o)
decrRefCountVoid	redis.h	/^void decrRefCountVoid(void *o);$/;"	p	signature:(void *o)
decrbyCommand	redis.h	/^void decrbyCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
decrbyCommand	t_string.c	/^void decrbyCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
del	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
delCommand	db.c	/^void delCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
delCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::redisCommand	access:public
delCommand	redis.h	/^void delCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
delKeysInSlot	db.c	/^unsigned int delKeysInSlot(unsigned int hashslot) {$/;"	f	signature:(unsigned int hashslot)
delKeysInSlot	redis.h	/^unsigned int delKeysInSlot(unsigned int hashslot);$/;"	p	signature:(unsigned int hashslot)
delnode_cluster_cmd	redis-trib.rb	/^    def delnode_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
di	redis.h	/^    dictIterator *di;$/;"	m	struct:__anon20	access:public
di	redis.h	/^    dictIterator *di;$/;"	m	struct:__anon21	access:public
di	t_zset.c	/^                dictIterator *di;$/;"	m	struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
dict	dict.h	/^typedef struct dict {$/;"	s
dict	dict.h	/^} dict;$/;"	t	typeref:struct:dict
dict	redis.h	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	struct:redisDb	access:public
dict	redis.h	/^    dict *dict;$/;"	m	struct:zset	access:public
dict	t_zset.c	/^                dict *dict;$/;"	m	struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
dict.c	dict.c	1;"	F
dict.h	dict.h	1;"	F
dict::ht	dict.h	/^    dictht ht[2];$/;"	m	struct:dict	access:public
dict::iterators	dict.h	/^    int iterators; \/* number of iterators currently running *\/$/;"	m	struct:dict	access:public
dict::privdata	dict.h	/^    void *privdata;$/;"	m	struct:dict	access:public
dict::rehashidx	dict.h	/^    long rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	struct:dict	access:public
dict::type	dict.h	/^    dictType *type;$/;"	m	struct:dict	access:public
dictAdd	dict.c	/^int dictAdd(dict *d, void *key, void *val)$/;"	f	signature:(dict *d, void *key, void *val)
dictAdd	dict.h	/^int dictAdd(dict *d, void *key, void *val);$/;"	p	signature:(dict *d, void *key, void *val)
dictAddRaw	dict.c	/^dictEntry *dictAddRaw(dict *d, void *key)$/;"	f	signature:(dict *d, void *key)
dictAddRaw	dict.h	/^dictEntry *dictAddRaw(dict *d, void *key);$/;"	p	signature:(dict *d, void *key)
dictCompareKeys	dict.h	/^#define dictCompareKeys(/;"	d
dictCreate	dict.c	/^dict *dictCreate(dictType *type,$/;"	f	signature:(dictType *type, void *privDataPtr)
dictCreate	dict.h	/^dict *dictCreate(dictType *type, void *privDataPtr);$/;"	p	signature:(dictType *type, void *privDataPtr)
dictDelete	dict.c	/^int dictDelete(dict *ht, const void *key) {$/;"	f	signature:(dict *ht, const void *key)
dictDelete	dict.h	/^int dictDelete(dict *d, const void *key);$/;"	p	signature:(dict *d, const void *key)
dictDeleteNoFree	dict.c	/^int dictDeleteNoFree(dict *ht, const void *key) {$/;"	f	signature:(dict *ht, const void *key)
dictDeleteNoFree	dict.h	/^int dictDeleteNoFree(dict *d, const void *key);$/;"	p	signature:(dict *d, const void *key)
dictDisableResize	dict.c	/^void dictDisableResize(void) {$/;"	f	signature:(void)
dictDisableResize	dict.h	/^void dictDisableResize(void);$/;"	p	signature:(void)
dictEmpty	dict.c	/^void dictEmpty(dict *d, void(callback)(void*)) {$/;"	f	signature:(dict *d, void(callback)(void*))
dictEmpty	dict.h	/^void dictEmpty(dict *d, void(callback)(void*));$/;"	p	signature:(dict *d, void(callback)(void*))
dictEnableResize	dict.c	/^void dictEnableResize(void) {$/;"	f	signature:(void)
dictEnableResize	dict.h	/^void dictEnableResize(void);$/;"	p	signature:(void)
dictEncObjHash	redis.c	/^unsigned int dictEncObjHash(const void *key) {$/;"	f	signature:(const void *key)
dictEncObjKeyCompare	redis.c	/^int dictEncObjKeyCompare(void *privdata, const void *key1,$/;"	f	signature:(void *privdata, const void *key1, const void *key2)
dictEntry	dict.h	/^typedef struct dictEntry {$/;"	s
dictEntry	dict.h	/^} dictEntry;$/;"	t	typeref:struct:dictEntry
dictEntry::__anon11::d	dict.h	/^        double d;$/;"	m	union:dictEntry::__anon11	access:public
dictEntry::__anon11::s64	dict.h	/^        int64_t s64;$/;"	m	union:dictEntry::__anon11	access:public
dictEntry::__anon11::u64	dict.h	/^        uint64_t u64;$/;"	m	union:dictEntry::__anon11	access:public
dictEntry::__anon11::val	dict.h	/^        void *val;$/;"	m	union:dictEntry::__anon11	access:public
dictEntry::key	dict.h	/^    void *key;$/;"	m	struct:dictEntry	access:public
dictEntry::next	dict.h	/^    struct dictEntry *next;$/;"	m	struct:dictEntry	typeref:struct:dictEntry::dictEntry	access:public
dictEntry::v	dict.h	/^    } v;$/;"	m	struct:dictEntry	typeref:union:dictEntry::__anon11	access:public
dictExpand	dict.c	/^int dictExpand(dict *d, unsigned long size)$/;"	f	signature:(dict *d, unsigned long size)
dictExpand	dict.h	/^int dictExpand(dict *d, unsigned long size);$/;"	p	signature:(dict *d, unsigned long size)
dictFetchValue	dict.c	/^void *dictFetchValue(dict *d, const void *key) {$/;"	f	signature:(dict *d, const void *key)
dictFetchValue	dict.h	/^void *dictFetchValue(dict *d, const void *key);$/;"	p	signature:(dict *d, const void *key)
dictFind	dict.c	/^dictEntry *dictFind(dict *d, const void *key)$/;"	f	signature:(dict *d, const void *key)
dictFind	dict.h	/^dictEntry * dictFind(dict *d, const void *key);$/;"	p	signature:(dict *d, const void *key)
dictFingerprint	dict.c	/^long long dictFingerprint(dict *d) {$/;"	f	signature:(dict *d)
dictFreeKey	dict.h	/^#define dictFreeKey(/;"	d
dictFreeVal	dict.h	/^#define dictFreeVal(/;"	d
dictGenCaseHashFunction	dict.c	/^unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len) {$/;"	f	signature:(const unsigned char *buf, int len)
dictGenCaseHashFunction	dict.h	/^unsigned int dictGenCaseHashFunction(const unsigned char *buf, int len);$/;"	p	signature:(const unsigned char *buf, int len)
dictGenHashFunction	dict.c	/^unsigned int dictGenHashFunction(const void *key, int len) {$/;"	f	signature:(const void *key, int len)
dictGenHashFunction	dict.h	/^unsigned int dictGenHashFunction(const void *key, int len);$/;"	p	signature:(const void *key, int len)
dictGenericDelete	dict.c	/^static int dictGenericDelete(dict *d, const void *key, int nofree)$/;"	f	file:	signature:(dict *d, const void *key, int nofree)
dictGetDoubleVal	dict.h	/^#define dictGetDoubleVal(/;"	d
dictGetHashFunctionSeed	dict.c	/^uint32_t dictGetHashFunctionSeed(void) {$/;"	f	signature:(void)
dictGetHashFunctionSeed	dict.h	/^unsigned int dictGetHashFunctionSeed(void);$/;"	p	signature:(void)
dictGetIterator	dict.c	/^dictIterator *dictGetIterator(dict *d)$/;"	f	signature:(dict *d)
dictGetIterator	dict.h	/^dictIterator *dictGetIterator(dict *d);$/;"	p	signature:(dict *d)
dictGetKey	dict.h	/^#define dictGetKey(/;"	d
dictGetRandomKey	dict.c	/^dictEntry *dictGetRandomKey(dict *d)$/;"	f	signature:(dict *d)
dictGetRandomKey	dict.h	/^dictEntry *dictGetRandomKey(dict *d);$/;"	p	signature:(dict *d)
dictGetSafeIterator	dict.c	/^dictIterator *dictGetSafeIterator(dict *d) {$/;"	f	signature:(dict *d)
dictGetSafeIterator	dict.h	/^dictIterator *dictGetSafeIterator(dict *d);$/;"	p	signature:(dict *d)
dictGetSignedIntegerVal	dict.h	/^#define dictGetSignedIntegerVal(/;"	d
dictGetSomeKeys	dict.c	/^unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count) {$/;"	f	signature:(dict *d, dictEntry **des, unsigned int count)
dictGetSomeKeys	dict.h	/^unsigned int dictGetSomeKeys(dict *d, dictEntry **des, unsigned int count);$/;"	p	signature:(dict *d, dictEntry **des, unsigned int count)
dictGetUnsignedIntegerVal	dict.h	/^#define dictGetUnsignedIntegerVal(/;"	d
dictGetVal	dict.h	/^#define dictGetVal(/;"	d
dictHashKey	dict.h	/^#define dictHashKey(/;"	d
dictInstancesValDestructor	sentinel.c	/^void dictInstancesValDestructor (void *privdata, void *obj) {$/;"	f	signature:(void *privdata, void *obj)
dictIntHashFunction	dict.c	/^unsigned int dictIntHashFunction(unsigned int key)$/;"	f	signature:(unsigned int key)
dictIsRehashing	dict.h	/^#define dictIsRehashing(/;"	d
dictIterator	dict.h	/^typedef struct dictIterator {$/;"	s
dictIterator	dict.h	/^} dictIterator;$/;"	t	typeref:struct:dictIterator
dictIterator::d	dict.h	/^    dict *d;$/;"	m	struct:dictIterator	access:public
dictIterator::entry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator	access:public
dictIterator::fingerprint	dict.h	/^    long long fingerprint;$/;"	m	struct:dictIterator	access:public
dictIterator::index	dict.h	/^    long index;$/;"	m	struct:dictIterator	access:public
dictIterator::nextEntry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator	access:public
dictIterator::safe	dict.h	/^    int table, safe;$/;"	m	struct:dictIterator	access:public
dictIterator::table	dict.h	/^    int table, safe;$/;"	m	struct:dictIterator	access:public
dictListDestructor	config.c	/^void dictListDestructor(void *privdata, void *val);$/;"	p	file:	signature:(void *privdata, void *val)
dictListDestructor	redis.c	/^void dictListDestructor(void *privdata, void *val)$/;"	f	signature:(void *privdata, void *val)
dictNext	dict.c	/^dictEntry *dictNext(dictIterator *iter)$/;"	f	signature:(dictIterator *iter)
dictNext	dict.h	/^dictEntry *dictNext(dictIterator *iter);$/;"	p	signature:(dictIterator *iter)
dictObjHash	redis.c	/^unsigned int dictObjHash(const void *key) {$/;"	f	signature:(const void *key)
dictObjKeyCompare	redis.c	/^int dictObjKeyCompare(void *privdata, const void *key1,$/;"	f	signature:(void *privdata, const void *key1, const void *key2)
dictPrintStats	dict.h	/^void dictPrintStats(dict *d);$/;"	p	signature:(dict *d)
dictRedisObjectDestructor	redis.c	/^void dictRedisObjectDestructor(void *privdata, void *val)$/;"	f	signature:(void *privdata, void *val)
dictRehash	dict.c	/^int dictRehash(dict *d, int n) {$/;"	f	signature:(dict *d, int n)
dictRehash	dict.h	/^int dictRehash(dict *d, int n);$/;"	p	signature:(dict *d, int n)
dictRehashMilliseconds	dict.c	/^int dictRehashMilliseconds(dict *d, int ms) {$/;"	f	signature:(dict *d, int ms)
dictRehashMilliseconds	dict.h	/^int dictRehashMilliseconds(dict *d, int ms);$/;"	p	signature:(dict *d, int ms)
dictRelease	dict.c	/^void dictRelease(dict *d)$/;"	f	signature:(dict *d)
dictRelease	dict.h	/^void dictRelease(dict *d);$/;"	p	signature:(dict *d)
dictReleaseIterator	dict.c	/^void dictReleaseIterator(dictIterator *iter)$/;"	f	signature:(dictIterator *iter)
dictReleaseIterator	dict.h	/^void dictReleaseIterator(dictIterator *iter);$/;"	p	signature:(dictIterator *iter)
dictReplace	dict.c	/^int dictReplace(dict *d, void *key, void *val)$/;"	f	signature:(dict *d, void *key, void *val)
dictReplace	dict.h	/^int dictReplace(dict *d, void *key, void *val);$/;"	p	signature:(dict *d, void *key, void *val)
dictReplaceRaw	dict.c	/^dictEntry *dictReplaceRaw(dict *d, void *key) {$/;"	f	signature:(dict *d, void *key)
dictReplaceRaw	dict.h	/^dictEntry *dictReplaceRaw(dict *d, void *key);$/;"	p	signature:(dict *d, void *key)
dictResize	dict.c	/^int dictResize(dict *d)$/;"	f	signature:(dict *d)
dictResize	dict.h	/^int dictResize(dict *d);$/;"	p	signature:(dict *d)
dictScan	dict.c	/^unsigned long dictScan(dict *d,$/;"	f	signature:(dict *d, unsigned long v, dictScanFunction *fn, void *privdata)
dictScan	dict.h	/^unsigned long dictScan(dict *d, unsigned long v, dictScanFunction *fn, void *privdata);$/;"	p	signature:(dict *d, unsigned long v, dictScanFunction *fn, void *privdata)
dictScanFunction	dict.h	/^typedef void (dictScanFunction)(void *privdata, const dictEntry *de);$/;"	t
dictSdsCaseHash	config.c	/^unsigned int dictSdsCaseHash(const void *key);$/;"	p	file:	signature:(const void *key)
dictSdsCaseHash	redis.c	/^unsigned int dictSdsCaseHash(const void *key) {$/;"	f	signature:(const void *key)
dictSdsDestructor	config.c	/^void dictSdsDestructor(void *privdata, void *val);$/;"	p	file:	signature:(void *privdata, void *val)
dictSdsDestructor	redis.c	/^void dictSdsDestructor(void *privdata, void *val)$/;"	f	signature:(void *privdata, void *val)
dictSdsHash	redis.c	/^unsigned int dictSdsHash(const void *key) {$/;"	f	signature:(const void *key)
dictSdsHash	sentinel.c	/^unsigned int dictSdsHash(const void *key);$/;"	p	file:	signature:(const void *key)
dictSdsKeyCaseCompare	config.c	/^int dictSdsKeyCaseCompare(void *privdata, const void *key1, const void *key2);$/;"	p	file:	signature:(void *privdata, const void *key1, const void *key2)
dictSdsKeyCaseCompare	redis.c	/^int dictSdsKeyCaseCompare(void *privdata, const void *key1,$/;"	f	signature:(void *privdata, const void *key1, const void *key2)
dictSdsKeyCompare	redis.c	/^int dictSdsKeyCompare(void *privdata, const void *key1,$/;"	f	signature:(void *privdata, const void *key1, const void *key2)
dictSdsKeyCompare	sentinel.c	/^int dictSdsKeyCompare(void *privdata, const void *key1, const void *key2);$/;"	p	file:	signature:(void *privdata, const void *key1, const void *key2)
dictSetDoubleVal	dict.h	/^#define dictSetDoubleVal(/;"	d
dictSetHashFunctionSeed	dict.c	/^void dictSetHashFunctionSeed(uint32_t seed) {$/;"	f	signature:(uint32_t seed)
dictSetHashFunctionSeed	dict.h	/^void dictSetHashFunctionSeed(unsigned int initval);$/;"	p	signature:(unsigned int initval)
dictSetKey	dict.h	/^#define dictSetKey(/;"	d
dictSetSignedIntegerVal	dict.h	/^#define dictSetSignedIntegerVal(/;"	d
dictSetUnsignedIntegerVal	dict.h	/^#define dictSetUnsignedIntegerVal(/;"	d
dictSetVal	dict.h	/^#define dictSetVal(/;"	d
dictSize	dict.h	/^#define dictSize(/;"	d
dictSlots	dict.h	/^#define dictSlots(/;"	d
dictStringHash	latency.c	/^unsigned int dictStringHash(const void *key) {$/;"	f	signature:(const void *key)
dictStringKeyCompare	latency.c	/^int dictStringKeyCompare(void *privdata, const void *key1, const void *key2) {$/;"	f	signature:(void *privdata, const void *key1, const void *key2)
dictType	dict.h	/^typedef struct dictType {$/;"	s
dictType	dict.h	/^} dictType;$/;"	t	typeref:struct:dictType
dictType::hashFunction	dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	struct:dictType	access:public
dictType::keyCompare	dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	struct:dictType	access:public
dictType::keyDestructor	dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	struct:dictType	access:public
dictType::keyDup	dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	struct:dictType	access:public
dictType::valDestructor	dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	struct:dictType	access:public
dictType::valDup	dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	struct:dictType	access:public
dictTypeHeapStringCopyKey	dict.h	/^extern dictType dictTypeHeapStringCopyKey;$/;"	x
dictTypeHeapStringCopyKeyValue	dict.h	/^extern dictType dictTypeHeapStringCopyKeyValue;$/;"	x
dictTypeHeapStrings	dict.h	/^extern dictType dictTypeHeapStrings;$/;"	x
dictVanillaFree	latency.c	/^void dictVanillaFree(void *privdata, void *val);$/;"	p	file:	signature:(void *privdata, void *val)
dictVanillaFree	redis.c	/^void dictVanillaFree(void *privdata, void *val)$/;"	f	signature:(void *privdata, void *val)
dict_can_resize	dict.c	/^static int dict_can_resize = 1;$/;"	v	file:
dict_force_resize_ratio	dict.c	/^static unsigned int dict_force_resize_ratio = 5;$/;"	v	file:
dict_hash_function_seed	dict.c	/^static uint32_t dict_hash_function_seed = 5381;$/;"	v	file:
dictht	dict.h	/^typedef struct dictht {$/;"	s
dictht	dict.h	/^} dictht;$/;"	t	typeref:struct:dictht
dictht::size	dict.h	/^    unsigned long size;$/;"	m	struct:dictht	access:public
dictht::sizemask	dict.h	/^    unsigned long sizemask;$/;"	m	struct:dictht	access:public
dictht::table	dict.h	/^    dictEntry **table;$/;"	m	struct:dictht	access:public
dictht::used	dict.h	/^    unsigned long used;$/;"	m	struct:dictht	access:public
dictid	redis.h	/^    int dictid;$/;"	m	struct:redisClient	access:public
digits10	util.c	/^uint32_t digits10(uint64_t v) {$/;"	f	signature:(uint64_t v)
direction	adlist.h	/^    int direction;$/;"	m	struct:listIter	access:public
direction	redis.h	/^    unsigned char direction; \/* Iteration direction *\/$/;"	m	struct:__anon18	access:public
dirty	redis.h	/^    long long dirty;                \/* Changes to DB from the last save *\/$/;"	m	struct:redisServer	access:public
dirty_before_bgsave	redis.h	/^    long long dirty_before_bgsave;  \/* Used to restore dirty on failed BGSAVE *\/$/;"	m	struct:redisServer	access:public
disableWatchdog	debug.c	/^void disableWatchdog(void) {$/;"	f	signature:(void)
disableWatchdog	redis.h	/^void disableWatchdog(void);$/;"	p	signature:(void)
discardCommand	multi.c	/^void discardCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
discardCommand	redis.h	/^void discardCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
discardTransaction	multi.c	/^void discardTransaction(redisClient *c) {$/;"	f	signature:(redisClient *c)
discardTransaction	redis.h	/^void discardTransaction(redisClient *c);$/;"	p	signature:(redisClient *c)
disconnectAllBlockedClients	blocked.c	/^void disconnectAllBlockedClients(void) {$/;"	f	signature:(void)
disconnectAllBlockedClients	redis.h	/^void disconnectAllBlockedClients(void);$/;"	p	signature:(void)
disconnectSlaves	networking.c	/^void disconnectSlaves(void) {$/;"	f	signature:(void)
disconnectSlaves	redis.h	/^void disconnectSlaves(void);$/;"	p	signature:(void)
distsamples	redis-cli.c	/^struct distsamples {$/;"	s	file:
distsamples::character	redis-cli.c	/^    int character;   \/* Associated character in visualization. *\/$/;"	m	struct:distsamples	file:	access:public
distsamples::count	redis-cli.c	/^    long long count; \/* Number of samples in this interval. *\/$/;"	m	struct:distsamples	file:	access:public
distsamples::max	redis-cli.c	/^    long long max;   \/* Max latency to fit into this interval (usec). *\/$/;"	m	struct:distsamples	file:	access:public
down_after_period	sentinel.c	/^    mstime_t down_after_period; \/* Consider it down after that period. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
dumpCommand	cluster.c	/^void dumpCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
dumpCommand	redis.h	/^void dumpCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
dup	adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:list	access:public
dupClientReplyValue	networking.c	/^void *dupClientReplyValue(void *o) {$/;"	f	signature:(void *o)
dupClientReplyValue	redis.h	/^void *dupClientReplyValue(void *o);$/;"	p	signature:(void *o)
dupLastObjectIfNeeded	networking.c	/^robj *dupLastObjectIfNeeded(list *reply) {$/;"	f	signature:(list *reply)
dupSentinelAddr	sentinel.c	/^sentinelAddr *dupSentinelAddr(sentinelAddr *src) {$/;"	f	signature:(sentinelAddr *src)
dupStringObject	object.c	/^robj *dupStringObject(robj *o) {$/;"	f	signature:(robj *o)
dupStringObject	redis.h	/^robj *dupStringObject(robj *o);$/;"	p	signature:(robj *o)
duration	slowlog.h	/^    long long duration; \/* Time spent by the query, in nanoseconds. *\/$/;"	m	struct:slowlogEntry	access:public
echoCommand	redis.c	/^void echoCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
echoCommand	redis.h	/^void echoCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
el	redis-benchmark.c	/^    aeEventLoop *el;$/;"	m	struct:config	file:	access:public
el	redis.h	/^    aeEventLoop *el;$/;"	m	struct:redisServer	access:public
ele	t_zset.c	/^    robj *ele;$/;"	m	struct:__anon36	file:	access:public
elen	t_zset.c	/^    unsigned int elen;$/;"	m	struct:__anon36	file:	access:public
ell	t_zset.c	/^    long long ell;$/;"	m	struct:__anon36	file:	access:public
emptyDb	db.c	/^long long emptyDb(void(callback)(void*)) {$/;"	f	signature:(void(callback)(void*))
emptyDb	redis.h	/^long long emptyDb(void(callback)(void*));$/;"	p	signature:(void(callback)(void*))
emptybulk	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
emptymultibulk	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
emptyscan	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
enableWatchdog	debug.c	/^void enableWatchdog(int period) {$/;"	f	signature:(int period)
enableWatchdog	redis.h	/^void enableWatchdog(int period);$/;"	p	signature:(int period)
encoding	hyperloglog.c	/^    uint8_t encoding;   \/* HLL_DENSE or HLL_SPARSE. *\/$/;"	m	struct:hllhdr	file:	access:public
encoding	intset.h	/^    uint32_t encoding;$/;"	m	struct:intset	access:public
encoding	redis.h	/^    int encoding;$/;"	m	struct:__anon20	access:public
encoding	redis.h	/^    int encoding;$/;"	m	struct:__anon21	access:public
encoding	redis.h	/^    unsigned char encoding;$/;"	m	struct:__anon18	access:public
encoding	redis.h	/^    unsigned encoding:4;$/;"	m	struct:redisObject	access:public
encoding	t_zset.c	/^    int encoding;$/;"	m	struct:__anon30	file:	access:public
encoding	ziplist.c	/^    unsigned char encoding;$/;"	m	struct:zlentry	file:	access:public
end	setproctitle.c	/^	char *base, *end;$/;"	m	struct:__anon28	file:	access:public
endianconv.c	endianconv.c	1;"	F
endianconv.h	endianconv.h	1;"	F
entry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator	access:public
entry	redis-check-dump.c	/^} entry;$/;"	t	typeref:struct:__anon14	file:
environ	sentinel.c	/^extern char **environ;$/;"	x
environ	setproctitle.c	/^extern char **environ;$/;"	x
epfd	ae_epoll.c	/^    int epfd;$/;"	m	struct:aeApiState	file:	access:public
epos	redis-check-aof.c	/^static off_t epos;$/;"	v	file:
eptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
equalStringObjects	object.c	/^int equalStringObjects(robj *a, robj *b) {$/;"	f	signature:(robj *a, robj *b)
equalStringObjects	redis.h	/^int equalStringObjects(robj *a, robj *b);$/;"	p	signature:(robj *a, robj *b)
err	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
error	intset.c	/^void error(char *err) {$/;"	f	signature:(char *err)
error	redis-check-aof.c	/^static char error[1024];$/;"	v	file:
error	redis-check-dump.c	/^    char error[16][1024];$/;"	m	struct:__anon13	file:	access:public
error	setproctitle.c	/^	int error;$/;"	m	struct:__anon28	file:	access:public
errors	redis-check-dump.c	/^static errors_t errors;$/;"	v	file:
errors_t	redis-check-dump.c	/^} errors_t;$/;"	t	typeref:struct:__anon13	file:
estimateObjectIdleTime	object.c	/^unsigned long long estimateObjectIdleTime(robj *o) {$/;"	f	signature:(robj *o)
estimateObjectIdleTime	redis.h	/^unsigned long long estimateObjectIdleTime(robj *o);$/;"	p	signature:(robj *o)
estr	t_zset.c	/^    unsigned char *estr;$/;"	m	struct:__anon36	file:	access:public
eval	redis-cli.c	/^    char *eval;$/;"	m	struct:config	file:	access:public
evalCommand	redis.h	/^void evalCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
evalCommand	scripting.c	/^void evalCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
evalGenericCommand	scripting.c	/^void evalGenericCommand(redisClient *c, int evalsha) {$/;"	f	signature:(redisClient *c, int evalsha)
evalGetKeys	db.c	/^int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
evalGetKeys	redis.h	/^int *evalGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
evalMode	redis-cli.c	/^static int evalMode(int argc, char **argv) {$/;"	f	file:	signature:(int argc, char **argv)
evalShaCommand	redis.h	/^void evalShaCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
evalShaCommand	scripting.c	/^void evalShaCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
events	ae.h	/^    aeFileEvent *events; \/* Registered events *\/$/;"	m	struct:aeEventLoop	access:public
events	ae_epoll.c	/^    struct epoll_event *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::epoll_event	file:	access:public
events	ae_kqueue.c	/^    struct kevent *events;$/;"	m	struct:aeApiState	typeref:struct:aeApiState::kevent	file:	access:public
evictionPoolAlloc	redis.c	/^struct evictionPoolEntry *evictionPoolAlloc(void) {$/;"	f	signature:(void)
evictionPoolAlloc	redis.c	/^struct evictionPoolEntry *evictionPoolAlloc(void);$/;"	p	file:	signature:(void)
evictionPoolEntry	redis.h	/^struct evictionPoolEntry {$/;"	s
evictionPoolEntry::idle	redis.h	/^    unsigned long long idle;    \/* Object idle time. *\/$/;"	m	struct:evictionPoolEntry	access:public
evictionPoolEntry::key	redis.h	/^    sds key;                    \/* Key name. *\/$/;"	m	struct:evictionPoolEntry	access:public
evictionPoolPopulate	redis.c	/^void evictionPoolPopulate(dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {$/;"	f	signature:(dict *sampledict, dict *keydict, struct evictionPoolEntry *pool)
eviction_pool	redis.h	/^    struct evictionPoolEntry *eviction_pool;    \/* Eviction pool of keys *\/$/;"	m	struct:redisDb	typeref:struct:redisDb::evictionPoolEntry	access:public
evport_debug	ae_evport.c	/^static int evport_debug = 0;$/;"	v	file:
execCommand	multi.c	/^void execCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
execCommand	redis.h	/^void execCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
execCommandPropagateMulti	multi.c	/^void execCommandPropagateMulti(redisClient *c) {$/;"	f	signature:(redisClient *c)
execaborterr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
existsCommand	db.c	/^void existsCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
existsCommand	redis.h	/^void existsCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
exitFromChild	redis.c	/^void exitFromChild(int retcode) {$/;"	f	signature:(int retcode)
exitFromChild	redis.h	/^void exitFromChild(int retcode);$/;"	p	signature:(int retcode)
expect	lzf_c.c	/^# define expect(/;"	d	file:
expect_false	lzf_c.c	/^#define expect_false(/;"	d	file:
expect_true	lzf_c.c	/^#define expect_true(/;"	d	file:
expireCommand	db.c	/^void expireCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
expireCommand	redis.h	/^void expireCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
expireGenericCommand	db.c	/^void expireGenericCommand(redisClient *c, long long basetime, int unit) {$/;"	f	signature:(redisClient *c, long long basetime, int unit)
expireIfNeeded	db.c	/^int expireIfNeeded(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
expireIfNeeded	redis.h	/^int expireIfNeeded(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
expireatCommand	db.c	/^void expireatCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
expireatCommand	redis.h	/^void expireatCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
expires	redis.h	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	struct:redisDb	access:public
fail	cluster.h	/^    } fail;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon6	access:public
fail_reports	cluster.h	/^    list *fail_reports;         \/* List of nodes signaling this as failing *\/$/;"	m	struct:clusterNode	access:public
fail_time	cluster.h	/^    mstime_t fail_time;      \/* Unix time when FAIL flag was set *\/$/;"	m	struct:clusterNode	access:public
failover_auth_count	cluster.h	/^    int failover_auth_count;    \/* Number of votes received so far. *\/$/;"	m	struct:clusterState	access:public
failover_auth_epoch	cluster.h	/^    uint64_t failover_auth_epoch; \/* Epoch of the current election. *\/$/;"	m	struct:clusterState	access:public
failover_auth_rank	cluster.h	/^    int failover_auth_rank;     \/* This slave rank for current auth request. *\/$/;"	m	struct:clusterState	access:public
failover_auth_sent	cluster.h	/^    int failover_auth_sent;     \/* True if we already asked for votes. *\/$/;"	m	struct:clusterState	access:public
failover_auth_time	cluster.h	/^    mstime_t failover_auth_time; \/* Time of previous or next election. *\/$/;"	m	struct:clusterState	access:public
failover_delay_logged	sentinel.c	/^    mstime_t failover_delay_logged; \/* For what failover_start_time value we$/;"	m	struct:sentinelRedisInstance	file:	access:public
failover_epoch	sentinel.c	/^    uint64_t failover_epoch; \/* Epoch of the currently started failover. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
failover_start_time	sentinel.c	/^    mstime_t failover_start_time;   \/* Last failover attempt start time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
failover_state	sentinel.c	/^    int failover_state; \/* See SENTINEL_FAILOVER_STATE_* defines. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
failover_state_change_time	sentinel.c	/^    mstime_t failover_state_change_time;$/;"	m	struct:sentinelRedisInstance	file:	access:public
failover_timeout	sentinel.c	/^    mstime_t failover_timeout;      \/* Max time to refresh failover state. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
fd	ae.h	/^    int fd;$/;"	m	struct:aeFiredEvent	access:public
fd	cluster.c	/^    int fd;$/;"	m	struct:migrateCachedSocket	file:	access:public
fd	cluster.h	/^    int fd;                     \/* TCP socket file descriptor *\/$/;"	m	struct:clusterLink	access:public
fd	redis.h	/^    int fd;$/;"	m	struct:redisClient	access:public
fd	sentinel.c	/^    int fd;$/;"	m	struct:redisAeEvents	file:	access:public
fds	rio.h	/^            int *fds;       \/* File descriptors. *\/$/;"	m	struct:_rio::__anon24::__anon27	access:public
fdset	rio.h	/^        } fdset;$/;"	m	union:_rio::__anon24	typeref:struct:_rio::__anon24::__anon27	access:public
feedAppendOnlyFile	aof.c	/^void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc) {$/;"	f	signature:(struct redisCommand *cmd, int dictid, robj **argv, int argc)
feedAppendOnlyFile	redis.h	/^void feedAppendOnlyFile(struct redisCommand *cmd, int dictid, robj **argv, int argc);$/;"	p	signature:(struct redisCommand *cmd, int dictid, robj **argv, int argc)
feedReplicationBacklog	replication.c	/^void feedReplicationBacklog(void *ptr, size_t len) {$/;"	f	signature:(void *ptr, size_t len)
feedReplicationBacklogWithObject	replication.c	/^void feedReplicationBacklogWithObject(robj *o) {$/;"	f	signature:(robj *o)
file	rio.h	/^        } file;$/;"	m	union:_rio::__anon24	typeref:struct:_rio::__anon24::__anon26	access:public
finalizerProc	ae.h	/^    aeEventFinalizerProc *finalizerProc;$/;"	m	struct:aeTimeEvent	access:public
findBigKeys	redis-cli.c	/^static void findBigKeys(void) {$/;"	f	file:	signature:(void)
fingerprint	dict.h	/^    long long fingerprint;$/;"	m	struct:dictIterator	access:public
fired	ae.h	/^    aeFiredEvent *fired; \/* Fired events *\/$/;"	m	struct:aeEventLoop	access:public
firstkey	redis.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	struct:redisCommand	access:public
fix_cluster_cmd	redis-trib.rb	/^    def fix_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
fix_open_slot	redis-trib.rb	/^    def fix_open_slot(slot)$/;"	f	class:RedisTrib
fix_slots_coverage	redis-trib.rb	/^    def fix_slots_coverage$/;"	f	class:RedisTrib
flag	cluster.c	/^    uint16_t flag;$/;"	m	struct:redisNodeFlags	file:	access:public
flagTransaction	multi.c	/^void flagTransaction(redisClient *c) {$/;"	f	signature:(redisClient *c)
flagTransaction	redis.h	/^void flagTransaction(redisClient *c);$/;"	p	signature:(redisClient *c)
flags	cluster.h	/^    int flags;      \/* REDIS_NODE_... *\/$/;"	m	struct:clusterNode	access:public
flags	cluster.h	/^    uint16_t flags;             \/* node->flags copy *\/$/;"	m	struct:__anon1	access:public
flags	cluster.h	/^    uint16_t flags;     \/* Sender node flags *\/$/;"	m	struct:__anon9	access:public
flags	redis.h	/^    int flags;              \/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... *\/$/;"	m	struct:redisClient	access:public
flags	redis.h	/^    int flags;    \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	struct:redisCommand	access:public
flags	sentinel.c	/^    int flags;              \/* Script job flags: SENTINEL_SCRIPT_* *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
flags	sentinel.c	/^    int flags;      \/* See SRI_... defines *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
flags	t_zset.c	/^    int flags;$/;"	m	struct:__anon36	file:	access:public
flush	rio.h	/^    int (*flush)(struct _rio *);$/;"	m	struct:_rio	access:public
flushAppendOnlyFile	aof.c	/^void flushAppendOnlyFile(int force) {$/;"	f	signature:(int force)
flushAppendOnlyFile	redis.h	/^void flushAppendOnlyFile(int force);$/;"	p	signature:(int force)
flushSlavesOutputBuffers	networking.c	/^void flushSlavesOutputBuffers(void) {$/;"	f	signature:(void)
flushSlavesOutputBuffers	redis.h	/^void flushSlavesOutputBuffers(void);$/;"	p	signature:(void)
flush_node_config	redis-trib.rb	/^    def flush_node_config$/;"	f	class:ClusterNode
flush_nodes_config	redis-trib.rb	/^    def flush_nodes_config$/;"	f	class:RedisTrib.alloc_slots
flushallCommand	db.c	/^void flushallCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
flushallCommand	redis.h	/^void flushallCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
flushdbCommand	db.c	/^void flushdbCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
flushdbCommand	redis.h	/^void flushdbCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
fmacros.h	fmacros.h	1;"	F
forceCommandPropagation	redis.c	/^void forceCommandPropagation(redisClient *c, int flags) {$/;"	f	signature:(redisClient *c, int flags)
forceCommandPropagation	redis.h	/^void forceCommandPropagation(redisClient *c, int flags);$/;"	p	signature:(redisClient *c, int flags)
force_cancel_loop	redis-cli.c	/^static volatile sig_atomic_t force_cancel_loop = 0;$/;"	v	file:
formatPeerId	networking.c	/^void formatPeerId(char *peerid, size_t peerid_len, char *ip, int port) {$/;"	f	signature:(char *peerid, size_t peerid_len, char *ip, int port)
formatPeerId	redis.h	/^void formatPeerId(char *peerid, size_t peerid_len, char *ip, int port);$/;"	p	signature:(char *peerid, size_t peerid_len, char *ip, int port)
forward	redis.h	/^        struct zskiplistNode *forward;$/;"	m	struct:zskiplistNode::zskiplistLevel	typeref:struct:zskiplistNode::zskiplistLevel::zskiplistNode	access:public
fp	rio.h	/^            FILE *fp;$/;"	m	struct:_rio::__anon24::__anon26	access:public
fptr	redis.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon21	access:public
free	adlist.h	/^    void (*free)(void *ptr);$/;"	m	struct:list	access:public
free	aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:	access:public
free	redis.h	/^void free(void *ptr) __attribute__ ((deprecated));$/;"	p	signature:(void *ptr)
free	sds.h	/^    unsigned int free;$/;"	m	struct:sdshdr	access:public
free	zmalloc.c	/^#define free(/;"	d	file:
freeAllClients	redis-benchmark.c	/^static void freeAllClients(void) {$/;"	f	file:	signature:(void)
freeClient	networking.c	/^void freeClient(redisClient *c) {$/;"	f	signature:(redisClient *c)
freeClient	redis-benchmark.c	/^static void freeClient(client c) {$/;"	f	file:	signature:(client c)
freeClient	redis.h	/^void freeClient(redisClient *c);$/;"	p	signature:(redisClient *c)
freeClientArgv	networking.c	/^static void freeClientArgv(redisClient *c) {$/;"	f	file:	signature:(redisClient *c)
freeClientAsync	networking.c	/^void freeClientAsync(redisClient *c) {$/;"	f	signature:(redisClient *c)
freeClientAsync	redis.h	/^void freeClientAsync(redisClient *c);$/;"	p	signature:(redisClient *c)
freeClientMultiState	multi.c	/^void freeClientMultiState(redisClient *c) {$/;"	f	signature:(redisClient *c)
freeClientMultiState	redis.h	/^void freeClientMultiState(redisClient *c);$/;"	p	signature:(redisClient *c)
freeClientsInAsyncFreeQueue	networking.c	/^void freeClientsInAsyncFreeQueue(void) {$/;"	f	signature:(void)
freeClientsInAsyncFreeQueue	redis.h	/^void freeClientsInAsyncFreeQueue(void);$/;"	p	signature:(void)
freeClusterLink	cluster.c	/^void freeClusterLink(clusterLink *link) {$/;"	f	signature:(clusterLink *link)
freeClusterNode	cluster.c	/^void freeClusterNode(clusterNode *n) {$/;"	f	signature:(clusterNode *n)
freeFakeClient	aof.c	/^void freeFakeClient(struct redisClient *c) {$/;"	f	signature:(struct redisClient *c)
freeFakeClientArgv	aof.c	/^void freeFakeClientArgv(struct redisClient *c) {$/;"	f	signature:(struct redisClient *c)
freeHashObject	object.c	/^void freeHashObject(robj *o) {$/;"	f	signature:(robj *o)
freeHashObject	redis.h	/^void freeHashObject(robj *o);$/;"	p	signature:(robj *o)
freeListObject	object.c	/^void freeListObject(robj *o) {$/;"	f	signature:(robj *o)
freeListObject	redis.h	/^void freeListObject(robj *o);$/;"	p	signature:(robj *o)
freeMemoryIfNeeded	redis.c	/^int freeMemoryIfNeeded(void) {$/;"	f	signature:(void)
freeMemoryIfNeeded	redis.h	/^int freeMemoryIfNeeded(void);$/;"	p	signature:(void)
freePubsubPattern	pubsub.c	/^void freePubsubPattern(void *p) {$/;"	f	signature:(void *p)
freePubsubPattern	redis.h	/^void freePubsubPattern(void *p);$/;"	p	signature:(void *p)
freeReplicationBacklog	replication.c	/^void freeReplicationBacklog(void) {$/;"	f	signature:(void)
freeSetObject	object.c	/^void freeSetObject(robj *o) {$/;"	f	signature:(robj *o)
freeSetObject	redis.h	/^void freeSetObject(robj *o);$/;"	p	signature:(robj *o)
freeSparklineSequence	sparkline.c	/^void freeSparklineSequence(struct sequence *seq) {$/;"	f	signature:(struct sequence *seq)
freeSparklineSequence	sparkline.h	/^void freeSparklineSequence(struct sequence *seq);$/;"	p	signature:(struct sequence *seq)
freeStringObject	object.c	/^void freeStringObject(robj *o) {$/;"	f	signature:(robj *o)
freeStringObject	redis.h	/^void freeStringObject(robj *o);$/;"	p	signature:(robj *o)
freeZsetObject	object.c	/^void freeZsetObject(robj *o) {$/;"	f	signature:(robj *o)
freeZsetObject	redis.h	/^void freeZsetObject(robj *o);$/;"	p	signature:(robj *o)
friends	redis-trib.rb	/^    def friends$/;"	f	class:ClusterNode
full	redis-cli.c	/^    sds full;$/;"	m	struct:__anon15	file:	access:public
genClientPeerId	networking.c	/^int genClientPeerId(redisClient *client, char *peerid, size_t peerid_len) {$/;"	f	signature:(redisClient *client, char *peerid, size_t peerid_len)
genRedisInfoString	redis.c	/^sds genRedisInfoString(char *section) {$/;"	f	signature:(char *section)
genRedisInfoString	redis.h	/^sds genRedisInfoString(char *section);$/;"	p	signature:(char *section)
genericHgetallCommand	t_hash.c	/^void genericHgetallCommand(redisClient *c, int flags) {$/;"	f	signature:(redisClient *c, int flags)
genericZrangebylexCommand	t_zset.c	/^void genericZrangebylexCommand(redisClient *c, int reverse) {$/;"	f	signature:(redisClient *c, int reverse)
genericZrangebyscoreCommand	t_zset.c	/^void genericZrangebyscoreCommand(redisClient *c, int reverse) {$/;"	f	signature:(redisClient *c, int reverse)
getAbsolutePath	util.c	/^sds getAbsolutePath(char *filename) {$/;"	f	signature:(char *filename)
getAbsolutePath	util.h	/^sds getAbsolutePath(char *filename);$/;"	p	signature:(char *filename)
getAllClientsInfoString	networking.c	/^sds getAllClientsInfoString(void) {$/;"	f	signature:(void)
getAllClientsInfoString	redis.h	/^sds getAllClientsInfoString(void);$/;"	p	signature:(void)
getBitOffsetFromArgument	bitops.c	/^static int getBitOffsetFromArgument(redisClient *c, robj *o, size_t *offset) {$/;"	f	file:	signature:(redisClient *c, robj *o, size_t *offset)
getClientOutputBufferMemoryUsage	networking.c	/^unsigned long getClientOutputBufferMemoryUsage(redisClient *c) {$/;"	f	signature:(redisClient *c)
getClientOutputBufferMemoryUsage	redis.h	/^unsigned long getClientOutputBufferMemoryUsage(redisClient *c);$/;"	p	signature:(redisClient *c)
getClientPeerId	networking.c	/^char *getClientPeerId(redisClient *c) {$/;"	f	signature:(redisClient *c)
getClientPeerId	redis.h	/^char *getClientPeerId(redisClient *client);$/;"	p	signature:(redisClient *client)
getClientType	networking.c	/^int getClientType(redisClient *c) {$/;"	f	signature:(redisClient *c)
getClientType	redis.h	/^int getClientType(redisClient *c);$/;"	p	signature:(redisClient *c)
getClientTypeByName	networking.c	/^int getClientTypeByName(char *name) {$/;"	f	signature:(char *name)
getClientTypeByName	redis.h	/^int getClientTypeByName(char *name);$/;"	p	signature:(char *name)
getClientTypeName	networking.c	/^char *getClientTypeName(int class) {$/;"	f	signature:(int class)
getClientTypeName	redis.h	/^char *getClientTypeName(int class);$/;"	p	signature:(int class)
getClientsMaxBuffers	networking.c	/^void getClientsMaxBuffers(unsigned long *longest_output_list,$/;"	f	signature:(unsigned long *longest_output_list, unsigned long *biggest_input_buffer)
getClientsMaxBuffers	redis.h	/^void getClientsMaxBuffers(unsigned long *longest_output_list,$/;"	p	signature:(unsigned long *longest_output_list, unsigned long *biggest_input_buffer)
getCommand	redis.h	/^void getCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
getCommand	t_string.c	/^void getCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
getDbSize	redis-cli.c	/^static int getDbSize(void) {$/;"	f	file:	signature:(void)
getDecodedObject	object.c	/^robj *getDecodedObject(robj *o) {$/;"	f	signature:(robj *o)
getDecodedObject	redis.h	/^robj *getDecodedObject(robj *o);$/;"	p	signature:(robj *o)
getDoubleFromObject	object.c	/^int getDoubleFromObject(robj *o, double *target) {$/;"	f	signature:(robj *o, double *target)
getDoubleFromObjectOrReply	object.c	/^int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg) {$/;"	f	signature:(redisClient *c, robj *o, double *target, const char *msg)
getDoubleFromObjectOrReply	redis.h	/^int getDoubleFromObjectOrReply(redisClient *c, robj *o, double *target, const char *msg);$/;"	p	signature:(redisClient *c, robj *o, double *target, const char *msg)
getExpire	db.c	/^long long getExpire(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
getExpire	redis.h	/^long long getExpire(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
getGenericCommand	t_string.c	/^int getGenericCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
getHistoryPath	redis-cli.c	/^static sds getHistoryPath() {$/;"	f	file:
getInfoField	redis-cli.c	/^static char *getInfoField(char *info, char *field) {$/;"	f	file:	signature:(char *info, char *field)
getInstantaneousMetric	redis.c	/^long long getInstantaneousMetric(int metric) {$/;"	f	signature:(int metric)
getKeySizes	redis-cli.c	/^static void getKeySizes(redisReply *keys, int *types,$/;"	f	file:	signature:(redisReply *keys, int *types, unsigned long long *sizes)
getKeyTypes	redis-cli.c	/^static void getKeyTypes(redisReply *keys, int *types) {$/;"	f	file:	signature:(redisReply *keys, int *types)
getKeysFreeResult	db.c	/^void getKeysFreeResult(int *result) {$/;"	f	signature:(int *result)
getKeysFreeResult	redis.h	/^void getKeysFreeResult(int *result);$/;"	p	signature:(int *result)
getKeysFromCommand	db.c	/^int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
getKeysFromCommand	redis.h	/^int *getKeysFromCommand(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
getKeysInSlot	db.c	/^unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count) {$/;"	f	signature:(unsigned int hashslot, robj **keys, unsigned int count)
getKeysInSlot	redis.h	/^unsigned int getKeysInSlot(unsigned int hashslot, robj **keys, unsigned int count);$/;"	p	signature:(unsigned int hashslot, robj **keys, unsigned int count)
getKeysUsingCommandTable	db.c	/^int *getKeysUsingCommandTable(struct redisCommand *cmd,robj **argv, int argc, int *numkeys) {$/;"	f	signature:(struct redisCommand *cmd,robj **argv, int argc, int *numkeys)
getLRUClock	redis.c	/^unsigned int getLRUClock(void) {$/;"	f	signature:(void)
getLRUClock	redis.h	/^unsigned int getLRUClock(void);$/;"	p	signature:(void)
getLongDoubleFromObject	object.c	/^int getLongDoubleFromObject(robj *o, long double *target) {$/;"	f	signature:(robj *o, long double *target)
getLongDoubleFromObject	redis.h	/^int getLongDoubleFromObject(robj *o, long double *target);$/;"	p	signature:(robj *o, long double *target)
getLongDoubleFromObjectOrReply	object.c	/^int getLongDoubleFromObjectOrReply(redisClient *c, robj *o, long double *target, const char *msg) {$/;"	f	signature:(redisClient *c, robj *o, long double *target, const char *msg)
getLongDoubleFromObjectOrReply	redis.h	/^int getLongDoubleFromObjectOrReply(redisClient *c, robj *o, long double *target, const char *msg);$/;"	p	signature:(redisClient *c, robj *o, long double *target, const char *msg)
getLongFromObjectOrReply	object.c	/^int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg) {$/;"	f	signature:(redisClient *c, robj *o, long *target, const char *msg)
getLongFromObjectOrReply	redis.h	/^int getLongFromObjectOrReply(redisClient *c, robj *o, long *target, const char *msg);$/;"	p	signature:(redisClient *c, robj *o, long *target, const char *msg)
getLongInfoField	redis-cli.c	/^static long getLongInfoField(char *info, char *field) {$/;"	f	file:	signature:(char *info, char *field)
getLongLongFromObject	object.c	/^int getLongLongFromObject(robj *o, long long *target) {$/;"	f	signature:(robj *o, long long *target)
getLongLongFromObject	redis.h	/^int getLongLongFromObject(robj *o, long long *target);$/;"	p	signature:(robj *o, long long *target)
getLongLongFromObjectOrReply	object.c	/^int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg) {$/;"	f	signature:(redisClient *c, robj *o, long long *target, const char *msg)
getLongLongFromObjectOrReply	redis.h	/^int getLongLongFromObjectOrReply(redisClient *c, robj *o, long long *target, const char *msg);$/;"	p	signature:(redisClient *c, robj *o, long long *target, const char *msg)
getMcontextEip	debug.c	/^static void *getMcontextEip(ucontext_t *uc) {$/;"	f	file:	signature:(ucontext_t *uc)
getNodeByQuery	cluster.c	/^clusterNode *getNodeByQuery(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code) {$/;"	f	signature:(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *error_code)
getNodeByQuery	cluster.h	/^clusterNode *getNodeByQuery(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *ask);$/;"	p	signature:(redisClient *c, struct redisCommand *cmd, robj **argv, int argc, int *hashslot, int *ask)
getPsyncInitialOffset	redis.h	/^long long getPsyncInitialOffset(void);$/;"	p	signature:(void)
getPsyncInitialOffset	replication.c	/^long long getPsyncInitialOffset(void) {$/;"	f	signature:(void)
getRDB	redis-cli.c	/^static void getRDB(void) {$/;"	f	file:	signature:(void)
getRandomHexChars	redis.h	/^void getRandomHexChars(char *p, unsigned int len);$/;"	p	signature:(char *p, unsigned int len)
getRandomHexChars	util.c	/^void getRandomHexChars(char *p, unsigned int len) {$/;"	f	signature:(char *p, unsigned int len)
getSentinelRedisInstanceByAddrAndRunID	sentinel.c	/^sentinelRedisInstance *getSentinelRedisInstanceByAddrAndRunID(dict *instances, char *ip, int port, char *runid) {$/;"	f	signature:(dict *instances, char *ip, int port, char *runid)
getSlotOrReply	cluster.c	/^int getSlotOrReply(redisClient *c, robj *o) {$/;"	f	signature:(redisClient *c, robj *o)
getStringObjectSdsUsedMemory	networking.c	/^size_t getStringObjectSdsUsedMemory(robj *o) {$/;"	f	signature:(robj *o)
getTimeoutFromObjectOrReply	blocked.c	/^int getTimeoutFromObjectOrReply(redisClient *c, robj *object, mstime_t *timeout, int unit) {$/;"	f	signature:(redisClient *c, robj *object, mstime_t *timeout, int unit)
getTimeoutFromObjectOrReply	redis.h	/^int getTimeoutFromObjectOrReply(redisClient *c, robj *object, mstime_t *timeout, int unit);$/;"	p	signature:(redisClient *c, robj *object, mstime_t *timeout, int unit)
get_ack_from_slaves	redis.h	/^    int get_ack_from_slaves;            \/* If true we send REPLCONF GETACK. *\/$/;"	m	struct:redisServer	access:public
get_config_signature	redis-trib.rb	/^    def get_config_signature$/;"	f	class:ClusterNode
get_master_with_least_replicas	redis-trib.rb	/^    def get_master_with_least_replicas$/;"	f	class:RedisTrib
get_node_by_name	redis-trib.rb	/^    def get_node_by_name(name)$/;"	f	class:RedisTrib
get_slot_owner	redis-trib.rb	/^    def get_slot_owner(slot)$/;"	f	class:RedisTrib
getbitCommand	bitops.c	/^void getbitCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
getbitCommand	redis.h	/^void getbitCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
getkeys_proc	redis.h	/^    redisGetKeysProc *getkeys_proc;$/;"	m	struct:redisCommand	access:public
getrangeCommand	redis.h	/^void getrangeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
getrangeCommand	t_string.c	/^void getrangeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
getrdb_mode	redis-cli.c	/^    int getrdb_mode;$/;"	m	struct:config	file:	access:public
getsetCommand	redis.h	/^void getsetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
getsetCommand	t_string.c	/^void getsetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
gossip	cluster.h	/^        clusterMsgDataGossip gossip[1];$/;"	m	struct:clusterMsgData::__anon5	access:public
group	help.h	/^  int group;$/;"	m	struct:commandHelp	access:public
handleClientsBlockedOnLists	redis.h	/^void handleClientsBlockedOnLists(void);$/;"	p	signature:(void)
handleClientsBlockedOnLists	t_list.c	/^void handleClientsBlockedOnLists(void) {$/;"	f	signature:(void)
handleLinkIOError	cluster.c	/^void handleLinkIOError(clusterLink *link) {$/;"	f	signature:(clusterLink *link)
hard_limit_bytes	redis.h	/^    unsigned long long hard_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig	access:public
has_flag?	redis-trib.rb	/^    def has_flag?(flag)$/;"	f	class:ClusterNode
has_tail	config.c	/^    int has_tail;         \/* True if we already added directives that were$/;"	m	struct:rewriteConfigState	file:	access:public
hashDictType	redis.c	/^dictType hashDictType = {$/;"	v
hashDictType	redis.h	/^extern dictType hashDictType;$/;"	x
hashFunction	dict.h	/^    unsigned int (*hashFunction)(const void *key);$/;"	m	struct:dictType	access:public
hashTypeConvert	redis.h	/^void hashTypeConvert(robj *o, int enc);$/;"	p	signature:(robj *o, int enc)
hashTypeConvert	t_hash.c	/^void hashTypeConvert(robj *o, int enc) {$/;"	f	signature:(robj *o, int enc)
hashTypeConvertZiplist	t_hash.c	/^void hashTypeConvertZiplist(robj *o, int enc) {$/;"	f	signature:(robj *o, int enc)
hashTypeCurrentFromHashTable	redis.h	/^void hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what, robj **dst);$/;"	p	signature:(hashTypeIterator *hi, int what, robj **dst)
hashTypeCurrentFromHashTable	t_hash.c	/^void hashTypeCurrentFromHashTable(hashTypeIterator *hi, int what, robj **dst) {$/;"	f	signature:(hashTypeIterator *hi, int what, robj **dst)
hashTypeCurrentFromZiplist	redis.h	/^void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,$/;"	p	signature:(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeCurrentFromZiplist	t_hash.c	/^void hashTypeCurrentFromZiplist(hashTypeIterator *hi, int what,$/;"	f	signature:(hashTypeIterator *hi, int what, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeCurrentObject	redis.h	/^robj *hashTypeCurrentObject(hashTypeIterator *hi, int what);$/;"	p	signature:(hashTypeIterator *hi, int what)
hashTypeCurrentObject	t_hash.c	/^robj *hashTypeCurrentObject(hashTypeIterator *hi, int what) {$/;"	f	signature:(hashTypeIterator *hi, int what)
hashTypeDelete	redis.h	/^int hashTypeDelete(robj *o, robj *key);$/;"	p	signature:(robj *o, robj *key)
hashTypeDelete	t_hash.c	/^int hashTypeDelete(robj *o, robj *field) {$/;"	f	signature:(robj *o, robj *field)
hashTypeExists	redis.h	/^int hashTypeExists(robj *o, robj *key);$/;"	p	signature:(robj *o, robj *key)
hashTypeExists	t_hash.c	/^int hashTypeExists(robj *o, robj *field) {$/;"	f	signature:(robj *o, robj *field)
hashTypeGetFromHashTable	t_hash.c	/^int hashTypeGetFromHashTable(robj *o, robj *field, robj **value) {$/;"	f	signature:(robj *o, robj *field, robj **value)
hashTypeGetFromZiplist	t_hash.c	/^int hashTypeGetFromZiplist(robj *o, robj *field,$/;"	f	signature:(robj *o, robj *field, unsigned char **vstr, unsigned int *vlen, long long *vll)
hashTypeGetObject	redis.h	/^robj *hashTypeGetObject(robj *o, robj *key);$/;"	p	signature:(robj *o, robj *key)
hashTypeGetObject	t_hash.c	/^robj *hashTypeGetObject(robj *o, robj *field) {$/;"	f	signature:(robj *o, robj *field)
hashTypeInitIterator	redis.h	/^hashTypeIterator *hashTypeInitIterator(robj *subject);$/;"	p	signature:(robj *subject)
hashTypeInitIterator	t_hash.c	/^hashTypeIterator *hashTypeInitIterator(robj *subject) {$/;"	f	signature:(robj *subject)
hashTypeIterator	redis.h	/^} hashTypeIterator;$/;"	t	typeref:struct:__anon21
hashTypeLength	redis.h	/^unsigned long hashTypeLength(robj *o);$/;"	p	signature:(robj *o)
hashTypeLength	t_hash.c	/^unsigned long hashTypeLength(robj *o) {$/;"	f	signature:(robj *o)
hashTypeLookupWriteOrCreate	redis.h	/^robj *hashTypeLookupWriteOrCreate(redisClient *c, robj *key);$/;"	p	signature:(redisClient *c, robj *key)
hashTypeLookupWriteOrCreate	t_hash.c	/^robj *hashTypeLookupWriteOrCreate(redisClient *c, robj *key) {$/;"	f	signature:(redisClient *c, robj *key)
hashTypeNext	redis.h	/^int hashTypeNext(hashTypeIterator *hi);$/;"	p	signature:(hashTypeIterator *hi)
hashTypeNext	t_hash.c	/^int hashTypeNext(hashTypeIterator *hi) {$/;"	f	signature:(hashTypeIterator *hi)
hashTypeReleaseIterator	redis.h	/^void hashTypeReleaseIterator(hashTypeIterator *hi);$/;"	p	signature:(hashTypeIterator *hi)
hashTypeReleaseIterator	t_hash.c	/^void hashTypeReleaseIterator(hashTypeIterator *hi) {$/;"	f	signature:(hashTypeIterator *hi)
hashTypeSet	redis.h	/^int hashTypeSet(robj *o, robj *key, robj *value);$/;"	p	signature:(robj *o, robj *key, robj *value)
hashTypeSet	t_hash.c	/^int hashTypeSet(robj *o, robj *field, robj *value) {$/;"	f	signature:(robj *o, robj *field, robj *value)
hashTypeTryConversion	redis.h	/^void hashTypeTryConversion(robj *subject, robj **argv, int start, int end);$/;"	p	signature:(robj *subject, robj **argv, int start, int end)
hashTypeTryConversion	t_hash.c	/^void hashTypeTryConversion(robj *o, robj **argv, int start, int end) {$/;"	f	signature:(robj *o, robj **argv, int start, int end)
hashTypeTryObjectEncoding	redis.h	/^void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2);$/;"	p	signature:(robj *subject, robj **o1, robj **o2)
hashTypeTryObjectEncoding	t_hash.c	/^void hashTypeTryObjectEncoding(robj *subject, robj **o1, robj **o2) {$/;"	f	signature:(robj *subject, robj **o1, robj **o2)
hash_max_ziplist_entries	redis.h	/^    size_t hash_max_ziplist_entries;$/;"	m	struct:redisServer	access:public
hash_max_ziplist_value	redis.h	/^    size_t hash_max_ziplist_value;$/;"	m	struct:redisServer	access:public
hdelCommand	redis.h	/^void hdelCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hdelCommand	t_hash.c	/^void hdelCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
head	adlist.h	/^    listNode *head;$/;"	m	struct:list	access:public
header	redis.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode	access:public
headersize	ziplist.c	/^    unsigned int headersize;$/;"	m	struct:zlentry	file:	access:public
help.h	help.h	1;"	F
helpEntries	redis-cli.c	/^static helpEntry *helpEntries;$/;"	v	file:
helpEntriesLen	redis-cli.c	/^static int helpEntriesLen;$/;"	v	file:
helpEntry	redis-cli.c	/^} helpEntry;$/;"	t	typeref:struct:__anon15	file:
help_cluster_cmd	redis-trib.rb	/^    def help_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
hex_digit_to_int	sds.c	/^int hex_digit_to_int(char c) {$/;"	f	signature:(char c)
hexistsCommand	redis.h	/^void hexistsCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hexistsCommand	t_hash.c	/^void hexistsCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hgetCommand	redis.h	/^void hgetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hgetCommand	t_hash.c	/^void hgetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hgetallCommand	redis.h	/^void hgetallCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hgetallCommand	t_hash.c	/^void hgetallCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hincrbyCommand	redis.h	/^void hincrbyCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hincrbyCommand	t_hash.c	/^void hincrbyCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hincrbyfloatCommand	redis.h	/^void hincrbyfloatCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hincrbyfloatCommand	t_hash.c	/^void hincrbyfloatCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hkeysCommand	redis.h	/^void hkeysCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hkeysCommand	t_hash.c	/^void hkeysCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hlenCommand	redis.h	/^void hlenCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hlenCommand	t_hash.c	/^void hlenCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hllAdd	hyperloglog.c	/^int hllAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f	signature:(robj *o, unsigned char *ele, size_t elesize)
hllCount	hyperloglog.c	/^uint64_t hllCount(struct hllhdr *hdr, int *invalid) {$/;"	f	signature:(struct hllhdr *hdr, int *invalid)
hllDenseAdd	hyperloglog.c	/^int hllDenseAdd(uint8_t *registers, unsigned char *ele, size_t elesize) {$/;"	f	signature:(uint8_t *registers, unsigned char *ele, size_t elesize)
hllDenseSum	hyperloglog.c	/^double hllDenseSum(uint8_t *registers, double *PE, int *ezp) {$/;"	f	signature:(uint8_t *registers, double *PE, int *ezp)
hllMerge	hyperloglog.c	/^int hllMerge(uint8_t *max, robj *hll) {$/;"	f	signature:(uint8_t *max, robj *hll)
hllPatLen	hyperloglog.c	/^int hllPatLen(unsigned char *ele, size_t elesize, long *regp) {$/;"	f	signature:(unsigned char *ele, size_t elesize, long *regp)
hllRawSum	hyperloglog.c	/^double hllRawSum(uint8_t *registers, double *PE, int *ezp) {$/;"	f	signature:(uint8_t *registers, double *PE, int *ezp)
hllSparseAdd	hyperloglog.c	/^int hllSparseAdd(robj *o, unsigned char *ele, size_t elesize) {$/;"	f	signature:(robj *o, unsigned char *ele, size_t elesize)
hllSparseSum	hyperloglog.c	/^double hllSparseSum(uint8_t *sparse, int sparselen, double *PE, int *ezp, int *invalid) {$/;"	f	signature:(uint8_t *sparse, int sparselen, double *PE, int *ezp, int *invalid)
hllSparseToDense	hyperloglog.c	/^int hllSparseToDense(robj *o) {$/;"	f	signature:(robj *o)
hll_sparse_max_bytes	redis.h	/^    size_t hll_sparse_max_bytes;$/;"	m	struct:redisServer	access:public
hllhdr	hyperloglog.c	/^struct hllhdr {$/;"	s	file:
hllhdr::card	hyperloglog.c	/^    uint8_t card[8];    \/* Cached cardinality, little endian. *\/$/;"	m	struct:hllhdr	file:	access:public
hllhdr::encoding	hyperloglog.c	/^    uint8_t encoding;   \/* HLL_DENSE or HLL_SPARSE. *\/$/;"	m	struct:hllhdr	file:	access:public
hllhdr::magic	hyperloglog.c	/^    char magic[4];      \/* "HYLL" *\/$/;"	m	struct:hllhdr	file:	access:public
hllhdr::notused	hyperloglog.c	/^    uint8_t notused[3]; \/* Reserved for future use, must be zero. *\/$/;"	m	struct:hllhdr	file:	access:public
hllhdr::registers	hyperloglog.c	/^    uint8_t registers[]; \/* Data bytes. *\/$/;"	m	struct:hllhdr	file:	access:public
hmgetCommand	redis.h	/^void hmgetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hmgetCommand	t_hash.c	/^void hmgetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hmsetCommand	redis.h	/^void hmsetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hmsetCommand	t_hash.c	/^void hmsetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hostip	redis-benchmark.c	/^    const char *hostip;$/;"	m	struct:config	file:	access:public
hostip	redis-cli.c	/^    char *hostip;$/;"	m	struct:config	file:	access:public
hostport	redis-benchmark.c	/^    int hostport;$/;"	m	struct:config	file:	access:public
hostport	redis-cli.c	/^    int hostport;$/;"	m	struct:config	file:	access:public
hostsocket	redis-benchmark.c	/^    const char *hostsocket;$/;"	m	struct:config	file:	access:public
hostsocket	redis-cli.c	/^    char *hostsocket;$/;"	m	struct:config	file:	access:public
hscanCommand	redis.h	/^void hscanCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hscanCommand	t_hash.c	/^void hscanCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hsetCommand	redis.h	/^void hsetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hsetCommand	t_hash.c	/^void hsetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hsetnxCommand	redis.h	/^void hsetnxCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hsetnxCommand	t_hash.c	/^void hsetnxCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
ht	dict.h	/^    dictht ht[2];$/;"	m	struct:dict	access:public
ht	t_zset.c	/^            } ht;$/;"	m	union:__anon30::__anon31::_iterset	typeref:struct:__anon30::__anon31::_iterset::__anon33	file:	access:public
htNeedsResize	redis.c	/^int htNeedsResize(dict *dict) {$/;"	f	signature:(dict *dict)
htNeedsResize	redis.h	/^int htNeedsResize(dict *dict);$/;"	p	signature:(dict *dict)
htonu64	endianconv.h	/^#define htonu64(/;"	d
hvalsCommand	redis.h	/^void hvalsCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
hvalsCommand	t_hash.c	/^void hvalsCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
hyperloglog.c	hyperloglog.c	1;"	F
hz	redis.h	/^    int hz;                     \/* serverCron() calls frequency in hertz *\/$/;"	m	struct:redisServer	access:public
hz	redis.h	/^#undef hz$/;"	d
id	ae.h	/^    long long id; \/* time event identifier. *\/$/;"	m	struct:aeTimeEvent	access:public
id	redis.h	/^    int id;                     \/* Database ID *\/$/;"	m	struct:redisDb	access:public
id	redis.h	/^    uint64_t id;            \/* Client incremental unique ID. *\/$/;"	m	struct:redisClient	access:public
id	slowlog.h	/^    long long id;       \/* Unique entry identifier. *\/$/;"	m	struct:slowlogEntry	access:public
idle	redis.h	/^    unsigned long long idle;    \/* Object idle time. *\/$/;"	m	struct:evictionPoolEntry	access:public
idlemode	redis-benchmark.c	/^    int idlemode;$/;"	m	struct:config	file:	access:public
idx	latency.h	/^    int idx; \/* Index of the next sample to store. *\/$/;"	m	struct:latencyTimeSeries	access:public
idx	redis.h	/^        int idx;$/;"	m	struct:redisServer::__anon16	access:public
ii	redis.h	/^    int ii; \/* intset iterator *\/$/;"	m	struct:__anon20	access:public
ii	t_zset.c	/^                int ii;$/;"	m	struct:__anon30::__anon31::_iterset::__anon32	file:	access:public
import_cluster_cmd	redis-trib.rb	/^    def import_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
importing_slots_from	cluster.h	/^    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];$/;"	m	struct:clusterState	access:public
incrCommand	redis.h	/^void incrCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
incrCommand	t_string.c	/^void incrCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
incrDecrCommand	t_string.c	/^void incrDecrCommand(redisClient *c, long long incr) {$/;"	f	signature:(redisClient *c, long long incr)
incrRefCount	object.c	/^void incrRefCount(robj *o) {$/;"	f	signature:(robj *o)
incrRefCount	redis.h	/^void incrRefCount(robj *o);$/;"	p	signature:(robj *o)
incrbyCommand	redis.h	/^void incrbyCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
incrbyCommand	t_string.c	/^void incrbyCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
incrbyfloatCommand	redis.h	/^void incrbyfloatCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
incrbyfloatCommand	t_string.c	/^void incrbyfloatCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
incrementallyRehash	redis.c	/^int incrementallyRehash(int dbid) {$/;"	f	signature:(int dbid)
index	dict.h	/^    long index;$/;"	m	struct:dictIterator	access:public
info	redis-trib.rb	/^    def info$/;"	f	class:ClusterNode
infoCommand	redis.c	/^void infoCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
infoCommand	redis.h	/^void infoCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
info_refresh	sentinel.c	/^    mstime_t info_refresh;  \/* Time at which we received INFO output from it. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
info_string	redis-trib.rb	/^    def info_string$/;"	f	class:ClusterNode
initClientMultiState	multi.c	/^void initClientMultiState(redisClient *c) {$/;"	f	signature:(redisClient *c)
initClientMultiState	redis.h	/^void initClientMultiState(redisClient *c);$/;"	p	signature:(redisClient *c)
initSentinel	redis.h	/^void initSentinel(void);$/;"	p	signature:(void)
initSentinel	sentinel.c	/^void initSentinel(void) {$/;"	f	signature:(void)
initSentinelConfig	redis.h	/^void initSentinelConfig(void);$/;"	p	signature:(void)
initSentinelConfig	sentinel.c	/^void initSentinelConfig(void) {$/;"	f	signature:(void)
initServer	redis.c	/^void initServer(void) {$/;"	f	signature:(void)
initServerConfig	redis.c	/^void initServerConfig(void) {$/;"	f	signature:(void)
initStaticStringObject	redis.h	/^#define initStaticStringObject(/;"	d
initialize	redis-trib.rb	/^    def initialize$/;"	f	class:RedisTrib
initialize	redis-trib.rb	/^    def initialize(addr)$/;"	f	class:ClusterNode
inline	lzf_c.c	/^# define inline /;"	d	file:
inst_metric	redis.h	/^    } inst_metric[REDIS_METRIC_COUNT];$/;"	m	struct:redisServer	typeref:struct:redisServer::__anon16	access:public
instancesDictType	sentinel.c	/^dictType instancesDictType = {$/;"	v
integers	redis.h	/^    *integers[REDIS_SHARED_INTEGERS],$/;"	m	struct:sharedObjectsStruct	access:public
interactive	redis-cli.c	/^    int interactive;$/;"	m	struct:config	file:	access:public
interval	redis-cli.c	/^    long interval;$/;"	m	struct:config	file:	access:public
intrev16	endianconv.c	/^uint16_t intrev16(uint16_t v) {$/;"	f	signature:(uint16_t v)
intrev16	endianconv.h	/^uint16_t intrev16(uint16_t v);$/;"	p	signature:(uint16_t v)
intrev16ifbe	endianconv.h	/^#define intrev16ifbe(/;"	d
intrev32	endianconv.c	/^uint32_t intrev32(uint32_t v) {$/;"	f	signature:(uint32_t v)
intrev32	endianconv.h	/^uint32_t intrev32(uint32_t v);$/;"	p	signature:(uint32_t v)
intrev32ifbe	endianconv.h	/^#define intrev32ifbe(/;"	d
intrev64	endianconv.c	/^uint64_t intrev64(uint64_t v) {$/;"	f	signature:(uint64_t v)
intrev64	endianconv.h	/^uint64_t intrev64(uint64_t v);$/;"	p	signature:(uint64_t v)
intrev64ifbe	endianconv.h	/^#define intrev64ifbe(/;"	d
intrinsicLatencyMode	redis-cli.c	/^static void intrinsicLatencyMode(void) {$/;"	f	file:	signature:(void)
intrinsicLatencyModeStop	redis-cli.c	/^static void intrinsicLatencyModeStop(int s) {$/;"	f	file:	signature:(int s)
intrinsic_latency_duration	redis-cli.c	/^    int intrinsic_latency_duration;$/;"	m	struct:config	file:	access:public
intrinsic_latency_mode	redis-cli.c	/^    int intrinsic_latency_mode;$/;"	m	struct:config	file:	access:public
intset	intset.h	/^typedef struct intset {$/;"	s
intset	intset.h	/^} intset;$/;"	t	typeref:struct:intset
intset.c	intset.c	1;"	F
intset.h	intset.h	1;"	F
intset::contents	intset.h	/^    int8_t contents[];$/;"	m	struct:intset	access:public
intset::encoding	intset.h	/^    uint32_t encoding;$/;"	m	struct:intset	access:public
intset::length	intset.h	/^    uint32_t length;$/;"	m	struct:intset	access:public
intsetAdd	intset.c	/^intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {$/;"	f	signature:(intset *is, int64_t value, uint8_t *success)
intsetAdd	intset.h	/^intset *intsetAdd(intset *is, int64_t value, uint8_t *success);$/;"	p	signature:(intset *is, int64_t value, uint8_t *success)
intsetBlobLen	intset.c	/^size_t intsetBlobLen(intset *is) {$/;"	f	signature:(intset *is)
intsetBlobLen	intset.h	/^size_t intsetBlobLen(intset *is);$/;"	p	signature:(intset *is)
intsetFind	intset.c	/^uint8_t intsetFind(intset *is, int64_t value) {$/;"	f	signature:(intset *is, int64_t value)
intsetFind	intset.h	/^uint8_t intsetFind(intset *is, int64_t value);$/;"	p	signature:(intset *is, int64_t value)
intsetGet	intset.c	/^uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value) {$/;"	f	signature:(intset *is, uint32_t pos, int64_t *value)
intsetGet	intset.h	/^uint8_t intsetGet(intset *is, uint32_t pos, int64_t *value);$/;"	p	signature:(intset *is, uint32_t pos, int64_t *value)
intsetLen	intset.c	/^uint32_t intsetLen(intset *is) {$/;"	f	signature:(intset *is)
intsetLen	intset.h	/^uint32_t intsetLen(intset *is);$/;"	p	signature:(intset *is)
intsetMoveTail	intset.c	/^static void intsetMoveTail(intset *is, uint32_t from, uint32_t to) {$/;"	f	file:	signature:(intset *is, uint32_t from, uint32_t to)
intsetNew	intset.c	/^intset *intsetNew(void) {$/;"	f	signature:(void)
intsetNew	intset.h	/^intset *intsetNew(void);$/;"	p	signature:(void)
intsetRandom	intset.c	/^int64_t intsetRandom(intset *is) {$/;"	f	signature:(intset *is)
intsetRandom	intset.h	/^int64_t intsetRandom(intset *is);$/;"	p	signature:(intset *is)
intsetRemove	intset.c	/^intset *intsetRemove(intset *is, int64_t value, int *success) {$/;"	f	signature:(intset *is, int64_t value, int *success)
intsetRemove	intset.h	/^intset *intsetRemove(intset *is, int64_t value, int *success);$/;"	p	signature:(intset *is, int64_t value, int *success)
intsetRepr	intset.c	/^void intsetRepr(intset *is) {$/;"	f	signature:(intset *is)
intsetResize	intset.c	/^static intset *intsetResize(intset *is, uint32_t len) {$/;"	f	file:	signature:(intset *is, uint32_t len)
intsetSearch	intset.c	/^static uint8_t intsetSearch(intset *is, int64_t value, uint32_t *pos) {$/;"	f	file:	signature:(intset *is, int64_t value, uint32_t *pos)
intsetUpgradeAndAdd	intset.c	/^static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {$/;"	f	file:	signature:(intset *is, int64_t value)
invalid_hll_err	hyperloglog.c	/^static char *invalid_hll_err = "-INVALIDOBJ Corrupted HLL object detected\\r\\n";$/;"	v	file:
io	rio.h	/^    } io;$/;"	m	struct:_rio	typeref:union:_rio::__anon24	access:public
ip	cluster.h	/^    char ip[REDIS_IP_STR_LEN];  \/* IP address last time it was seen *\/$/;"	m	struct:__anon1	access:public
ip	cluster.h	/^    char ip[REDIS_IP_STR_LEN];  \/* Latest known IP address of this node *\/$/;"	m	struct:clusterNode	access:public
ip	sentinel.c	/^    char *ip;$/;"	m	struct:sentinelAddr	file:	access:public
ip_len	anet.h	/^#undef ip_len$/;"	d
ipfd	redis.h	/^    int ipfd[REDIS_BINDADDR_MAX]; \/* TCP socket file descriptors *\/$/;"	m	struct:redisServer	access:public
ipfd_count	redis.h	/^    int ipfd_count;             \/* Used slots in ipfd[] *\/$/;"	m	struct:redisServer	access:public
is	t_zset.c	/^                intset *is;$/;"	m	struct:__anon30::__anon31::_iterset::__anon32	file:	access:public
is	t_zset.c	/^            } is;$/;"	m	union:__anon30::__anon31::_iterset	typeref:struct:__anon30::__anon31::_iterset::__anon32	file:	access:public
isHLLObjectOrReply	hyperloglog.c	/^int isHLLObjectOrReply(redisClient *c, robj *o) {$/;"	f	signature:(redisClient *c, robj *o)
isObjectRepresentableAsLongLong	object.c	/^int isObjectRepresentableAsLongLong(robj *o, long long *llval) {$/;"	f	signature:(robj *o, long long *llval)
isObjectRepresentableAsLongLong	redis.h	/^int isObjectRepresentableAsLongLong(robj *o, long long *llongval);$/;"	p	signature:(robj *o, long long *llongval)
is_config_consistent?	redis-trib.rb	/^    def is_config_consistent?$/;"	f	class:RedisTrib
is_dirty?	redis-trib.rb	/^    def is_dirty?$/;"	f	class:ClusterNode
is_hex_digit	sds.c	/^int is_hex_digit(char c) {$/;"	f	signature:(char c)
isfinite	solarisfixes.h	/^#define isfinite(/;"	d
isfinite	solarisfixes.h	/^#undef isfinite$/;"	d
isinf	solarisfixes.h	/^#define isinf(/;"	d
isinf	solarisfixes.h	/^#undef isinf$/;"	d
isnan	solarisfixes.h	/^#define isnan(/;"	d
isnan	solarisfixes.h	/^#undef isnan$/;"	d
issueCommand	redis-cli.c	/^static int issueCommand(int argc, char **argv) {$/;"	f	file:	signature:(int argc, char **argv)
issueCommandRepeat	redis-cli.c	/^static int issueCommandRepeat(int argc, char **argv, long repeat) {$/;"	f	file:	signature:(int argc, char **argv, long repeat)
iter	t_zset.c	/^    } iter;$/;"	m	struct:__anon30	typeref:union:__anon30::__anon31	file:	access:public
iterators	dict.h	/^    int iterators; \/* number of iterators currently running *\/$/;"	m	struct:dict	access:public
iterset	t_zset.c	/^typedef union _iterset iterset;$/;"	t	typeref:union:_iterset	file:
iterzset	t_zset.c	/^typedef union _iterzset iterzset;$/;"	t	typeref:union:_iterzset	file:
join_cluster	redis-trib.rb	/^    def join_cluster$/;"	f	class:RedisTrib.alloc_slots
keepalive	redis-benchmark.c	/^    int keepalive;$/;"	m	struct:config	file:	access:public
key	dict.h	/^    void *key;$/;"	m	struct:dictEntry	access:public
key	multi.c	/^    robj *key;$/;"	m	struct:watchedKey	file:	access:public
key	redis-check-dump.c	/^    char* key;$/;"	m	struct:__anon14	file:	access:public
key	redis.h	/^    robj *key;$/;"	m	struct:readyList	access:public
key	redis.h	/^    sds key;                    \/* Key name. *\/$/;"	m	struct:evictionPoolEntry	access:public
keyCompare	dict.h	/^    int (*keyCompare)(void *privdata, const void *key1, const void *key2);$/;"	m	struct:dictType	access:public
keyDestructor	dict.h	/^    void (*keyDestructor)(void *privdata, void *key);$/;"	m	struct:dictType	access:public
keyDup	dict.h	/^    void *(*keyDup)(void *privdata, const void *key);$/;"	m	struct:dictType	access:public
keyHashSlot	cluster.c	/^unsigned int keyHashSlot(char *key, int keylen) {$/;"	f	signature:(char *key, int keylen)
keyHashSlot	redis.h	/^unsigned int keyHashSlot(char *key, int keylen);$/;"	p	signature:(char *key, int keylen)
key_to_slot	redis-trib.rb	/^def key_to_slot(key)$/;"	f	class:RedisTrib
keylistDictType	redis.c	/^dictType keylistDictType = {$/;"	v
keyptrDictType	redis.c	/^dictType keyptrDictType = {$/;"	v
keys	redis.h	/^    dict *keys;             \/* The keys we are waiting to terminate a blocking$/;"	m	struct:blockingState	access:public
keysCommand	db.c	/^void keysCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
keysCommand	redis.h	/^void keysCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
keysize	redis-benchmark.c	/^    int keysize;$/;"	m	struct:config	file:	access:public
keyspaceEventsFlagsToString	notify.c	/^sds keyspaceEventsFlagsToString(int flags) {$/;"	f	signature:(int flags)
keyspaceEventsFlagsToString	redis.h	/^sds keyspaceEventsFlagsToString(int flags);$/;"	p	signature:(int flags)
keyspaceEventsStringToFlags	notify.c	/^int keyspaceEventsStringToFlags(char *classes) {$/;"	f	signature:(char *classes)
keyspaceEventsStringToFlags	redis.h	/^int keyspaceEventsStringToFlags(char *classes);$/;"	p	signature:(char *classes)
keystep	redis.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	struct:redisCommand	access:public
kqfd	ae_kqueue.c	/^    int kqfd;$/;"	m	struct:aeApiState	file:	access:public
label	sparkline.h	/^    char *label;$/;"	m	struct:sample	access:public
label_margin_top	sparkline.c	/^static int label_margin_top = 1;$/;"	v	file:
labels	sparkline.h	/^    int labels;$/;"	m	struct:sequence	access:public
lastTime	ae.h	/^    time_t lastTime;     \/* Used to detect system clock skew *\/$/;"	m	struct:aeEventLoop	access:public
lastVoteEpoch	cluster.h	/^    uint64_t lastVoteEpoch;     \/* Epoch of the last vote granted. *\/$/;"	m	struct:clusterState	access:public
last_avail_time	sentinel.c	/^    mstime_t last_avail_time; \/* Last time the instance replied to ping with$/;"	m	struct:sentinelRedisInstance	file:	access:public
last_cmd_type	redis-cli.c	/^    int last_cmd_type;$/;"	m	struct:config	file:	access:public
last_dbid	cluster.c	/^    long last_dbid;$/;"	m	struct:migrateCachedSocket	file:	access:public
last_hello_time	sentinel.c	/^    mstime_t last_hello_time; \/* Only used if SRI_SENTINEL is set. Last time$/;"	m	struct:sentinelRedisInstance	file:	access:public
last_master_down_reply_time	sentinel.c	/^    mstime_t last_master_down_reply_time; \/* Time of last reply to$/;"	m	struct:sentinelRedisInstance	file:	access:public
last_ping_time	sentinel.c	/^    mstime_t last_ping_time;  \/* Last time a pending ping was sent in the$/;"	m	struct:sentinelRedisInstance	file:	access:public
last_pong_time	sentinel.c	/^    mstime_t last_pong_time;  \/* Last time the instance replied to ping,$/;"	m	struct:sentinelRedisInstance	file:	access:public
last_pub_time	sentinel.c	/^    mstime_t last_pub_time;   \/* Last time we sent hello via Pub\/Sub. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
last_sample_count	redis.h	/^        long long last_sample_count;\/* Count in last sample *\/$/;"	m	struct:redisServer::__anon16	access:public
last_sample_time	redis.h	/^        long long last_sample_time; \/* Timestamp of last sample in ms *\/$/;"	m	struct:redisServer::__anon16	access:public
last_use_time	cluster.c	/^    time_t last_use_time;$/;"	m	struct:migrateCachedSocket	file:	access:public
lastbgsave_status	redis.h	/^    int lastbgsave_status;          \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer	access:public
lastbgsave_try	redis.h	/^    time_t lastbgsave_try;          \/* Unix time of last attempted bgsave *\/$/;"	m	struct:redisServer	access:public
lastcmd	redis.h	/^    struct redisCommand *cmd, *lastcmd;$/;"	m	struct:redisClient	typeref:struct:redisClient::	access:public
lastinteraction	redis.h	/^    time_t lastinteraction; \/* time of the last interaction, used for timeout *\/$/;"	m	struct:redisClient	access:public
lastkey	redis.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	struct:redisCommand	access:public
lastsave	redis.h	/^    time_t lastsave;                \/* Unix time of last successful save *\/$/;"	m	struct:redisServer	access:public
lastsaveCommand	db.c	/^void lastsaveCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lastsaveCommand	redis.h	/^void lastsaveCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
latency	latency.h	/^    uint32_t latency; \/* Latency in milliseconds. *\/$/;"	m	struct:latencySample	access:public
latency	redis-benchmark.c	/^    long long *latency;$/;"	m	struct:config	file:	access:public
latency	redis-benchmark.c	/^    long long latency;      \/* Request latency *\/$/;"	m	struct:_client	file:	access:public
latency.c	latency.c	1;"	F
latency.h	latency.h	1;"	F
latencyAddSample	latency.c	/^void latencyAddSample(char *event, mstime_t latency) {$/;"	f	signature:(char *event, mstime_t latency)
latencyAddSample	latency.h	/^void latencyAddSample(char *event, mstime_t latency);$/;"	p	signature:(char *event, mstime_t latency)
latencyAddSampleIfNeeded	latency.h	/^#define latencyAddSampleIfNeeded(/;"	d
latencyCommand	latency.c	/^void latencyCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
latencyCommand	redis.h	/^void latencyCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
latencyCommandGenSparkeline	latency.c	/^sds latencyCommandGenSparkeline(char *event, struct latencyTimeSeries *ts) {$/;"	f	signature:(char *event, struct latencyTimeSeries *ts)
latencyCommandReplyWithLatestEvents	latency.c	/^void latencyCommandReplyWithLatestEvents(redisClient *c) {$/;"	f	signature:(redisClient *c)
latencyCommandReplyWithSamples	latency.c	/^void latencyCommandReplyWithSamples(redisClient *c, struct latencyTimeSeries *ts) {$/;"	f	signature:(redisClient *c, struct latencyTimeSeries *ts)
latencyDistMode	redis-cli.c	/^static void latencyDistMode(void) {$/;"	f	file:	signature:(void)
latencyEndMonitor	latency.h	/^#define latencyEndMonitor(/;"	d
latencyMode	redis-cli.c	/^static void latencyMode(void) {$/;"	f	file:	signature:(void)
latencyMonitorInit	latency.c	/^void latencyMonitorInit(void) {$/;"	f	signature:(void)
latencyMonitorInit	latency.h	/^void latencyMonitorInit(void);$/;"	p	signature:(void)
latencyRemoveNestedEvent	latency.h	/^#define latencyRemoveNestedEvent(/;"	d
latencyResetEvent	latency.c	/^int latencyResetEvent(char *event_to_reset) {$/;"	f	signature:(char *event_to_reset)
latencySample	latency.h	/^struct latencySample {$/;"	s
latencySample::latency	latency.h	/^    uint32_t latency; \/* Latency in milliseconds. *\/$/;"	m	struct:latencySample	access:public
latencySample::time	latency.h	/^    int32_t time; \/* We don't use time_t to force 4 bytes usage everywhere. *\/$/;"	m	struct:latencySample	access:public
latencyStartMonitor	latency.h	/^#define latencyStartMonitor(/;"	d
latencyStats	latency.h	/^struct latencyStats {$/;"	s
latencyStats::all_time_high	latency.h	/^    uint32_t all_time_high; \/* Absolute max observed since latest reset. *\/$/;"	m	struct:latencyStats	access:public
latencyStats::avg	latency.h	/^    uint32_t avg;           \/* Average of current samples. *\/$/;"	m	struct:latencyStats	access:public
latencyStats::mad	latency.h	/^    uint32_t mad;           \/* Mean absolute deviation. *\/$/;"	m	struct:latencyStats	access:public
latencyStats::max	latency.h	/^    uint32_t max;           \/* Max of current samples. *\/$/;"	m	struct:latencyStats	access:public
latencyStats::min	latency.h	/^    uint32_t min;           \/* Min of current samples. *\/$/;"	m	struct:latencyStats	access:public
latencyStats::period	latency.h	/^    time_t period;          \/* Number of seconds since first event and now. *\/$/;"	m	struct:latencyStats	access:public
latencyStats::samples	latency.h	/^    uint32_t samples;       \/* Number of non-zero samples. *\/$/;"	m	struct:latencyStats	access:public
latencyTimeSeries	latency.h	/^struct latencyTimeSeries {$/;"	s
latencyTimeSeries::idx	latency.h	/^    int idx; \/* Index of the next sample to store. *\/$/;"	m	struct:latencyTimeSeries	access:public
latencyTimeSeries::max	latency.h	/^    uint32_t max; \/* Max latency observed for this event. *\/$/;"	m	struct:latencyTimeSeries	access:public
latencyTimeSeries::samples	latency.h	/^    struct latencySample samples[LATENCY_TS_LEN]; \/* Latest history. *\/$/;"	m	struct:latencyTimeSeries	typeref:struct:latencyTimeSeries::latencySample	access:public
latencyTimeSeriesDictType	latency.c	/^dictType latencyTimeSeriesDictType = {$/;"	v
latency_dist_mode	redis-cli.c	/^    int latency_dist_mode;$/;"	m	struct:config	file:	access:public
latency_events	redis.h	/^    dict *latency_events;$/;"	m	struct:redisServer	access:public
latency_history	redis-cli.c	/^    int latency_history;$/;"	m	struct:config	file:	access:public
latency_mode	redis-cli.c	/^    int latency_mode;$/;"	m	struct:config	file:	access:public
latency_monitor_threshold	redis.h	/^    long long latency_monitor_threshold;$/;"	m	struct:redisServer	access:public
leader	sentinel.c	/^    char *leader;       \/* If this is a master instance, this is the runid of$/;"	m	struct:sentinelRedisInstance	file:	access:public
leaderVotesDictType	sentinel.c	/^dictType leaderVotesDictType = {$/;"	v
leader_epoch	sentinel.c	/^    uint64_t leader_epoch; \/* Epoch of the 'leader' field. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
len	adlist.h	/^    unsigned long len;$/;"	m	struct:list	access:public
len	sds.h	/^    unsigned int len;$/;"	m	struct:sdshdr	access:public
len	ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:	access:public
length	intset.h	/^    uint32_t length;$/;"	m	struct:intset	access:public
length	redis.h	/^    unsigned long length;$/;"	m	struct:zskiplist	access:public
length	sparkline.h	/^    int length;$/;"	m	struct:sequence	access:public
lensize	ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:	access:public
level	redis-check-dump.c	/^    size_t level;$/;"	m	struct:__anon13	file:	access:public
level	redis-check-dump.c	/^static unsigned char level = 0;$/;"	v	file:
level	redis.h	/^    int level;$/;"	m	struct:zskiplist	access:public
level	redis.h	/^    } level[];$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistLevel	access:public
li	redis.h	/^    listTypeIterator *li;$/;"	m	struct:__anon19	access:public
lindexCommand	redis.h	/^void lindexCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
lindexCommand	t_list.c	/^void lindexCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lines	config.c	/^    sds *lines;           \/* Current lines as an array of sds strings *\/$/;"	m	struct:rewriteConfigState	file:	access:public
link	cluster.h	/^    clusterLink *link;          \/* TCP\/IP link with this node *\/$/;"	m	struct:clusterNode	access:public
linsertCommand	redis.h	/^void linsertCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
linsertCommand	t_list.c	/^void linsertCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
linuxMemoryWarnings	redis.c	/^void linuxMemoryWarnings(void) {$/;"	f	signature:(void)
linuxOvercommitMemoryValue	redis.c	/^int linuxOvercommitMemoryValue(void) {$/;"	f	signature:(void)
list	adlist.h	/^typedef struct list {$/;"	s
list	adlist.h	/^} list;$/;"	t	typeref:struct:list
list::dup	adlist.h	/^    void *(*dup)(void *ptr);$/;"	m	struct:list	access:public
list::free	adlist.h	/^    void (*free)(void *ptr);$/;"	m	struct:list	access:public
list::head	adlist.h	/^    listNode *head;$/;"	m	struct:list	access:public
list::len	adlist.h	/^    unsigned long len;$/;"	m	struct:list	access:public
list::match	adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:list	access:public
list::tail	adlist.h	/^    listNode *tail;$/;"	m	struct:list	access:public
listAddNodeHead	adlist.c	/^list *listAddNodeHead(list *list, void *value)$/;"	f	signature:(list *list, void *value)
listAddNodeHead	adlist.h	/^list *listAddNodeHead(list *list, void *value);$/;"	p	signature:(list *list, void *value)
listAddNodeTail	adlist.c	/^list *listAddNodeTail(list *list, void *value)$/;"	f	signature:(list *list, void *value)
listAddNodeTail	adlist.h	/^list *listAddNodeTail(list *list, void *value);$/;"	p	signature:(list *list, void *value)
listCreate	adlist.c	/^list *listCreate(void)$/;"	f	signature:(void)
listCreate	adlist.h	/^list *listCreate(void);$/;"	p	signature:(void)
listDelNode	adlist.c	/^void listDelNode(list *list, listNode *node)$/;"	f	signature:(list *list, listNode *node)
listDelNode	adlist.h	/^void listDelNode(list *list, listNode *node);$/;"	p	signature:(list *list, listNode *node)
listDup	adlist.c	/^list *listDup(list *orig)$/;"	f	signature:(list *orig)
listDup	adlist.h	/^list *listDup(list *orig);$/;"	p	signature:(list *orig)
listFirst	adlist.h	/^#define listFirst(/;"	d
listGetDupMethod	adlist.h	/^#define listGetDupMethod(/;"	d
listGetFree	adlist.h	/^#define listGetFree(/;"	d
listGetIterator	adlist.c	/^listIter *listGetIterator(list *list, int direction)$/;"	f	signature:(list *list, int direction)
listGetIterator	adlist.h	/^listIter *listGetIterator(list *list, int direction);$/;"	p	signature:(list *list, int direction)
listGetMatchMethod	adlist.h	/^#define listGetMatchMethod(/;"	d
listIndex	adlist.c	/^listNode *listIndex(list *list, long index) {$/;"	f	signature:(list *list, long index)
listIndex	adlist.h	/^listNode *listIndex(list *list, long index);$/;"	p	signature:(list *list, long index)
listInsertNode	adlist.c	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after) {$/;"	f	signature:(list *list, listNode *old_node, void *value, int after)
listInsertNode	adlist.h	/^list *listInsertNode(list *list, listNode *old_node, void *value, int after);$/;"	p	signature:(list *list, listNode *old_node, void *value, int after)
listIter	adlist.h	/^typedef struct listIter {$/;"	s
listIter	adlist.h	/^} listIter;$/;"	t	typeref:struct:listIter
listIter::direction	adlist.h	/^    int direction;$/;"	m	struct:listIter	access:public
listIter::next	adlist.h	/^    listNode *next;$/;"	m	struct:listIter	access:public
listLast	adlist.h	/^#define listLast(/;"	d
listLength	adlist.h	/^#define listLength(/;"	d
listMatchObjects	networking.c	/^int listMatchObjects(void *a, void *b) {$/;"	f	signature:(void *a, void *b)
listMatchPubsubPattern	pubsub.c	/^int listMatchPubsubPattern(void *a, void *b) {$/;"	f	signature:(void *a, void *b)
listMatchPubsubPattern	redis.h	/^int listMatchPubsubPattern(void *a, void *b);$/;"	p	signature:(void *a, void *b)
listNext	adlist.c	/^listNode *listNext(listIter *iter)$/;"	f	signature:(listIter *iter)
listNext	adlist.h	/^listNode *listNext(listIter *iter);$/;"	p	signature:(listIter *iter)
listNextNode	adlist.h	/^#define listNextNode(/;"	d
listNode	adlist.h	/^typedef struct listNode {$/;"	s
listNode	adlist.h	/^} listNode;$/;"	t	typeref:struct:listNode
listNode::next	adlist.h	/^    struct listNode *next;$/;"	m	struct:listNode	typeref:struct:listNode::listNode	access:public
listNode::prev	adlist.h	/^    struct listNode *prev;$/;"	m	struct:listNode	typeref:struct:listNode::listNode	access:public
listNode::value	adlist.h	/^    void *value;$/;"	m	struct:listNode	access:public
listNodeValue	adlist.h	/^#define listNodeValue(/;"	d
listPrevNode	adlist.h	/^#define listPrevNode(/;"	d
listRelease	adlist.c	/^void listRelease(list *list)$/;"	f	signature:(list *list)
listRelease	adlist.h	/^void listRelease(list *list);$/;"	p	signature:(list *list)
listReleaseIterator	adlist.c	/^void listReleaseIterator(listIter *iter) {$/;"	f	signature:(listIter *iter)
listReleaseIterator	adlist.h	/^void listReleaseIterator(listIter *iter);$/;"	p	signature:(listIter *iter)
listRewind	adlist.c	/^void listRewind(list *list, listIter *li) {$/;"	f	signature:(list *list, listIter *li)
listRewind	adlist.h	/^void listRewind(list *list, listIter *li);$/;"	p	signature:(list *list, listIter *li)
listRewindTail	adlist.c	/^void listRewindTail(list *list, listIter *li) {$/;"	f	signature:(list *list, listIter *li)
listRewindTail	adlist.h	/^void listRewindTail(list *list, listIter *li);$/;"	p	signature:(list *list, listIter *li)
listRotate	adlist.c	/^void listRotate(list *list) {$/;"	f	signature:(list *list)
listRotate	adlist.h	/^void listRotate(list *list);$/;"	p	signature:(list *list)
listSearchKey	adlist.c	/^listNode *listSearchKey(list *list, void *key)$/;"	f	signature:(list *list, void *key)
listSearchKey	adlist.h	/^listNode *listSearchKey(list *list, void *key);$/;"	p	signature:(list *list, void *key)
listSetDupMethod	adlist.h	/^#define listSetDupMethod(/;"	d
listSetFreeMethod	adlist.h	/^#define listSetFreeMethod(/;"	d
listSetMatchMethod	adlist.h	/^#define listSetMatchMethod(/;"	d
listTypeConvert	redis.h	/^void listTypeConvert(robj *subject, int enc);$/;"	p	signature:(robj *subject, int enc)
listTypeConvert	t_list.c	/^void listTypeConvert(robj *subject, int enc) {$/;"	f	signature:(robj *subject, int enc)
listTypeDelete	redis.h	/^void listTypeDelete(listTypeEntry *entry);$/;"	p	signature:(listTypeEntry *entry)
listTypeDelete	t_list.c	/^void listTypeDelete(listTypeEntry *entry) {$/;"	f	signature:(listTypeEntry *entry)
listTypeEntry	redis.h	/^} listTypeEntry;$/;"	t	typeref:struct:__anon19
listTypeEqual	redis.h	/^int listTypeEqual(listTypeEntry *entry, robj *o);$/;"	p	signature:(listTypeEntry *entry, robj *o)
listTypeEqual	t_list.c	/^int listTypeEqual(listTypeEntry *entry, robj *o) {$/;"	f	signature:(listTypeEntry *entry, robj *o)
listTypeGet	redis.h	/^robj *listTypeGet(listTypeEntry *entry);$/;"	p	signature:(listTypeEntry *entry)
listTypeGet	t_list.c	/^robj *listTypeGet(listTypeEntry *entry) {$/;"	f	signature:(listTypeEntry *entry)
listTypeInitIterator	redis.h	/^listTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction);$/;"	p	signature:(robj *subject, long index, unsigned char direction)
listTypeInitIterator	t_list.c	/^listTypeIterator *listTypeInitIterator(robj *subject, long index, unsigned char direction) {$/;"	f	signature:(robj *subject, long index, unsigned char direction)
listTypeInsert	redis.h	/^void listTypeInsert(listTypeEntry *entry, robj *value, int where);$/;"	p	signature:(listTypeEntry *entry, robj *value, int where)
listTypeInsert	t_list.c	/^void listTypeInsert(listTypeEntry *entry, robj *value, int where) {$/;"	f	signature:(listTypeEntry *entry, robj *value, int where)
listTypeIterator	redis.h	/^} listTypeIterator;$/;"	t	typeref:struct:__anon18
listTypeLength	redis.h	/^unsigned long listTypeLength(robj *subject);$/;"	p	signature:(robj *subject)
listTypeLength	t_list.c	/^unsigned long listTypeLength(robj *subject) {$/;"	f	signature:(robj *subject)
listTypeNext	redis.h	/^int listTypeNext(listTypeIterator *li, listTypeEntry *entry);$/;"	p	signature:(listTypeIterator *li, listTypeEntry *entry)
listTypeNext	t_list.c	/^int listTypeNext(listTypeIterator *li, listTypeEntry *entry) {$/;"	f	signature:(listTypeIterator *li, listTypeEntry *entry)
listTypePop	redis.h	/^robj *listTypePop(robj *subject, int where);$/;"	p	signature:(robj *subject, int where)
listTypePop	t_list.c	/^robj *listTypePop(robj *subject, int where) {$/;"	f	signature:(robj *subject, int where)
listTypePush	redis.h	/^void listTypePush(robj *subject, robj *value, int where);$/;"	p	signature:(robj *subject, robj *value, int where)
listTypePush	t_list.c	/^void listTypePush(robj *subject, robj *value, int where) {$/;"	f	signature:(robj *subject, robj *value, int where)
listTypeReleaseIterator	redis.h	/^void listTypeReleaseIterator(listTypeIterator *li);$/;"	p	signature:(listTypeIterator *li)
listTypeReleaseIterator	t_list.c	/^void listTypeReleaseIterator(listTypeIterator *li) {$/;"	f	signature:(listTypeIterator *li)
listTypeTryConversion	redis.h	/^void listTypeTryConversion(robj *subject, robj *value);$/;"	p	signature:(robj *subject, robj *value)
listTypeTryConversion	t_list.c	/^void listTypeTryConversion(robj *subject, robj *value) {$/;"	f	signature:(robj *subject, robj *value)
list_max_ziplist_entries	redis.h	/^    size_t list_max_ziplist_entries;$/;"	m	struct:redisServer	access:public
list_max_ziplist_value	redis.h	/^    size_t list_max_ziplist_value;$/;"	m	struct:redisServer	access:public
listenToPort	redis.c	/^int listenToPort(int port, int *fds, int *count) {$/;"	f	signature:(int port, int *fds, int *count)
listenToPort	redis.h	/^int listenToPort(int port, int *fds, int *count);$/;"	p	signature:(int port, int *fds, int *count)
liveclients	redis-benchmark.c	/^    int liveclients;$/;"	m	struct:config	file:	access:public
ll2string	util.c	/^int ll2string(char* dst, size_t dstlen, long long svalue) {$/;"	f	signature:(char* dst, size_t dstlen, long long svalue)
ll2string	util.h	/^int ll2string(char *s, size_t len, long long value);$/;"	p	signature:(char *s, size_t len, long long value)
llenCommand	redis.h	/^void llenCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
llenCommand	t_list.c	/^void llenCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
ln	redis.h	/^    listNode *ln;       \/* Entry in linked list *\/$/;"	m	struct:__anon19	access:public
ln	redis.h	/^    listNode *ln;$/;"	m	struct:__anon18	access:public
loadAppendOnlyFile	aof.c	/^int loadAppendOnlyFile(char *filename) {$/;"	f	signature:(char *filename)
loadAppendOnlyFile	redis.h	/^int loadAppendOnlyFile(char *filename);$/;"	p	signature:(char *filename)
loadDataFromDisk	redis.c	/^void loadDataFromDisk(void) {$/;"	f	signature:(void)
loadDoubleValue	redis-check-dump.c	/^double* loadDoubleValue() {$/;"	f
loadEntry	redis-check-dump.c	/^entry loadEntry() {$/;"	f
loadIntegerObject	redis-check-dump.c	/^char *loadIntegerObject(int enctype) {$/;"	f	signature:(int enctype)
loadLength	redis-check-dump.c	/^uint32_t loadLength(int *isencoded) {$/;"	f	signature:(int *isencoded)
loadLzfStringObject	redis-check-dump.c	/^char* loadLzfStringObject() {$/;"	f
loadPair	redis-check-dump.c	/^int loadPair(entry *e) {$/;"	f	signature:(entry *e)
loadServerConfig	config.c	/^void loadServerConfig(char *filename, char *options) {$/;"	f	signature:(char *filename, char *options)
loadServerConfig	redis.h	/^void loadServerConfig(char *filename, char *options);$/;"	p	signature:(char *filename, char *options)
loadServerConfigFromString	config.c	/^void loadServerConfigFromString(char *config) {$/;"	f	signature:(char *config)
loadStringObject	redis-check-dump.c	/^char* loadStringObject() {$/;"	f
loadType	redis-check-dump.c	/^int loadType(entry *e) {$/;"	f	signature:(entry *e)
load_cluster_info_from_node	redis-trib.rb	/^    def load_cluster_info_from_node(nodeaddr)$/;"	f	class:RedisTrib.alloc_slots
load_info	redis-trib.rb	/^    def load_info(o={})$/;"	f	class:ClusterNode
loading	redis.h	/^    int loading;                \/* We are loading data from disk if true *\/$/;"	m	struct:redisServer	access:public
loadingProgress	rdb.c	/^void loadingProgress(off_t pos) {$/;"	f	signature:(off_t pos)
loadingProgress	redis.h	/^void loadingProgress(off_t pos);$/;"	p	signature:(off_t pos)
loading_loaded_bytes	redis.h	/^    off_t loading_loaded_bytes;$/;"	m	struct:redisServer	access:public
loading_process_events_interval_bytes	redis.h	/^    off_t loading_process_events_interval_bytes;$/;"	m	struct:redisServer	access:public
loading_start_time	redis.h	/^    time_t loading_start_time;$/;"	m	struct:redisServer	access:public
loading_total_bytes	redis.h	/^    off_t loading_total_bytes;$/;"	m	struct:redisServer	access:public
loadingerr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
logCurrentClient	debug.c	/^void logCurrentClient(void) {$/;"	f	signature:(void)
logRegisters	debug.c	/^void logRegisters(ucontext_t *uc) {$/;"	f	signature:(ucontext_t *uc)
logStackContent	debug.c	/^void logStackContent(void **sp) {$/;"	f	signature:(void **sp)
logStackTrace	debug.c	/^void logStackTrace(ucontext_t *uc) {$/;"	f	signature:(ucontext_t *uc)
logfile	redis.h	/^    char *logfile;                  \/* Path of log file *\/$/;"	m	struct:redisServer	access:public
lookupCommand	redis.c	/^struct redisCommand *lookupCommand(sds name) {$/;"	f	signature:(sds name)
lookupCommand	redis.h	/^struct redisCommand *lookupCommand(sds name);$/;"	p	signature:(sds name)
lookupCommandByCString	redis.c	/^struct redisCommand *lookupCommandByCString(char *s) {$/;"	f	signature:(char *s)
lookupCommandByCString	redis.h	/^struct redisCommand *lookupCommandByCString(char *s);$/;"	p	signature:(char *s)
lookupCommandOrOriginal	redis.c	/^struct redisCommand *lookupCommandOrOriginal(sds name) {$/;"	f	signature:(sds name)
lookupCommandOrOriginal	redis.h	/^struct redisCommand *lookupCommandOrOriginal(sds name);$/;"	p	signature:(sds name)
lookupKey	db.c	/^robj *lookupKey(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
lookupKey	redis.h	/^robj *lookupKey(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
lookupKeyByPattern	sort.c	/^robj *lookupKeyByPattern(redisDb *db, robj *pattern, robj *subst) {$/;"	f	signature:(redisDb *db, robj *pattern, robj *subst)
lookupKeyRead	db.c	/^robj *lookupKeyRead(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
lookupKeyRead	redis.h	/^robj *lookupKeyRead(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
lookupKeyReadOrReply	db.c	/^robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f	signature:(redisClient *c, robj *key, robj *reply)
lookupKeyReadOrReply	redis.h	/^robj *lookupKeyReadOrReply(redisClient *c, robj *key, robj *reply);$/;"	p	signature:(redisClient *c, robj *key, robj *reply)
lookupKeyWrite	db.c	/^robj *lookupKeyWrite(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
lookupKeyWrite	redis.h	/^robj *lookupKeyWrite(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
lookupKeyWriteOrReply	db.c	/^robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f	signature:(redisClient *c, robj *key, robj *reply)
lookupKeyWriteOrReply	redis.h	/^robj *lookupKeyWriteOrReply(redisClient *c, robj *key, robj *reply);$/;"	p	signature:(redisClient *c, robj *key, robj *reply)
loop	redis-benchmark.c	/^    int loop;$/;"	m	struct:config	file:	access:public
loop	sentinel.c	/^    aeEventLoop *loop;$/;"	m	struct:redisAeEvents	file:	access:public
lpop	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
lpopCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
lpopCommand	redis.h	/^void lpopCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
lpopCommand	t_list.c	/^void lpopCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lpush	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
lpushCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
lpushCommand	redis.h	/^void lpushCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
lpushCommand	t_list.c	/^void lpushCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lpushxCommand	redis.h	/^void lpushxCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
lpushxCommand	t_list.c	/^void lpushxCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lrangeCommand	redis.h	/^void lrangeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
lrangeCommand	t_list.c	/^void lrangeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lremCommand	redis.h	/^void lremCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
lremCommand	t_list.c	/^void lremCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lru	redis.h	/^    unsigned lru:REDIS_LRU_BITS; \/* lru time (relative to server.lruclock) *\/$/;"	m	struct:redisObject	access:public
lru_test_mode	redis-cli.c	/^    int lru_test_mode;$/;"	m	struct:config	file:	access:public
lru_test_sample_size	redis-cli.c	/^    long long lru_test_sample_size;$/;"	m	struct:config	file:	access:public
lruclock	redis.h	/^    unsigned lruclock:REDIS_LRU_BITS; \/* Clock for LRU eviction *\/$/;"	m	struct:redisServer	access:public
lsetCommand	redis.h	/^void lsetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
lsetCommand	t_list.c	/^void lsetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
ltrimCommand	redis.h	/^void ltrimCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
ltrimCommand	t_list.c	/^void ltrimCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
lua	redis.h	/^    lua_State *lua; \/* The Lua interpreter. We use just one for all clients *\/$/;"	m	struct:redisServer	access:public
luaCreateFunction	scripting.c	/^int luaCreateFunction(redisClient *c, lua_State *lua, char *funcname, robj *body) {$/;"	f	signature:(redisClient *c, lua_State *lua, char *funcname, robj *body)
luaLoadLib	scripting.c	/^void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {$/;"	f	signature:(lua_State *lua, const char *libname, lua_CFunction luafunc)
luaLoadLibraries	scripting.c	/^void luaLoadLibraries(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaLogCommand	scripting.c	/^int luaLogCommand(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaMaskCountHook	scripting.c	/^void luaMaskCountHook(lua_State *lua, lua_Debug *ar) {$/;"	f	signature:(lua_State *lua, lua_Debug *ar)
luaPushError	scripting.c	/^void luaPushError(lua_State *lua, char *error) {$/;"	f	signature:(lua_State *lua, char *error)
luaRedisCallCommand	scripting.c	/^int luaRedisCallCommand(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaRedisErrorReplyCommand	scripting.c	/^int luaRedisErrorReplyCommand(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaRedisGenericCommand	scripting.c	/^int luaRedisGenericCommand(lua_State *lua, int raise_error) {$/;"	f	signature:(lua_State *lua, int raise_error)
luaRedisPCallCommand	scripting.c	/^int luaRedisPCallCommand(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaRedisReturnSingleFieldTable	scripting.c	/^int luaRedisReturnSingleFieldTable(lua_State *lua, char *field) {$/;"	f	signature:(lua_State *lua, char *field)
luaRedisSha1hexCommand	scripting.c	/^int luaRedisSha1hexCommand(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaRedisStatusReplyCommand	scripting.c	/^int luaRedisStatusReplyCommand(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaRemoveUnsupportedFunctions	scripting.c	/^void luaRemoveUnsupportedFunctions(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
luaReplyToRedisReply	scripting.c	/^void luaReplyToRedisReply(redisClient *c, lua_State *lua) {$/;"	f	signature:(redisClient *c, lua_State *lua)
luaSetGlobalArray	scripting.c	/^void luaSetGlobalArray(lua_State *lua, char *var, robj **elev, int elec) {$/;"	f	signature:(lua_State *lua, char *var, robj **elev, int elec)
luaSortArray	scripting.c	/^void luaSortArray(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
lua_caller	redis.h	/^    redisClient *lua_caller;   \/* The client running EVAL right now, or NULL *\/$/;"	m	struct:redisServer	access:public
lua_client	redis.h	/^    redisClient *lua_client;   \/* The "fake client" to query Redis from Lua *\/$/;"	m	struct:redisServer	access:public
lua_kill	redis.h	/^    int lua_kill;         \/* Kill the script if true. *\/$/;"	m	struct:redisServer	access:public
lua_random_dirty	redis.h	/^    int lua_random_dirty; \/* True if a random command was called during the$/;"	m	struct:redisServer	access:public
lua_scripts	redis.h	/^    dict *lua_scripts;         \/* A dictionary of SHA1 -> Lua scripts *\/$/;"	m	struct:redisServer	access:public
lua_time_limit	redis.h	/^    mstime_t lua_time_limit;  \/* Script timeout in milliseconds *\/$/;"	m	struct:redisServer	access:public
lua_time_start	redis.h	/^    mstime_t lua_time_start;  \/* Start time of script, milliseconds time *\/$/;"	m	struct:redisServer	access:public
lua_timedout	redis.h	/^    int lua_timedout;     \/* True if we reached the time limit for script$/;"	m	struct:redisServer	access:public
lua_write_dirty	redis.h	/^    int lua_write_dirty;  \/* True if a write command was called during the$/;"	m	struct:redisServer	access:public
luaopen_bit	scripting.c	/^LUALIB_API int (luaopen_bit) (lua_State *L);$/;"	p	file:	signature:(lua_State *L)
luaopen_cjson	scripting.c	/^LUALIB_API int (luaopen_cjson) (lua_State *L);$/;"	p	file:	signature:(lua_State *L)
luaopen_cmsgpack	scripting.c	/^LUALIB_API int (luaopen_cmsgpack) (lua_State *L);$/;"	p	file:	signature:(lua_State *L)
luaopen_struct	scripting.c	/^LUALIB_API int (luaopen_struct) (lua_State *L);$/;"	p	file:	signature:(lua_State *L)
lzf.h	lzf.h	1;"	F
lzfP.h	lzfP.h	1;"	F
lzf_c.c	lzf_c.c	1;"	F
lzf_compress	lzf.h	/^lzf_compress (const void *const in_data,  unsigned int in_len,$/;"	p	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
lzf_compress	lzf_c.c	/^lzf_compress (const void *const in_data, unsigned int in_len,$/;"	f	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len , LZF_STATE htab )
lzf_d.c	lzf_d.c	1;"	F
lzf_decompress	lzf.h	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	p	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
lzf_decompress	lzf_d.c	/^lzf_decompress (const void *const in_data,  unsigned int in_len,$/;"	f	signature:(const void *const in_data, unsigned int in_len, void *out_data, unsigned int out_len)
mad	latency.h	/^    uint32_t mad;           \/* Mean absolute deviation. *\/$/;"	m	struct:latencyStats	access:public
magic	hyperloglog.c	/^    char magic[4];      \/* "HYLL" *\/$/;"	m	struct:hllhdr	file:	access:public
main	crc64.c	/^int main(void) {$/;"	f	signature:(void)
main	endianconv.c	/^int main(void) {$/;"	f	signature:(void)
main	intset.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	redis-benchmark.c	/^int main(int argc, const char **argv) {$/;"	f	signature:(int argc, const char **argv)
main	redis-check-aof.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	redis-check-dump.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	redis-cli.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	redis.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	sds.c	/^int main(void) {$/;"	f	signature:(void)
main	util.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	ziplist.c	/^int main(int argc, char **argv) {$/;"	f	signature:(int argc, char **argv)
main	zipmap.c	/^int main(void) {$/;"	f	signature:(void)
malloc	redis.h	/^void *malloc(size_t size) __attribute__ ((deprecated));$/;"	p	signature:(size_t size)
malloc	zmalloc.c	/^#define malloc(/;"	d	file:
manualFailoverCheckTimeout	cluster.c	/^void manualFailoverCheckTimeout(void) {$/;"	f	signature:(void)
markNodeAsFailingIfNeeded	cluster.c	/^void markNodeAsFailingIfNeeded(clusterNode *node) {$/;"	f	signature:(clusterNode *node)
mask	ae.h	/^    int mask; \/* one of AE_(READABLE|WRITABLE) *\/$/;"	m	struct:aeFileEvent	access:public
mask	ae.h	/^    int mask;$/;"	m	struct:aeFiredEvent	access:public
master	redis.h	/^    redisClient *master;     \/* Client that is master for this slave *\/$/;"	m	struct:redisServer	access:public
master	sentinel.c	/^    struct sentinelRedisInstance *master; \/* Master instance if it's slave. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
masterTryPartialResynchronization	replication.c	/^int masterTryPartialResynchronization(redisClient *c) {$/;"	f	signature:(redisClient *c)
master_link_down_time	sentinel.c	/^    mstime_t master_link_down_time; \/* Slave replication link down time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
master_repl_offset	redis.h	/^    long long master_repl_offset;   \/* Global replication offset *\/$/;"	m	struct:redisServer	access:public
masterauth	redis.h	/^    char *masterauth;               \/* AUTH with this password with master *\/$/;"	m	struct:redisServer	access:public
masterdownerr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
masterhost	redis.h	/^    char *masterhost;               \/* Hostname of master *\/$/;"	m	struct:redisServer	access:public
masterport	redis.h	/^    int masterport;                 \/* Port of master *\/$/;"	m	struct:redisServer	access:public
masters	sentinel.c	/^    dict *masters;      \/* Dictionary of master sentinelRedisInstances.$/;"	m	struct:sentinelState	file:	access:public
match	adlist.h	/^    int (*match)(void *ptr, void *key);$/;"	m	struct:list	access:public
max	latency.h	/^    uint32_t max;           \/* Max of current samples. *\/$/;"	m	struct:latencyStats	access:public
max	latency.h	/^    uint32_t max; \/* Max latency observed for this event. *\/$/;"	m	struct:latencyTimeSeries	access:public
max	redis-cli.c	/^    long long max;   \/* Max latency to fit into this interval (usec). *\/$/;"	m	struct:distsamples	file:	access:public
max	redis.h	/^    double min, max;$/;"	m	struct:__anon22	access:public
max	redis.h	/^    robj *min, *max;  \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon23	access:public
max	sparkline.h	/^    double min, max;$/;"	m	struct:sequence	access:public
max_processing_chunk	rio.h	/^    size_t max_processing_chunk;$/;"	m	struct:_rio	access:public
maxclients	redis.h	/^    unsigned int maxclients;            \/* Max number of simultaneous clients *\/$/;"	m	struct:redisServer	access:public
maxex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon22	access:public
maxex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon23	access:public
maxfd	ae.h	/^    int maxfd;   \/* highest file descriptor currently registered *\/$/;"	m	struct:aeEventLoop	access:public
maxidletime	redis.h	/^    int maxidletime;                \/* Client timeout in seconds *\/$/;"	m	struct:redisServer	access:public
maxmemory	redis.h	/^    unsigned long long maxmemory;   \/* Max number of memory bytes to use *\/$/;"	m	struct:redisServer	access:public
maxmemory_policy	redis.h	/^    int maxmemory_policy;           \/* Policy for key eviction *\/$/;"	m	struct:redisServer	access:public
maxmemory_samples	redis.h	/^    int maxmemory_samples;          \/* Pricision of random sampling *\/$/;"	m	struct:redisServer	access:public
maxstring	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
mb_delim	redis-cli.c	/^    sds mb_delim;$/;"	m	struct:config	file:	access:public
mbulkhdr	redis.h	/^    *mbulkhdr[REDIS_SHARED_BULKHDR_LEN], \/* "*<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct	access:public
med3	pqsort.c	/^med3(char *a, char *b, char *c,$/;"	f	file:	signature:(char *a, char *b, char *c, int (*cmp) (const void *, const void *))
med3	pqsort.c	/^static inline char	*med3 (char *, char *, char *,$/;"	p	file:	signature:(char *, char *, char *, int (*)(const void *, const void *))
memrev16	endianconv.c	/^void memrev16(void *p) {$/;"	f	signature:(void *p)
memrev16	endianconv.h	/^void memrev16(void *p);$/;"	p	signature:(void *p)
memrev16ifbe	endianconv.h	/^#define memrev16ifbe(/;"	d
memrev32	endianconv.c	/^void memrev32(void *p) {$/;"	f	signature:(void *p)
memrev32	endianconv.h	/^void memrev32(void *p);$/;"	p	signature:(void *p)
memrev32ifbe	endianconv.h	/^#define memrev32ifbe(/;"	d
memrev64	endianconv.c	/^void memrev64(void *p) {$/;"	f	signature:(void *p)
memrev64	endianconv.h	/^void memrev64(void *p);$/;"	p	signature:(void *p)
memrev64ifbe	endianconv.h	/^#define memrev64ifbe(/;"	d
memtest	memtest.c	/^void memtest(size_t megabytes, int passes) {$/;"	f	signature:(size_t megabytes, int passes)
memtest	redis.c	/^void memtest(size_t megabytes, int passes);$/;"	p	file:	signature:(size_t megabytes, int passes)
memtest.c	memtest.c	1;"	F
memtest_addressing	memtest.c	/^void memtest_addressing(unsigned long *l, size_t bytes) {$/;"	f	signature:(unsigned long *l, size_t bytes)
memtest_compare	memtest.c	/^void memtest_compare(unsigned long *l, size_t bytes) {$/;"	f	signature:(unsigned long *l, size_t bytes)
memtest_compare_times	memtest.c	/^void memtest_compare_times(unsigned long *m, size_t bytes, int pass, int times) {$/;"	f	signature:(unsigned long *m, size_t bytes, int pass, int times)
memtest_fill_random	memtest.c	/^void memtest_fill_random(unsigned long *l, size_t bytes) {$/;"	f	signature:(unsigned long *l, size_t bytes)
memtest_fill_value	memtest.c	/^void memtest_fill_value(unsigned long *l, size_t bytes, unsigned long v1,$/;"	f	signature:(unsigned long *l, size_t bytes, unsigned long v1, unsigned long v2, char sym)
memtest_non_destructive_invert	debug.c	/^void memtest_non_destructive_invert(void *addr, size_t size);$/;"	p	file:	signature:(void *addr, size_t size)
memtest_non_destructive_invert	memtest.c	/^void memtest_non_destructive_invert(void *addr, size_t size) {$/;"	f	signature:(void *addr, size_t size)
memtest_non_destructive_swap	debug.c	/^void memtest_non_destructive_swap(void *addr, size_t size);$/;"	p	file:	signature:(void *addr, size_t size)
memtest_non_destructive_swap	memtest.c	/^void memtest_non_destructive_swap(void *addr, size_t size) {$/;"	f	signature:(void *addr, size_t size)
memtest_progress_end	memtest.c	/^void memtest_progress_end(void) {$/;"	f	signature:(void)
memtest_progress_start	memtest.c	/^void memtest_progress_start(char *title, int pass) {$/;"	f	signature:(char *title, int pass)
memtest_progress_step	memtest.c	/^void memtest_progress_step(size_t curr, size_t size, char c) {$/;"	f	signature:(size_t curr, size_t size, char c)
memtest_test	memtest.c	/^void memtest_test(size_t megabytes, int passes) {$/;"	f	signature:(size_t megabytes, int passes)
memtest_test_linux_anonymous_maps	debug.c	/^int memtest_test_linux_anonymous_maps(void) {$/;"	f	signature:(void)
memtoll	util.c	/^long long memtoll(const char *p, int *err) {$/;"	f	signature:(const char *p, int *err)
memtoll	util.h	/^long long memtoll(const char *p, int *err);$/;"	p	signature:(const char *p, int *err)
message_len	cluster.h	/^    uint32_t message_len;$/;"	m	struct:__anon3	access:public
messagebulk	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
mf_can_start	cluster.h	/^    int mf_can_start;           \/* If non-zero signal that the manual failover$/;"	m	struct:clusterState	access:public
mf_end	cluster.h	/^    mstime_t mf_end;            \/* Manual failover time limit (ms unixtime).$/;"	m	struct:clusterState	access:public
mf_master_offset	cluster.h	/^    long long mf_master_offset; \/* Master offset the slave needs to start MF$/;"	m	struct:clusterState	access:public
mf_slave	cluster.h	/^    clusterNode *mf_slave;      \/* Slave performing the manual failover. *\/$/;"	m	struct:clusterState	access:public
mflags	cluster.h	/^    unsigned char mflags[3]; \/* Message flags: CLUSTERMSG_FLAG[012]_... *\/$/;"	m	struct:__anon9	access:public
mgetCommand	redis.h	/^void mgetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
mgetCommand	t_string.c	/^void mgetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
microseconds	redis.h	/^    long long microseconds, calls;$/;"	m	struct:redisCommand	access:public
migrateCacheDictType	redis.c	/^dictType migrateCacheDictType = {$/;"	v
migrateCachedSocket	cluster.c	/^typedef struct migrateCachedSocket {$/;"	s	file:
migrateCachedSocket	cluster.c	/^} migrateCachedSocket;$/;"	t	typeref:struct:migrateCachedSocket	file:
migrateCachedSocket::fd	cluster.c	/^    int fd;$/;"	m	struct:migrateCachedSocket	file:	access:public
migrateCachedSocket::last_dbid	cluster.c	/^    long last_dbid;$/;"	m	struct:migrateCachedSocket	file:	access:public
migrateCachedSocket::last_use_time	cluster.c	/^    time_t last_use_time;$/;"	m	struct:migrateCachedSocket	file:	access:public
migrateCloseSocket	cluster.c	/^void migrateCloseSocket(robj *host, robj *port) {$/;"	f	signature:(robj *host, robj *port)
migrateCloseTimedoutSockets	cluster.c	/^void migrateCloseTimedoutSockets(void) {$/;"	f	signature:(void)
migrateCloseTimedoutSockets	redis.h	/^void migrateCloseTimedoutSockets(void);$/;"	p	signature:(void)
migrateCommand	cluster.c	/^void migrateCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
migrateCommand	redis.h	/^void migrateCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
migrateGetSocket	cluster.c	/^migrateCachedSocket* migrateGetSocket(redisClient *c, robj *host, robj *port, long timeout) {$/;"	f	signature:(redisClient *c, robj *host, robj *port, long timeout)
migrate_cached_sockets	redis.h	/^    dict *migrate_cached_sockets;\/* MIGRATE cached sockets *\/$/;"	m	struct:redisServer	access:public
migrating_slots_to	cluster.h	/^    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];$/;"	m	struct:clusterState	access:public
min	latency.h	/^    uint32_t min;           \/* Min of current samples. *\/$/;"	m	struct:latencyStats	access:public
min	pqsort.c	/^#define min(/;"	d	file:
min	redis.h	/^    double min, max;$/;"	m	struct:__anon22	access:public
min	redis.h	/^    robj *min, *max;  \/* May be set to shared.(minstring|maxstring) *\/$/;"	m	struct:__anon23	access:public
min	sparkline.h	/^    double min, max;$/;"	m	struct:sequence	access:public
minex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon22	access:public
minex	redis.h	/^    int minex, maxex; \/* are min or max exclusive? *\/$/;"	m	struct:__anon23	access:public
minreplicas	redis.h	/^    int minreplicas;        \/* MINREPLICAS for synchronous replication *\/$/;"	m	struct:multiState	access:public
minreplicas_timeout	redis.h	/^    time_t minreplicas_timeout; \/* MINREPLICAS timeout as unixtime. *\/$/;"	m	struct:multiState	access:public
minstring	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
mixDigest	debug.c	/^void mixDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f	signature:(unsigned char *digest, void *ptr, size_t len)
mixObjectDigest	debug.c	/^void mixObjectDigest(unsigned char *digest, robj *o) {$/;"	f	signature:(unsigned char *digest, robj *o)
mkreleasehdr.sh	mkreleasehdr.sh	1;"	F
monitorCommand	redis.c	/^void monitorCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
monitorCommand	redis.h	/^void monitorCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
monitor_mode	redis-cli.c	/^    int monitor_mode;$/;"	m	struct:config	file:	access:public
monitors	redis.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer	access:public
moveCommand	db.c	/^void moveCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
moveCommand	redis.h	/^void moveCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
move_slot	redis-trib.rb	/^    def move_slot(source,target,slot,o={})$/;"	f	class:RedisTrib.alloc_slots
msetCommand	redis.h	/^void msetCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
msetCommand	t_string.c	/^void msetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
msetGenericCommand	t_string.c	/^void msetGenericCommand(redisClient *c, int nx) {$/;"	f	signature:(redisClient *c, int nx)
msetnxCommand	redis.h	/^void msetnxCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
msetnxCommand	t_string.c	/^void msetnxCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
msg	cluster.h	/^        clusterMsgDataPublish msg;$/;"	m	struct:clusterMsgData::__anon7	access:public
mstate	redis.h	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	struct:redisClient	access:public
mstime	redis-benchmark.c	/^static long long mstime(void) {$/;"	f	file:	signature:(void)
mstime	redis-cli.c	/^static long long mstime(void) {$/;"	f	file:	signature:(void)
mstime	redis.c	/^long long mstime(void) {$/;"	f	signature:(void)
mstime	redis.h	/^    long long mstime;       \/* Like 'unixtime' but with milliseconds resolution. *\/$/;"	m	struct:redisServer	access:public
mstime	redis.h	/^long long mstime(void);$/;"	p	signature:(void)
mstime_t	redis.h	/^typedef long long mstime_t; \/* millisecond time type. *\/$/;"	t
multi.c	multi.c	1;"	F
multiCmd	redis.h	/^typedef struct multiCmd {$/;"	s
multiCmd	redis.h	/^} multiCmd;$/;"	t	typeref:struct:multiCmd
multiCmd::argc	redis.h	/^    int argc;$/;"	m	struct:multiCmd	access:public
multiCmd::argv	redis.h	/^    robj **argv;$/;"	m	struct:multiCmd	access:public
multiCmd::cmd	redis.h	/^    struct redisCommand *cmd;$/;"	m	struct:multiCmd	typeref:struct:multiCmd::redisCommand	access:public
multiCommand	multi.c	/^void multiCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
multiCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
multiCommand	redis.h	/^void multiCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
multiState	redis.h	/^typedef struct multiState {$/;"	s
multiState	redis.h	/^} multiState;$/;"	t	typeref:struct:multiState
multiState::commands	redis.h	/^    multiCmd *commands;     \/* Array of MULTI commands *\/$/;"	m	struct:multiState	access:public
multiState::count	redis.h	/^    int count;              \/* Total number of MULTI commands *\/$/;"	m	struct:multiState	access:public
multiState::minreplicas	redis.h	/^    int minreplicas;        \/* MINREPLICAS for synchronous replication *\/$/;"	m	struct:multiState	access:public
multiState::minreplicas_timeout	redis.h	/^    time_t minreplicas_timeout; \/* MINREPLICAS timeout as unixtime. *\/$/;"	m	struct:multiState	access:public
multibulklen	redis.h	/^    int multibulklen;       \/* number of multi bulk arguments left to read *\/$/;"	m	struct:redisClient	access:public
myself	cluster.c	/^clusterNode *myself = NULL;$/;"	v
myself	cluster.h	/^    clusterNode *myself;  \/* This node *\/$/;"	m	struct:clusterState	access:public
myslots	cluster.h	/^    unsigned char myslots[REDIS_CLUSTER_SLOTS\/8];$/;"	m	struct:__anon9	access:public
name	cluster.c	/^    char *name;$/;"	m	struct:redisNodeFlags	file:	access:public
name	cluster.h	/^    char name[REDIS_CLUSTER_NAMELEN]; \/* Node name, hex string, sha1-size *\/$/;"	m	struct:clusterNode	access:public
name	config.c	/^    const char     *name;$/;"	m	struct:__anon10	file:	access:public
name	help.h	/^  char *name;$/;"	m	struct:commandHelp	access:public
name	redis.h	/^    char *name;$/;"	m	struct:redisCommand	access:public
name	redis.h	/^    char *name;$/;"	m	struct:redisFunctionSym	access:public
name	redis.h	/^    robj *name;             \/* As set by CLIENT SETNAME *\/$/;"	m	struct:redisClient	access:public
name	sentinel.c	/^    char *name;     \/* Master name from the point of view of this sentinel. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
neterr	redis.h	/^    char neterr[ANET_ERR_LEN];   \/* Error buffer for anet.c *\/$/;"	m	struct:redisServer	access:public
networking.c	networking.c	1;"	F
next	adlist.h	/^    listNode *next;$/;"	m	struct:listIter	access:public
next	adlist.h	/^    struct listNode *next;$/;"	m	struct:listNode	typeref:struct:listNode::listNode	access:public
next	ae.h	/^    struct aeTimeEvent *next;$/;"	m	struct:aeTimeEvent	typeref:struct:aeTimeEvent::aeTimeEvent	access:public
next	dict.h	/^    struct dictEntry *next;$/;"	m	struct:dictEntry	typeref:struct:dictEntry::dictEntry	access:public
next	rand.c	/^static void next(void) {$/;"	f	file:	signature:(void)
next	rand.c	/^static void next(void);$/;"	p	file:	signature:(void)
nextEntry	dict.h	/^    dictEntry *entry, *nextEntry;$/;"	m	struct:dictIterator	access:public
next_client_id	redis.h	/^    uint64_t next_client_id;    \/* Next client unique ID. Incremental. *\/$/;"	m	struct:redisServer	access:public
noautherr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
node	cluster.h	/^    struct clusterNode *node;   \/* Node related to this link if any, or NULL *\/$/;"	m	struct:clusterLink	typeref:struct:clusterLink::clusterNode	access:public
node	cluster.h	/^    struct clusterNode *node;  \/* Node reporting the failure condition. *\/$/;"	m	struct:clusterNodeFailReport	typeref:struct:clusterNodeFailReport::clusterNode	access:public
node	t_zset.c	/^                zskiplistNode *node;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon35	file:	access:public
nodeFailed	cluster.h	/^#define nodeFailed(/;"	d
nodeHasAddr	cluster.h	/^#define nodeHasAddr(/;"	d
nodeInHandshake	cluster.h	/^#define nodeInHandshake(/;"	d
nodeIp2String	cluster.c	/^void nodeIp2String(char *buf, clusterLink *link) {$/;"	f	signature:(char *buf, clusterLink *link)
nodeIsMaster	cluster.h	/^#define nodeIsMaster(/;"	d
nodeIsSlave	cluster.h	/^#define nodeIsSlave(/;"	d
nodeTimedOut	cluster.h	/^#define nodeTimedOut(/;"	d
nodeUpdateAddressIfNeeded	cluster.c	/^int nodeUpdateAddressIfNeeded(clusterNode *node, clusterLink *link, int port) {$/;"	f	signature:(clusterNode *node, clusterLink *link, int port)
nodeWithoutAddr	cluster.h	/^#define nodeWithoutAddr(/;"	d
nodecfg	cluster.h	/^        clusterMsgDataUpdate nodecfg;$/;"	m	struct:clusterMsgData::__anon8	access:public
nodename	cluster.h	/^    char nodename[REDIS_CLUSTER_NAMELEN]; \/* Name of the slots owner. *\/$/;"	m	struct:__anon4	access:public
nodename	cluster.h	/^    char nodename[REDIS_CLUSTER_NAMELEN];$/;"	m	struct:__anon1	access:public
nodename	cluster.h	/^    char nodename[REDIS_CLUSTER_NAMELEN];$/;"	m	struct:__anon2	access:public
nodes	cluster.h	/^    dict *nodes;          \/* Hash table of name -> clusterNode structures *\/$/;"	m	struct:clusterState	access:public
nodes_black_list	cluster.h	/^    dict *nodes_black_list; \/* Nodes we don't re-add for a few seconds. *\/$/;"	m	struct:clusterState	access:public
nodes_with_keys_in_slot	redis-trib.rb	/^    def nodes_with_keys_in_slot(slot)$/;"	f	class:RedisTrib
nokeyerr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
noninteractive	redis-cli.c	/^static int noninteractive(int argc, char **argv) {$/;"	f	file:	signature:(int argc, char **argv)
noreplicaserr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
noscripterr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
notification_script	sentinel.c	/^    char *notification_script;$/;"	m	struct:sentinelRedisInstance	file:	access:public
notify.c	notify.c	1;"	F
notifyKeyspaceEvent	notify.c	/^void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {$/;"	f	signature:(int type, char *event, robj *key, int dbid)
notifyKeyspaceEvent	redis.h	/^void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid);$/;"	p	signature:(int type, char *event, robj *key, int dbid)
notify_keyspace_events	redis.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	struct:redisServer	access:public
notused	hyperloglog.c	/^    uint8_t notused[3]; \/* Reserved for future use, must be zero. *\/$/;"	m	struct:hllhdr	file:	access:public
notused0	cluster.h	/^    uint16_t notused0;  \/* 2 bytes not used. *\/$/;"	m	struct:__anon9	access:public
notused1	cluster.h	/^    char notused1[32];  \/* 32 bytes reserved for future usage. *\/$/;"	m	struct:__anon9	access:public
notused1	cluster.h	/^    uint16_t notused1;          \/* Some room for future improvements. *\/$/;"	m	struct:__anon1	access:public
notused2	cluster.h	/^    uint32_t notused2;$/;"	m	struct:__anon1	access:public
npending	ae_evport.c	/^    int     npending;                           \/* # of pending fds *\/$/;"	m	struct:aeApiState	file:	access:public
ntohu64	endianconv.h	/^#define ntohu64(/;"	d
nul	setproctitle.c	/^	char *nul;$/;"	m	struct:__anon28	file:	access:public
nullbulk	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
nullmultibulk	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
numclients	redis-benchmark.c	/^    int numclients;$/;"	m	struct:config	file:	access:public
numfds	rio.h	/^            int numfds;$/;"	m	struct:_rio::__anon24::__anon27	access:public
numlines	config.c	/^    int numlines;         \/* Number of lines in current config *\/$/;"	m	struct:rewriteConfigState	file:	access:public
numops	redis.h	/^    int numops;$/;"	m	struct:redisOpArray	access:public
numreplicas	redis.h	/^    int numreplicas;        \/* Number of replicas we are waiting for ACK. *\/$/;"	m	struct:blockingState	access:public
numslaves	cluster.h	/^    int numslaves;  \/* Number of slave nodes, if this is a master *\/$/;"	m	struct:clusterNode	access:public
numslots	cluster.h	/^    int numslots;   \/* Number of slots handled by this node *\/$/;"	m	struct:clusterNode	access:public
o_down_since_time	sentinel.c	/^    mstime_t o_down_since_time; \/* Objectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
obj	redis.h	/^    robj *obj;$/;"	m	struct:_redisSortObject	access:public
obj	redis.h	/^    robj *obj;$/;"	m	struct:zskiplistNode	access:public
object.c	object.c	1;"	F
objectCommand	object.c	/^void objectCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
objectCommand	redis.h	/^void objectCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
objectCommandLookup	object.c	/^robj *objectCommandLookup(redisClient *c, robj *key) {$/;"	f	signature:(redisClient *c, robj *key)
objectCommandLookupOrReply	object.c	/^robj *objectCommandLookupOrReply(redisClient *c, robj *key, robj *reply) {$/;"	f	signature:(redisClient *c, robj *key, robj *reply)
obuf	redis-benchmark.c	/^    sds obuf;$/;"	m	struct:_client	file:	access:public
obuf_soft_limit_reached_time	redis.h	/^    time_t obuf_soft_limit_reached_time;$/;"	m	struct:redisClient	access:public
offset	cluster.h	/^    uint64_t offset;    \/* Master replication offset if node is a master or$/;"	m	struct:__anon9	access:public
offset	redis-check-dump.c	/^    size_t offset;$/;"	m	struct:__anon12	file:	access:public
offset	redis-check-dump.c	/^    size_t offset[16];$/;"	m	struct:__anon13	file:	access:public
ok	intset.c	/^void ok(void) {$/;"	f	signature:(void)
ok	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
oom	redis.h	/^void oom(const char *msg);$/;"	p	signature:(const char *msg)
oomerr	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
ops	redis.h	/^    redisOp *ops;$/;"	m	struct:redisOpArray	access:public
optionSetDictType	config.c	/^dictType optionSetDictType = {$/;"	v
optionToLineDictType	config.c	/^dictType optionToLineDictType = {$/;"	v
option_to_line	config.c	/^    dict *option_to_line; \/* Option -> list of config file lines map *\/$/;"	m	struct:rewriteConfigState	file:	access:public
org	redis-cli.c	/^    struct commandHelp *org;$/;"	m	struct:__anon15	typeref:struct:__anon15::commandHelp	file:	access:public
orig_commands	redis.h	/^    dict *orig_commands;        \/* Command table before command renaming. *\/$/;"	m	struct:redisServer	access:public
outofrangeerr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
output	redis-cli.c	/^    int output; \/* output mode, see OUTPUT_* defines *\/$/;"	m	struct:config	file:	access:public
p	ziplist.c	/^    unsigned char *p;$/;"	m	struct:zlentry	file:	access:public
parallel_syncs	sentinel.c	/^    int parallel_syncs; \/* How many slaves to reconfigure at same time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
params	help.h	/^  char *params;$/;"	m	struct:commandHelp	access:public
parseOptions	redis-benchmark.c	/^int parseOptions(int argc, const char **argv) {$/;"	f	signature:(int argc, const char **argv)
parseOptions	redis-cli.c	/^static int parseOptions(int argc, char **argv) {$/;"	f	file:	signature:(int argc, char **argv)
parseScanCursorOrReply	db.c	/^int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor) {$/;"	f	signature:(redisClient *c, robj *o, unsigned long *cursor)
parseScanCursorOrReply	redis.h	/^int parseScanCursorOrReply(redisClient *c, robj *o, unsigned long *cursor);$/;"	p	signature:(redisClient *c, robj *o, unsigned long *cursor)
parse_options	redis-trib.rb	/^    def parse_options(cmd)$/;"	f	class:RedisTrib.alloc_slots
pathIsBaseName	util.c	/^int pathIsBaseName(char *path) {$/;"	f	signature:(char *path)
pathIsBaseName	util.h	/^int pathIsBaseName(char *path);$/;"	p	signature:(char *path)
pattern	redis-cli.c	/^    char *pattern;$/;"	m	struct:config	file:	access:public
pattern	redis.h	/^    robj *pattern;$/;"	m	struct:_redisSortOperation	access:public
pattern	redis.h	/^    robj *pattern;$/;"	m	struct:pubsubPattern	access:public
pauseClients	networking.c	/^void pauseClients(mstime_t end) {$/;"	f	signature:(mstime_t end)
pauseClients	redis.h	/^void pauseClients(mstime_t duration);$/;"	p	signature:(mstime_t duration)
pc	sentinel.c	/^    redisAsyncContext *pc; \/* Hiredis context for Pub \/ Sub. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
pc_conn_time	sentinel.c	/^    mstime_t pc_conn_time; \/* pc connection time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
pc_last_activity	sentinel.c	/^    mstime_t pc_last_activity; \/* Last time we received any message. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
peekType	redis-check-dump.c	/^int peekType() {$/;"	f
peerid	redis.h	/^    sds peerid;             \/* Cached peer ID. *\/$/;"	m	struct:redisClient	access:public
pending	redis-benchmark.c	/^    int pending;            \/* Number of pending requests (replies to consume) *\/$/;"	m	struct:_client	file:	access:public
pending_commands	sentinel.c	/^    int pending_commands;   \/* Number of commands sent waiting for a reply. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
pending_fds	ae_evport.c	/^    int     pending_fds[MAX_EVENT_BATCHSZ];     \/* pending fds *\/$/;"	m	struct:aeApiState	file:	access:public
pending_masks	ae_evport.c	/^    int     pending_masks[MAX_EVENT_BATCHSZ];   \/* pending fds' masks *\/$/;"	m	struct:aeApiState	file:	access:public
period	latency.h	/^    time_t period;          \/* Number of seconds since first event and now. *\/$/;"	m	struct:latencyStats	access:public
persistCommand	db.c	/^void persistCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
persistCommand	redis.h	/^void persistCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pexpireCommand	db.c	/^void pexpireCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pexpireCommand	redis.h	/^void pexpireCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pexpireatCommand	db.c	/^void pexpireatCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pexpireatCommand	redis.h	/^void pexpireatCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pfaddCommand	hyperloglog.c	/^void pfaddCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pfaddCommand	redis.h	/^void pfaddCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pfcountCommand	hyperloglog.c	/^void pfcountCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pfcountCommand	redis.h	/^void pfcountCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pfdebugCommand	hyperloglog.c	/^void pfdebugCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pfdebugCommand	redis.h	/^void pfdebugCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pfmergeCommand	hyperloglog.c	/^void pfmergeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pfmergeCommand	redis.h	/^void pfmergeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pfselftestCommand	hyperloglog.c	/^void pfselftestCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pfselftestCommand	redis.h	/^void pfselftestCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pid	redis.h	/^    pid_t pid;                  \/* Main process pid. *\/$/;"	m	struct:redisServer	access:public
pid	sentinel.c	/^    pid_t pid;              \/* Script execution pid. *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
pidfile	redis.h	/^    char *pidfile;              \/* PID file path *\/$/;"	m	struct:redisServer	access:public
ping	cluster.h	/^    } ping;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon5	access:public
pingCommand	redis.c	/^void pingCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pingCommand	redis.h	/^void pingCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
ping_sent	cluster.h	/^    mstime_t ping_sent;      \/* Unix time we sent latest ping *\/$/;"	m	struct:clusterNode	access:public
ping_sent	cluster.h	/^    uint32_t ping_sent;$/;"	m	struct:__anon1	access:public
pipeMode	redis-cli.c	/^static void pipeMode(void) {$/;"	f	file:	signature:(void)
pipe_mode	redis-cli.c	/^    int pipe_mode;$/;"	m	struct:config	file:	access:public
pipe_timeout	redis-cli.c	/^    int pipe_timeout;$/;"	m	struct:config	file:	access:public
pipeline	redis-benchmark.c	/^    int pipeline;$/;"	m	struct:config	file:	access:public
plus	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
pmessagebulk	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
pointer	redis.h	/^    unsigned long pointer;$/;"	m	struct:redisFunctionSym	access:public
pong	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
pong_received	cluster.h	/^    mstime_t pong_received;  \/* Unix time we received the pong *\/$/;"	m	struct:clusterNode	access:public
pong_received	cluster.h	/^    uint32_t pong_received;$/;"	m	struct:__anon1	access:public
pop	ziplist.c	/^void pop(unsigned char *zl, int where) {$/;"	f	signature:(unsigned char *zl, int where)
popGenericCommand	redis.h	/^void popGenericCommand(redisClient *c, int where);$/;"	p	signature:(redisClient *c, int where)
popGenericCommand	t_list.c	/^void popGenericCommand(redisClient *c, int where) {$/;"	f	signature:(redisClient *c, int where)
populateCommandTable	redis.c	/^void populateCommandTable(void) {$/;"	f	signature:(void)
populateCommandTable	redis.h	/^void populateCommandTable(void);$/;"	p	signature:(void)
populate_nodes_replicas_info	redis-trib.rb	/^    def populate_nodes_replicas_info$/;"	f	class:RedisTrib.alloc_slots
port	cluster.h	/^    int port;                   \/* Latest known port of this node *\/$/;"	m	struct:clusterNode	access:public
port	cluster.h	/^    uint16_t port;              \/* port last time it was seen *\/$/;"	m	struct:__anon1	access:public
port	cluster.h	/^    uint16_t port;      \/* Sender TCP base port *\/$/;"	m	struct:__anon9	access:public
port	redis.h	/^    int port;                   \/* TCP listening port *\/$/;"	m	struct:redisServer	access:public
port	sentinel.c	/^    int port;$/;"	m	struct:sentinelAddr	file:	access:public
portfd	ae_evport.c	/^    int     portfd;                             \/* event port *\/$/;"	m	struct:aeApiState	file:	access:public
pos	redis-check-dump.c	/^} pos;$/;"	t	typeref:struct:__anon12	file:
pos	rio.h	/^            off_t pos;$/;"	m	struct:_rio::__anon24::__anon25	access:public
pos	rio.h	/^            off_t pos;$/;"	m	struct:_rio::__anon24::__anon27	access:public
positions	redis-check-dump.c	/^static pos positions[16];$/;"	v	file:
powerLawRand	redis-cli.c	/^long long powerLawRand(long long min, long long max, double alpha) {$/;"	f	signature:(long long min, long long max, double alpha)
pqsort	pqsort.c	/^pqsort(void *a, size_t n, size_t es,$/;"	f	signature:(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
pqsort	pqsort.h	/^pqsort(void *a, size_t n, size_t es,$/;"	p	signature:(void *a, size_t n, size_t es, int (*cmp) (const void *, const void *), size_t lrange, size_t rrange)
pqsort.c	pqsort.c	1;"	F
pqsort.h	pqsort.h	1;"	F
prefix_pending	redis-benchmark.c	/^    int prefix_pending;     \/* If non-zero, number of pending prefix commands. Commands$/;"	m	struct:_client	file:	access:public
prefixlen	redis-benchmark.c	/^    int prefixlen;          \/* Size in bytes of the pending prefix commands *\/$/;"	m	struct:_client	file:	access:public
prepareClientToWrite	networking.c	/^int prepareClientToWrite(redisClient *c) {$/;"	f	signature:(redisClient *c)
prepareForShutdown	redis.c	/^int prepareForShutdown(int flags) {$/;"	f	signature:(int flags)
prepareForShutdown	redis.h	/^int prepareForShutdown();$/;"	p	signature:()
prev	adlist.h	/^    struct listNode *prev;$/;"	m	struct:listNode	typeref:struct:listNode::listNode	access:public
previous_time	sentinel.c	/^    mstime_t previous_time;     \/* Last time we ran the time handler. *\/$/;"	m	struct:sentinelState	file:	access:public
prevrawlen	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:	access:public
prevrawlensize	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:	access:public
printCentered	redis-check-dump.c	/^void printCentered(int indent, int width, char* body) {$/;"	f	signature:(int indent, int width, char* body)
printErrorStack	redis-check-dump.c	/^void printErrorStack(entry *e) {$/;"	f	signature:(entry *e)
printSkipped	redis-check-dump.c	/^void printSkipped(uint64_t bytes, uint64_t offset) {$/;"	f	signature:(uint64_t bytes, uint64_t offset)
printValid	redis-check-dump.c	/^void printValid(uint64_t ops, uint64_t bytes) {$/;"	f	signature:(uint64_t ops, uint64_t bytes)
privdata	dict.h	/^    void *privdata;$/;"	m	struct:dict	access:public
proc	redis.h	/^    redisCommandProc *proc;$/;"	m	struct:redisCommand	access:public
process	redis-check-aof.c	/^off_t process(FILE *fp) {$/;"	f	signature:(FILE *fp)
process	redis-check-dump.c	/^void process(void) {$/;"	f	signature:(void)
processClientsWaitingReplicas	redis.h	/^void processClientsWaitingReplicas(void);$/;"	p	signature:(void)
processClientsWaitingReplicas	replication.c	/^void processClientsWaitingReplicas(void) {$/;"	f	signature:(void)
processCommand	redis.c	/^int processCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
processCommand	redis.h	/^int processCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
processDoubleValue	redis-check-dump.c	/^int processDoubleValue(double** store) {$/;"	f	signature:(double** store)
processEventsWhileBlocked	networking.c	/^int processEventsWhileBlocked(void) {$/;"	f	signature:(void)
processEventsWhileBlocked	redis.h	/^int processEventsWhileBlocked(void);$/;"	p	signature:(void)
processHeader	redis-check-dump.c	/^int processHeader(void) {$/;"	f	signature:(void)
processInlineBuffer	networking.c	/^int processInlineBuffer(redisClient *c) {$/;"	f	signature:(redisClient *c)
processInputBuffer	networking.c	/^void processInputBuffer(redisClient *c) {$/;"	f	signature:(redisClient *c)
processInputBuffer	redis.h	/^void processInputBuffer(redisClient *c);$/;"	p	signature:(redisClient *c)
processMultibulkBuffer	networking.c	/^int processMultibulkBuffer(redisClient *c) {$/;"	f	signature:(redisClient *c)
processStringObject	redis-check-dump.c	/^int processStringObject(char** store) {$/;"	f	signature:(char** store)
processTime	redis-check-dump.c	/^int processTime(int type) {$/;"	f	signature:(int type)
processTimeEvents	ae.c	/^static int processTimeEvents(aeEventLoop *eventLoop) {$/;"	f	file:	signature:(aeEventLoop *eventLoop)
processUnblockedClients	blocked.c	/^void processUnblockedClients(void) {$/;"	f	signature:(void)
processUnblockedClients	redis.h	/^void processUnblockedClients(void);$/;"	p	signature:(void)
processed_bytes	rio.h	/^    size_t processed_bytes;$/;"	m	struct:_rio	access:public
progress_full	memtest.c	/^size_t progress_full; \/* How many chars to write to fill the progress bar. *\/$/;"	v
progress_printed	memtest.c	/^size_t progress_printed; \/* Printed chars in screen-wide progress bar. *\/$/;"	v
promoted_slave	sentinel.c	/^    struct sentinelRedisInstance *promoted_slave; \/* Promoted slave instance. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
prompt	redis-cli.c	/^    char prompt[128];$/;"	m	struct:config	file:	access:public
propagate	redis.c	/^void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc,$/;"	f	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags)
propagate	redis.h	/^void propagate(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags);$/;"	p	signature:(struct redisCommand *cmd, int dbid, robj **argv, int argc, int flags)
propagateExpire	db.c	/^void propagateExpire(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
propagateExpire	redis.h	/^void propagateExpire(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
psetexCommand	redis.h	/^void psetexCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
psetexCommand	t_string.c	/^void psetexCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
psubscribeCommand	pubsub.c	/^void psubscribeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
psubscribeCommand	redis.h	/^void psubscribeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
psubscribebulk	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
psync_initial_offset	redis.h	/^    long long psync_initial_offset; \/* FULLRESYNC reply offset other slaves$/;"	m	struct:redisClient	access:public
ptr	redis.h	/^    void *ptr;$/;"	m	struct:redisObject	access:public
ptr	rio.h	/^            sds ptr;$/;"	m	struct:_rio::__anon24::__anon25	access:public
pttlCommand	db.c	/^void pttlCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pttlCommand	redis.h	/^void pttlCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
publish	cluster.h	/^    } publish;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon7	access:public
publishCommand	pubsub.c	/^void publishCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
publishCommand	redis.h	/^void publishCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pubsub.c	pubsub.c	1;"	F
pubsubCommand	pubsub.c	/^void pubsubCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
pubsubCommand	redis.h	/^void pubsubCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
pubsubPattern	redis.h	/^typedef struct pubsubPattern {$/;"	s
pubsubPattern	redis.h	/^} pubsubPattern;$/;"	t	typeref:struct:pubsubPattern
pubsubPattern::client	redis.h	/^    redisClient *client;$/;"	m	struct:pubsubPattern	access:public
pubsubPattern::pattern	redis.h	/^    robj *pattern;$/;"	m	struct:pubsubPattern	access:public
pubsubPublishMessage	pubsub.c	/^int pubsubPublishMessage(robj *channel, robj *message) {$/;"	f	signature:(robj *channel, robj *message)
pubsubPublishMessage	redis.h	/^int pubsubPublishMessage(robj *channel, robj *message);$/;"	p	signature:(robj *channel, robj *message)
pubsubSubscribeChannel	pubsub.c	/^int pubsubSubscribeChannel(redisClient *c, robj *channel) {$/;"	f	signature:(redisClient *c, robj *channel)
pubsubSubscribePattern	pubsub.c	/^int pubsubSubscribePattern(redisClient *c, robj *pattern) {$/;"	f	signature:(redisClient *c, robj *pattern)
pubsubUnsubscribeAllChannels	pubsub.c	/^int pubsubUnsubscribeAllChannels(redisClient *c, int notify) {$/;"	f	signature:(redisClient *c, int notify)
pubsubUnsubscribeAllChannels	redis.h	/^int pubsubUnsubscribeAllChannels(redisClient *c, int notify);$/;"	p	signature:(redisClient *c, int notify)
pubsubUnsubscribeAllPatterns	pubsub.c	/^int pubsubUnsubscribeAllPatterns(redisClient *c, int notify) {$/;"	f	signature:(redisClient *c, int notify)
pubsubUnsubscribeAllPatterns	redis.h	/^int pubsubUnsubscribeAllPatterns(redisClient *c, int notify);$/;"	p	signature:(redisClient *c, int notify)
pubsubUnsubscribeChannel	pubsub.c	/^int pubsubUnsubscribeChannel(redisClient *c, robj *channel, int notify) {$/;"	f	signature:(redisClient *c, robj *channel, int notify)
pubsubUnsubscribePattern	pubsub.c	/^int pubsubUnsubscribePattern(redisClient *c, robj *pattern, int notify) {$/;"	f	signature:(redisClient *c, robj *pattern, int notify)
pubsub_channels	redis.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	struct:redisServer	access:public
pubsub_channels	redis.h	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient	access:public
pubsub_mode	redis-cli.c	/^    int pubsub_mode;$/;"	m	struct:config	file:	access:public
pubsub_patterns	redis.h	/^    list *pubsub_patterns;  \/* A list of pubsub_patterns *\/$/;"	m	struct:redisServer	access:public
pubsub_patterns	redis.h	/^    list *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient	access:public
punsubscribeCommand	pubsub.c	/^void punsubscribeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
punsubscribeCommand	redis.h	/^void punsubscribeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
punsubscribebulk	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
pushGenericCommand	t_list.c	/^void pushGenericCommand(redisClient *c, int where) {$/;"	f	signature:(redisClient *c, int where)
pushxGenericCommand	t_list.c	/^void pushxGenericCommand(redisClient *c, robj *refval, robj *val, int where) {$/;"	f	signature:(redisClient *c, robj *refval, robj *val, int where)
putSlaveOnline	replication.c	/^void putSlaveOnline(redisClient *slave) {$/;"	f	signature:(redisClient *slave)
putSlaveOnline	replication.c	/^void putSlaveOnline(redisClient *slave);$/;"	p	file:	signature:(redisClient *slave)
qsortCompareSetsByCardinality	t_set.c	/^int qsortCompareSetsByCardinality(const void *s1, const void *s2) {$/;"	f	signature:(const void *s1, const void *s2)
qsortCompareSetsByRevCardinality	t_set.c	/^int qsortCompareSetsByRevCardinality(const void *s1, const void *s2) {$/;"	f	signature:(const void *s1, const void *s2)
querybuf	redis.h	/^    sds querybuf;$/;"	m	struct:redisClient	access:public
querybuf_peak	redis.h	/^    size_t querybuf_peak;   \/* Recent (100ms or more) peak of querybuf size *\/$/;"	m	struct:redisClient	access:public
queueMultiCommand	multi.c	/^void queueMultiCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
queueMultiCommand	redis.h	/^void queueMultiCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
queued	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
quiet	redis-benchmark.c	/^    int quiet;$/;"	m	struct:config	file:	access:public
quorum	sentinel.c	/^    unsigned int quorum;\/* Number of sentinels that need to agree on failure. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
r	redis-trib.rb	/^    def r$/;"	f	class:ClusterNode
rand.c	rand.c	1;"	F
rand.h	rand.h	1;"	F
randfree	redis-benchmark.c	/^    size_t randfree;        \/* Number of unused pointers in client->randptr *\/$/;"	m	struct:_client	file:	access:public
randlen	redis-benchmark.c	/^    size_t randlen;         \/* Number of pointers in client->randptr *\/$/;"	m	struct:_client	file:	access:public
randomizeClientKey	redis-benchmark.c	/^static void randomizeClientKey(client c) {$/;"	f	file:	signature:(client c)
randomkeyCommand	db.c	/^void randomkeyCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
randomkeyCommand	redis.h	/^void randomkeyCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
randomkeys	redis-benchmark.c	/^    int randomkeys;$/;"	m	struct:config	file:	access:public
randomkeys_keyspacelen	redis-benchmark.c	/^    int randomkeys_keyspacelen;$/;"	m	struct:config	file:	access:public
randptr	redis-benchmark.c	/^    char **randptr;         \/* Pointers to :rand: strings inside the command buf *\/$/;"	m	struct:_client	file:	access:public
randstring	ziplist.c	/^int randstring(char *target, unsigned int min, unsigned int max) {$/;"	f	signature:(char *target, unsigned int min, unsigned int max)
rcvbuf	cluster.h	/^    sds rcvbuf;                 \/* Packet reception buffer *\/$/;"	m	struct:clusterLink	access:public
rdb.c	rdb.c	1;"	F
rdb.h	rdb.h	1;"	F
rdbEncodeInteger	rdb.c	/^int rdbEncodeInteger(long long value, unsigned char *enc) {$/;"	f	signature:(long long value, unsigned char *enc)
rdbGenericLoadStringObject	rdb.c	/^robj *rdbGenericLoadStringObject(rio *rdb, int encode) {$/;"	f	signature:(rio *rdb, int encode)
rdbIsObjectType	rdb.h	/^#define rdbIsObjectType(/;"	d
rdbLoad	rdb.c	/^int rdbLoad(char *filename) {$/;"	f	signature:(char *filename)
rdbLoad	rdb.h	/^int rdbLoad(char *filename);$/;"	p	signature:(char *filename)
rdbLoadDoubleValue	rdb.c	/^int rdbLoadDoubleValue(rio *rdb, double *val) {$/;"	f	signature:(rio *rdb, double *val)
rdbLoadEncodedStringObject	rdb.c	/^robj *rdbLoadEncodedStringObject(rio *rdb) {$/;"	f	signature:(rio *rdb)
rdbLoadIntegerObject	rdb.c	/^robj *rdbLoadIntegerObject(rio *rdb, int enctype, int encode) {$/;"	f	signature:(rio *rdb, int enctype, int encode)
rdbLoadLen	rdb.c	/^uint32_t rdbLoadLen(rio *rdb, int *isencoded) {$/;"	f	signature:(rio *rdb, int *isencoded)
rdbLoadLen	rdb.h	/^uint32_t rdbLoadLen(rio *rdb, int *isencoded);$/;"	p	signature:(rio *rdb, int *isencoded)
rdbLoadLzfStringObject	rdb.c	/^robj *rdbLoadLzfStringObject(rio *rdb) {$/;"	f	signature:(rio *rdb)
rdbLoadMillisecondTime	rdb.c	/^long long rdbLoadMillisecondTime(rio *rdb) {$/;"	f	signature:(rio *rdb)
rdbLoadObject	rdb.c	/^robj *rdbLoadObject(int rdbtype, rio *rdb) {$/;"	f	signature:(int rdbtype, rio *rdb)
rdbLoadObject	rdb.h	/^robj *rdbLoadObject(int type, rio *rdb);$/;"	p	signature:(int type, rio *rdb)
rdbLoadObjectType	rdb.c	/^int rdbLoadObjectType(rio *rdb) {$/;"	f	signature:(rio *rdb)
rdbLoadObjectType	rdb.h	/^int rdbLoadObjectType(rio *rdb);$/;"	p	signature:(rio *rdb)
rdbLoadProgressCallback	rdb.c	/^void rdbLoadProgressCallback(rio *r, const void *buf, size_t len) {$/;"	f	signature:(rio *r, const void *buf, size_t len)
rdbLoadStringObject	rdb.c	/^robj *rdbLoadStringObject(rio *rdb) {$/;"	f	signature:(rio *rdb)
rdbLoadStringObject	rdb.h	/^robj *rdbLoadStringObject(rio *rdb);$/;"	p	signature:(rio *rdb)
rdbLoadTime	rdb.c	/^time_t rdbLoadTime(rio *rdb) {$/;"	f	signature:(rio *rdb)
rdbLoadTime	rdb.h	/^time_t rdbLoadTime(rio *rdb);$/;"	p	signature:(rio *rdb)
rdbLoadType	rdb.c	/^int rdbLoadType(rio *rdb) {$/;"	f	signature:(rio *rdb)
rdbLoadType	rdb.h	/^int rdbLoadType(rio *rdb);$/;"	p	signature:(rio *rdb)
rdbRemoveTempFile	rdb.c	/^void rdbRemoveTempFile(pid_t childpid) {$/;"	f	signature:(pid_t childpid)
rdbRemoveTempFile	rdb.h	/^void rdbRemoveTempFile(pid_t childpid);$/;"	p	signature:(pid_t childpid)
rdbSave	rdb.c	/^int rdbSave(char *filename) {$/;"	f	signature:(char *filename)
rdbSave	rdb.h	/^int rdbSave(char *filename);$/;"	p	signature:(char *filename)
rdbSaveBackground	rdb.c	/^int rdbSaveBackground(char *filename) {$/;"	f	signature:(char *filename)
rdbSaveBackground	rdb.h	/^int rdbSaveBackground(char *filename);$/;"	p	signature:(char *filename)
rdbSaveDoubleValue	rdb.c	/^int rdbSaveDoubleValue(rio *rdb, double val) {$/;"	f	signature:(rio *rdb, double val)
rdbSaveKeyValuePair	rdb.c	/^int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val,$/;"	f	signature:(rio *rdb, robj *key, robj *val, long long expiretime, long long now)
rdbSaveKeyValuePair	rdb.h	/^int rdbSaveKeyValuePair(rio *rdb, robj *key, robj *val, long long expiretime, long long now);$/;"	p	signature:(rio *rdb, robj *key, robj *val, long long expiretime, long long now)
rdbSaveLen	rdb.c	/^int rdbSaveLen(rio *rdb, uint32_t len) {$/;"	f	signature:(rio *rdb, uint32_t len)
rdbSaveLen	rdb.h	/^int rdbSaveLen(rio *rdb, uint32_t len);$/;"	p	signature:(rio *rdb, uint32_t len)
rdbSaveLongLongAsStringObject	rdb.c	/^int rdbSaveLongLongAsStringObject(rio *rdb, long long value) {$/;"	f	signature:(rio *rdb, long long value)
rdbSaveLzfStringObject	rdb.c	/^int rdbSaveLzfStringObject(rio *rdb, unsigned char *s, size_t len) {$/;"	f	signature:(rio *rdb, unsigned char *s, size_t len)
rdbSaveMillisecondTime	rdb.c	/^int rdbSaveMillisecondTime(rio *rdb, long long t) {$/;"	f	signature:(rio *rdb, long long t)
rdbSaveObject	rdb.c	/^int rdbSaveObject(rio *rdb, robj *o) {$/;"	f	signature:(rio *rdb, robj *o)
rdbSaveObject	rdb.h	/^int rdbSaveObject(rio *rdb, robj *o);$/;"	p	signature:(rio *rdb, robj *o)
rdbSaveObjectType	rdb.c	/^int rdbSaveObjectType(rio *rdb, robj *o) {$/;"	f	signature:(rio *rdb, robj *o)
rdbSaveObjectType	rdb.h	/^int rdbSaveObjectType(rio *rdb, robj *o);$/;"	p	signature:(rio *rdb, robj *o)
rdbSaveRawString	rdb.c	/^int rdbSaveRawString(rio *rdb, unsigned char *s, size_t len) {$/;"	f	signature:(rio *rdb, unsigned char *s, size_t len)
rdbSaveRio	rdb.c	/^int rdbSaveRio(rio *rdb, int *error) {$/;"	f	signature:(rio *rdb, int *error)
rdbSaveRioWithEOFMark	rdb.c	/^int rdbSaveRioWithEOFMark(rio *rdb, int *error) {$/;"	f	signature:(rio *rdb, int *error)
rdbSaveStringObject	rdb.c	/^int rdbSaveStringObject(rio *rdb, robj *obj) {$/;"	f	signature:(rio *rdb, robj *obj)
rdbSaveTime	rdb.h	/^int rdbSaveTime(rio *rdb, time_t t);$/;"	p	signature:(rio *rdb, time_t t)
rdbSaveToSlavesSockets	rdb.c	/^int rdbSaveToSlavesSockets(void) {$/;"	f	signature:(void)
rdbSaveToSlavesSockets	rdb.h	/^int rdbSaveToSlavesSockets(void);$/;"	p	signature:(void)
rdbSaveType	rdb.c	/^int rdbSaveType(rio *rdb, unsigned char type) {$/;"	f	signature:(rio *rdb, unsigned char type)
rdbSaveType	rdb.h	/^int rdbSaveType(rio *rdb, unsigned char type);$/;"	p	signature:(rio *rdb, unsigned char type)
rdbSavedObjectLen	rdb.c	/^off_t rdbSavedObjectLen(robj *o) {$/;"	f	signature:(robj *o)
rdbSavedObjectLen	rdb.h	/^off_t rdbSavedObjectLen(robj *o);$/;"	p	signature:(robj *o)
rdbSavedObjectPages	rdb.h	/^off_t rdbSavedObjectPages(robj *o);$/;"	p	signature:(robj *o)
rdbTryIntegerEncoding	rdb.c	/^int rdbTryIntegerEncoding(char *s, size_t len, unsigned char *enc) {$/;"	f	signature:(char *s, size_t len, unsigned char *enc)
rdbWriteRaw	rdb.c	/^static int rdbWriteRaw(rio *rdb, void *p, size_t len) {$/;"	f	file:	signature:(rio *rdb, void *p, size_t len)
rdb_checksum	redis.h	/^    int rdb_checksum;               \/* Use RDB checksum? *\/$/;"	m	struct:redisServer	access:public
rdb_child_pid	redis.h	/^    pid_t rdb_child_pid;            \/* PID of RDB saving child *\/$/;"	m	struct:redisServer	access:public
rdb_child_type	redis.h	/^    int rdb_child_type;             \/* Type of save by active child. *\/$/;"	m	struct:redisServer	access:public
rdb_compression	redis.h	/^    int rdb_compression;            \/* Use compression in RDB? *\/$/;"	m	struct:redisServer	access:public
rdb_filename	redis-cli.c	/^    char *rdb_filename;$/;"	m	struct:config	file:	access:public
rdb_filename	redis.h	/^    char *rdb_filename;             \/* Name of RDB file *\/$/;"	m	struct:redisServer	access:public
rdb_fsync_range	config.h	/^#define rdb_fsync_range(/;"	d
rdb_pipe_read_result_from_child	redis.h	/^    int rdb_pipe_read_result_from_child; \/* of each slave in diskless SYNC. *\/$/;"	m	struct:redisServer	access:public
rdb_pipe_write_result_to_parent	redis.h	/^    int rdb_pipe_write_result_to_parent; \/* RDB pipes used to return the state *\/$/;"	m	struct:redisServer	access:public
rdb_save_time_last	redis.h	/^    time_t rdb_save_time_last;      \/* Time used by last RDB save run. *\/$/;"	m	struct:redisServer	access:public
rdb_save_time_start	redis.h	/^    time_t rdb_save_time_start;     \/* Current RDB save start time. *\/$/;"	m	struct:redisServer	access:public
read	rio.h	/^    size_t (*read)(struct _rio *, void *buf, size_t len);$/;"	m	struct:_rio	access:public
readArgFromStdin	redis-cli.c	/^static sds readArgFromStdin(void) {$/;"	f	file:	signature:(void)
readArgc	redis-check-aof.c	/^int readArgc(FILE *fp, long *target) {$/;"	f	signature:(FILE *fp, long *target)
readBytes	redis-check-aof.c	/^int readBytes(FILE *fp, char *target, long length) {$/;"	f	signature:(FILE *fp, char *target, long length)
readBytes	redis-check-dump.c	/^int readBytes(void *target, long num) {$/;"	f	signature:(void *target, long num)
readHandler	redis-benchmark.c	/^static void readHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
readLong	redis-check-aof.c	/^int readLong(FILE *fp, char prefix, long *target) {$/;"	f	signature:(FILE *fp, char prefix, long *target)
readQueryFromClient	networking.c	/^void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
readQueryFromClient	redis.h	/^void readQueryFromClient(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
readString	redis-check-aof.c	/^int readString(FILE *fp, char** target) {$/;"	f	signature:(FILE *fp, char** target)
readSyncBulkPayload	replication.c	/^void readSyncBulkPayload(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
reading	sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:	access:public
readonlyCommand	cluster.c	/^void readonlyCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
readonlyCommand	redis.h	/^void readonlyCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
readwriteCommand	cluster.c	/^void readwriteCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
readwriteCommand	redis.h	/^void readwriteCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
readyList	redis.h	/^typedef struct readyList {$/;"	s
readyList	redis.h	/^} readyList;$/;"	t	typeref:struct:readyList
readyList::db	redis.h	/^    redisDb *db;$/;"	m	struct:readyList	access:public
readyList::key	redis.h	/^    robj *key;$/;"	m	struct:readyList	access:public
ready_keys	redis.h	/^    dict *ready_keys;           \/* Blocked keys that received a PUSH *\/$/;"	m	struct:redisDb	access:public
ready_keys	redis.h	/^    list *ready_keys;        \/* List of readyList structures for BLPOP & co *\/$/;"	m	struct:redisServer	access:public
realloc	redis.h	/^void *realloc(void *ptr, size_t size) __attribute__ ((deprecated));$/;"	p	signature:(void *ptr, size_t size)
realloc	zmalloc.c	/^#define realloc(/;"	d	file:
reconnectingRedisCommand	redis-cli.c	/^static redisReply *reconnectingRedisCommand(redisContext *c, const char *fmt, ...) {$/;"	f	file:	signature:(redisContext *c, const char *fmt, ...)
redis-benchmark.c	redis-benchmark.c	1;"	F
redis-check-aof.c	redis-check-aof.c	1;"	F
redis-check-dump.c	redis-check-dump.c	1;"	F
redis-cli.c	redis-cli.c	1;"	F
redis-trib.rb	redis-trib.rb	1;"	F
redis.c	redis.c	1;"	F
redis.h	redis.h	1;"	F
redisAeAddRead	sentinel.c	/^static void redisAeAddRead(void *privdata) {$/;"	f	file:	signature:(void *privdata)
redisAeAddWrite	sentinel.c	/^static void redisAeAddWrite(void *privdata) {$/;"	f	file:	signature:(void *privdata)
redisAeAttach	sentinel.c	/^static int redisAeAttach(aeEventLoop *loop, redisAsyncContext *ac) {$/;"	f	file:	signature:(aeEventLoop *loop, redisAsyncContext *ac)
redisAeCleanup	sentinel.c	/^static void redisAeCleanup(void *privdata) {$/;"	f	file:	signature:(void *privdata)
redisAeDelRead	sentinel.c	/^static void redisAeDelRead(void *privdata) {$/;"	f	file:	signature:(void *privdata)
redisAeDelWrite	sentinel.c	/^static void redisAeDelWrite(void *privdata) {$/;"	f	file:	signature:(void *privdata)
redisAeEvents	sentinel.c	/^typedef struct redisAeEvents {$/;"	s	file:
redisAeEvents	sentinel.c	/^} redisAeEvents;$/;"	t	typeref:struct:redisAeEvents	file:
redisAeEvents::context	sentinel.c	/^    redisAsyncContext *context;$/;"	m	struct:redisAeEvents	file:	access:public
redisAeEvents::fd	sentinel.c	/^    int fd;$/;"	m	struct:redisAeEvents	file:	access:public
redisAeEvents::loop	sentinel.c	/^    aeEventLoop *loop;$/;"	m	struct:redisAeEvents	file:	access:public
redisAeEvents::reading	sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:	access:public
redisAeEvents::writing	sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:	access:public
redisAeReadEvent	sentinel.c	/^static void redisAeReadEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
redisAeWriteEvent	sentinel.c	/^static void redisAeWriteEvent(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
redisAsciiArt	redis.c	/^void redisAsciiArt(void) {$/;"	f	signature:(void)
redisAssert	redis.h	/^#define redisAssert(/;"	d
redisAssertWithInfo	redis.h	/^#define redisAssertWithInfo(/;"	d
redisBitpos	bitops.c	/^long redisBitpos(void *s, unsigned long count, int bit) {$/;"	f	signature:(void *s, unsigned long count, int bit)
redisBuildId	redis.h	/^uint64_t redisBuildId(void);$/;"	p	signature:(void)
redisBuildId	release.c	/^uint64_t redisBuildId(void) {$/;"	f	signature:(void)
redisClient	redis.h	/^typedef struct redisClient {$/;"	s
redisClient	redis.h	/^} redisClient;$/;"	t	typeref:struct:redisClient
redisClient::argc	redis.h	/^    int argc;$/;"	m	struct:redisClient	access:public
redisClient::argv	redis.h	/^    robj **argv;$/;"	m	struct:redisClient	access:public
redisClient::authenticated	redis.h	/^    int authenticated;      \/* when requirepass is non-NULL *\/$/;"	m	struct:redisClient	access:public
redisClient::bpop	redis.h	/^    blockingState bpop;     \/* blocking state *\/$/;"	m	struct:redisClient	access:public
redisClient::btype	redis.h	/^    int btype;              \/* Type of blocking op if REDIS_BLOCKED. *\/$/;"	m	struct:redisClient	access:public
redisClient::buf	redis.h	/^    char buf[REDIS_REPLY_CHUNK_BYTES];$/;"	m	struct:redisClient	access:public
redisClient::bufpos	redis.h	/^    int bufpos;$/;"	m	struct:redisClient	access:public
redisClient::bulklen	redis.h	/^    long bulklen;           \/* length of bulk argument in multi bulk request *\/$/;"	m	struct:redisClient	access:public
redisClient::cmd	redis.h	/^    struct redisCommand *cmd, *lastcmd;$/;"	m	struct:redisClient	typeref:struct:redisClient::redisCommand	access:public
redisClient::ctime	redis.h	/^    time_t ctime;           \/* Client creation time *\/$/;"	m	struct:redisClient	access:public
redisClient::db	redis.h	/^    redisDb *db;$/;"	m	struct:redisClient	access:public
redisClient::dictid	redis.h	/^    int dictid;$/;"	m	struct:redisClient	access:public
redisClient::fd	redis.h	/^    int fd;$/;"	m	struct:redisClient	access:public
redisClient::flags	redis.h	/^    int flags;              \/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... *\/$/;"	m	struct:redisClient	access:public
redisClient::id	redis.h	/^    uint64_t id;            \/* Client incremental unique ID. *\/$/;"	m	struct:redisClient	access:public
redisClient::lastcmd	redis.h	/^    struct redisCommand *cmd, *lastcmd;$/;"	m	struct:redisClient	typeref:struct:redisClient::	access:public
redisClient::lastinteraction	redis.h	/^    time_t lastinteraction; \/* time of the last interaction, used for timeout *\/$/;"	m	struct:redisClient	access:public
redisClient::mstate	redis.h	/^    multiState mstate;      \/* MULTI\/EXEC state *\/$/;"	m	struct:redisClient	access:public
redisClient::multibulklen	redis.h	/^    int multibulklen;       \/* number of multi bulk arguments left to read *\/$/;"	m	struct:redisClient	access:public
redisClient::name	redis.h	/^    robj *name;             \/* As set by CLIENT SETNAME *\/$/;"	m	struct:redisClient	access:public
redisClient::obuf_soft_limit_reached_time	redis.h	/^    time_t obuf_soft_limit_reached_time;$/;"	m	struct:redisClient	access:public
redisClient::peerid	redis.h	/^    sds peerid;             \/* Cached peer ID. *\/$/;"	m	struct:redisClient	access:public
redisClient::psync_initial_offset	redis.h	/^    long long psync_initial_offset; \/* FULLRESYNC reply offset other slaves$/;"	m	struct:redisClient	access:public
redisClient::pubsub_channels	redis.h	/^    dict *pubsub_channels;  \/* channels a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient	access:public
redisClient::pubsub_patterns	redis.h	/^    list *pubsub_patterns;  \/* patterns a client is interested in (SUBSCRIBE) *\/$/;"	m	struct:redisClient	access:public
redisClient::querybuf	redis.h	/^    sds querybuf;$/;"	m	struct:redisClient	access:public
redisClient::querybuf_peak	redis.h	/^    size_t querybuf_peak;   \/* Recent (100ms or more) peak of querybuf size *\/$/;"	m	struct:redisClient	access:public
redisClient::repl_ack_off	redis.h	/^    long long repl_ack_off; \/* replication ack offset, if this is a slave *\/$/;"	m	struct:redisClient	access:public
redisClient::repl_ack_time	redis.h	/^    long long repl_ack_time;\/* replication ack time, if this is a slave *\/$/;"	m	struct:redisClient	access:public
redisClient::repl_put_online_on_ack	redis.h	/^    int repl_put_online_on_ack; \/* Install slave write handler on ACK. *\/$/;"	m	struct:redisClient	access:public
redisClient::repldbfd	redis.h	/^    int repldbfd;           \/* replication DB file descriptor *\/$/;"	m	struct:redisClient	access:public
redisClient::repldboff	redis.h	/^    off_t repldboff;        \/* replication DB file offset *\/$/;"	m	struct:redisClient	access:public
redisClient::repldbsize	redis.h	/^    off_t repldbsize;       \/* replication DB file size *\/$/;"	m	struct:redisClient	access:public
redisClient::reploff	redis.h	/^    long long reploff;      \/* replication offset if this is our master *\/$/;"	m	struct:redisClient	access:public
redisClient::replpreamble	redis.h	/^    sds replpreamble;       \/* replication DB preamble. *\/$/;"	m	struct:redisClient	access:public
redisClient::replrunid	redis.h	/^    char replrunid[REDIS_RUN_ID_SIZE+1]; \/* master run id if this is a master *\/$/;"	m	struct:redisClient	access:public
redisClient::replstate	redis.h	/^    int replstate;          \/* replication state if this is a slave *\/$/;"	m	struct:redisClient	access:public
redisClient::reply	redis.h	/^    list *reply;$/;"	m	struct:redisClient	access:public
redisClient::reply_bytes	redis.h	/^    unsigned long reply_bytes; \/* Tot bytes of objects in reply list *\/$/;"	m	struct:redisClient	access:public
redisClient::reqtype	redis.h	/^    int reqtype;$/;"	m	struct:redisClient	access:public
redisClient::sentlen	redis.h	/^    int sentlen;            \/* Amount of bytes already sent in the current$/;"	m	struct:redisClient	access:public
redisClient::slave_capa	redis.h	/^    int slave_capa;         \/* Slave capabilities: SLAVE_CAPA_* bitwise OR. *\/$/;"	m	struct:redisClient	access:public
redisClient::slave_listening_port	redis.h	/^    int slave_listening_port; \/* As configured with: SLAVECONF listening-port *\/$/;"	m	struct:redisClient	access:public
redisClient::watched_keys	redis.h	/^    list *watched_keys;     \/* Keys WATCHED for MULTI\/EXEC CAS *\/$/;"	m	struct:redisClient	access:public
redisClient::woff	redis.h	/^    long long woff;         \/* Last write global replication offset. *\/$/;"	m	struct:redisClient	access:public
redisCommand	redis.h	/^struct redisCommand {$/;"	s
redisCommand::arity	redis.h	/^    int arity;$/;"	m	struct:redisCommand	access:public
redisCommand::calls	redis.h	/^    long long microseconds, calls;$/;"	m	struct:redisCommand	access:public
redisCommand::firstkey	redis.h	/^    int firstkey; \/* The first argument that's a key (0 = no keys) *\/$/;"	m	struct:redisCommand	access:public
redisCommand::flags	redis.h	/^    int flags;    \/* The actual flags, obtained from the 'sflags' field. *\/$/;"	m	struct:redisCommand	access:public
redisCommand::getkeys_proc	redis.h	/^    redisGetKeysProc *getkeys_proc;$/;"	m	struct:redisCommand	access:public
redisCommand::keystep	redis.h	/^    int keystep;  \/* The step between first and last key *\/$/;"	m	struct:redisCommand	access:public
redisCommand::lastkey	redis.h	/^    int lastkey;  \/* The last argument that's a key *\/$/;"	m	struct:redisCommand	access:public
redisCommand::microseconds	redis.h	/^    long long microseconds, calls;$/;"	m	struct:redisCommand	access:public
redisCommand::name	redis.h	/^    char *name;$/;"	m	struct:redisCommand	access:public
redisCommand::proc	redis.h	/^    redisCommandProc *proc;$/;"	m	struct:redisCommand	access:public
redisCommand::sflags	redis.h	/^    char *sflags; \/* Flags as string representation, one char per flag. *\/$/;"	m	struct:redisCommand	access:public
redisCommandProc	redis.h	/^typedef void redisCommandProc(redisClient *c);$/;"	t
redisCommandTable	redis.c	/^struct redisCommand redisCommandTable[] = {$/;"	v	typeref:struct:redisCommand
redisDb	redis.h	/^typedef struct redisDb {$/;"	s
redisDb	redis.h	/^} redisDb;$/;"	t	typeref:struct:redisDb
redisDb::avg_ttl	redis.h	/^    long long avg_ttl;          \/* Average TTL, just for stats *\/$/;"	m	struct:redisDb	access:public
redisDb::blocking_keys	redis.h	/^    dict *blocking_keys;        \/* Keys with clients waiting for data (BLPOP) *\/$/;"	m	struct:redisDb	access:public
redisDb::dict	redis.h	/^    dict *dict;                 \/* The keyspace for this DB *\/$/;"	m	struct:redisDb	access:public
redisDb::eviction_pool	redis.h	/^    struct evictionPoolEntry *eviction_pool;    \/* Eviction pool of keys *\/$/;"	m	struct:redisDb	typeref:struct:redisDb::evictionPoolEntry	access:public
redisDb::expires	redis.h	/^    dict *expires;              \/* Timeout of keys with a timeout set *\/$/;"	m	struct:redisDb	access:public
redisDb::id	redis.h	/^    int id;                     \/* Database ID *\/$/;"	m	struct:redisDb	access:public
redisDb::ready_keys	redis.h	/^    dict *ready_keys;           \/* Blocked keys that received a PUSH *\/$/;"	m	struct:redisDb	access:public
redisDb::watched_keys	redis.h	/^    dict *watched_keys;         \/* WATCHED keys for MULTI\/EXEC CAS *\/$/;"	m	struct:redisDb	access:public
redisDebug	redis.h	/^#define redisDebug(/;"	d
redisDebugMark	redis.h	/^#define redisDebugMark(/;"	d
redisFunctionSym	redis.h	/^struct redisFunctionSym {$/;"	s
redisFunctionSym::name	redis.h	/^    char *name;$/;"	m	struct:redisFunctionSym	access:public
redisFunctionSym::pointer	redis.h	/^    unsigned long pointer;$/;"	m	struct:redisFunctionSym	access:public
redisGetKeysProc	redis.h	/^typedef int *redisGetKeysProc(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	t
redisGitDirty	redis-cli.c	/^char *redisGitDirty(void);$/;"	p	file:	signature:(void)
redisGitDirty	redis.h	/^char *redisGitDirty(void);$/;"	p	signature:(void)
redisGitDirty	release.c	/^char *redisGitDirty(void) {$/;"	f	signature:(void)
redisGitSHA1	redis-cli.c	/^char *redisGitSHA1(void);$/;"	p	file:	signature:(void)
redisGitSHA1	redis.h	/^char *redisGitSHA1(void);$/;"	p	signature:(void)
redisGitSHA1	release.c	/^char *redisGitSHA1(void) {$/;"	f	signature:(void)
redisLog	redis.c	/^void redisLog(int level, const char *fmt, ...) {$/;"	f	signature:(int level, const char *fmt, ...)
redisLog	redis.h	/^void redisLog(int level, const char *fmt, ...)$/;"	p	signature:(int level, const char *fmt, ...)
redisLog	redis.h	/^void redisLog(int level, const char *fmt, ...);$/;"	p	signature:(int level, const char *fmt, ...)
redisLogFromHandler	redis.c	/^void redisLogFromHandler(int level, const char *msg) {$/;"	f	signature:(int level, const char *msg)
redisLogFromHandler	redis.h	/^void redisLogFromHandler(int level, const char *msg);$/;"	p	signature:(int level, const char *msg)
redisLogHexDump	debug.c	/^void redisLogHexDump(int level, char *descr, void *value, size_t len) {$/;"	f	signature:(int level, char *descr, void *value, size_t len)
redisLogHexDump	redis.h	/^void redisLogHexDump(int level, char *descr, void *value, size_t len);$/;"	p	signature:(int level, char *descr, void *value, size_t len)
redisLogObjectDebugInfo	debug.c	/^void redisLogObjectDebugInfo(robj *o) {$/;"	f	signature:(robj *o)
redisLogObjectDebugInfo	redis.h	/^void redisLogObjectDebugInfo(robj *o);$/;"	p	signature:(robj *o)
redisLogRaw	redis.c	/^void redisLogRaw(int level, const char *msg) {$/;"	f	signature:(int level, const char *msg)
redisLogRaw	redis.h	/^void redisLogRaw(int level, const char *msg);$/;"	p	signature:(int level, const char *msg)
redisLrand48	rand.c	/^int32_t redisLrand48() {$/;"	f
redisLrand48	rand.h	/^int32_t redisLrand48();$/;"	p	signature:()
redisNodeFlags	cluster.c	/^struct redisNodeFlags {$/;"	s	file:
redisNodeFlags::flag	cluster.c	/^    uint16_t flag;$/;"	m	struct:redisNodeFlags	file:	access:public
redisNodeFlags::name	cluster.c	/^    char *name;$/;"	m	struct:redisNodeFlags	file:	access:public
redisNodeFlagsTable	cluster.c	/^static struct redisNodeFlags redisNodeFlagsTable[] = {$/;"	v	typeref:struct:redisNodeFlags	file:
redisObject	redis.h	/^typedef struct redisObject {$/;"	s
redisObject::encoding	redis.h	/^    unsigned encoding:4;$/;"	m	struct:redisObject	access:public
redisObject::lru	redis.h	/^    unsigned lru:REDIS_LRU_BITS; \/* lru time (relative to server.lruclock) *\/$/;"	m	struct:redisObject	access:public
redisObject::ptr	redis.h	/^    void *ptr;$/;"	m	struct:redisObject	access:public
redisObject::refcount	redis.h	/^    int refcount;$/;"	m	struct:redisObject	access:public
redisObject::type	redis.h	/^    unsigned type:4;$/;"	m	struct:redisObject	access:public
redisOp	redis.h	/^typedef struct redisOp {$/;"	s
redisOp	redis.h	/^} redisOp;$/;"	t	typeref:struct:redisOp
redisOp::argc	redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp	access:public
redisOp::argv	redis.h	/^    robj **argv;$/;"	m	struct:redisOp	access:public
redisOp::cmd	redis.h	/^    struct redisCommand *cmd;$/;"	m	struct:redisOp	typeref:struct:redisOp::redisCommand	access:public
redisOp::dbid	redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp	access:public
redisOp::target	redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp	access:public
redisOpArray	redis.h	/^typedef struct redisOpArray {$/;"	s
redisOpArray	redis.h	/^} redisOpArray;$/;"	t	typeref:struct:redisOpArray
redisOpArray::numops	redis.h	/^    int numops;$/;"	m	struct:redisOpArray	access:public
redisOpArray::ops	redis.h	/^    redisOp *ops;$/;"	m	struct:redisOpArray	access:public
redisOpArrayAppend	redis.c	/^int redisOpArrayAppend(redisOpArray *oa, struct redisCommand *cmd, int dbid,$/;"	f	signature:(redisOpArray *oa, struct redisCommand *cmd, int dbid, robj **argv, int argc, int target)
redisOpArrayFree	redis.c	/^void redisOpArrayFree(redisOpArray *oa) {$/;"	f	signature:(redisOpArray *oa)
redisOpArrayInit	redis.c	/^void redisOpArrayInit(redisOpArray *oa) {$/;"	f	signature:(redisOpArray *oa)
redisOutOfMemoryHandler	redis.c	/^void redisOutOfMemoryHandler(size_t allocation_size) {$/;"	f	signature:(size_t allocation_size)
redisPanic	redis.h	/^#define redisPanic(/;"	d
redisPopcount	bitops.c	/^size_t redisPopcount(void *s, long count) {$/;"	f	signature:(void *s, long count)
redisPopcount	redis.h	/^size_t redisPopcount(void *s, long count);$/;"	p	signature:(void *s, long count)
redisProtocolToLuaType	scripting.c	/^char *redisProtocolToLuaType(lua_State *lua, char* reply) {$/;"	f	signature:(lua_State *lua, char* reply)
redisProtocolToLuaType_Bulk	scripting.c	/^char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply) {$/;"	f	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Bulk	scripting.c	/^char *redisProtocolToLuaType_Bulk(lua_State *lua, char *reply);$/;"	p	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Error	scripting.c	/^char *redisProtocolToLuaType_Error(lua_State *lua, char *reply) {$/;"	f	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Error	scripting.c	/^char *redisProtocolToLuaType_Error(lua_State *lua, char *reply);$/;"	p	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Int	scripting.c	/^char *redisProtocolToLuaType_Int(lua_State *lua, char *reply) {$/;"	f	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Int	scripting.c	/^char *redisProtocolToLuaType_Int(lua_State *lua, char *reply);$/;"	p	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_MultiBulk	scripting.c	/^char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply) {$/;"	f	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_MultiBulk	scripting.c	/^char *redisProtocolToLuaType_MultiBulk(lua_State *lua, char *reply);$/;"	p	file:	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Status	scripting.c	/^char *redisProtocolToLuaType_Status(lua_State *lua, char *reply) {$/;"	f	signature:(lua_State *lua, char *reply)
redisProtocolToLuaType_Status	scripting.c	/^char *redisProtocolToLuaType_Status(lua_State *lua, char *reply);$/;"	p	file:	signature:(lua_State *lua, char *reply)
redisServer	redis.h	/^struct redisServer {$/;"	s
redisServer::__anon16::idx	redis.h	/^        int idx;$/;"	m	struct:redisServer::__anon16	access:public
redisServer::__anon16::last_sample_count	redis.h	/^        long long last_sample_count;\/* Count in last sample *\/$/;"	m	struct:redisServer::__anon16	access:public
redisServer::__anon16::last_sample_time	redis.h	/^        long long last_sample_time; \/* Timestamp of last sample in ms *\/$/;"	m	struct:redisServer::__anon16	access:public
redisServer::__anon16::samples	redis.h	/^        long long samples[REDIS_METRIC_SAMPLES];$/;"	m	struct:redisServer::__anon16	access:public
redisServer::active_expire_enabled	redis.h	/^    int active_expire_enabled;      \/* Can be disabled for testing purposes. *\/$/;"	m	struct:redisServer	access:public
redisServer::activerehashing	redis.h	/^    int activerehashing;        \/* Incremental rehash in serverCron() *\/$/;"	m	struct:redisServer	access:public
redisServer::also_propagate	redis.h	/^    redisOpArray also_propagate;    \/* Additional command to propagate. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_buf	redis.h	/^    sds aof_buf;      \/* AOF buffer, written before entering the event loop *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_child_diff	redis.h	/^    sds aof_child_diff;             \/* AOF diff accumulator child side. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_child_pid	redis.h	/^    pid_t aof_child_pid;            \/* PID if rewriting process *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_current_size	redis.h	/^    off_t aof_current_size;         \/* AOF current size. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_delayed_fsync	redis.h	/^    unsigned long aof_delayed_fsync;  \/* delayed AOF fsync() counter *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_fd	redis.h	/^    int aof_fd;       \/* File descriptor of currently selected AOF file *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_filename	redis.h	/^    char *aof_filename;             \/* Name of the AOF file *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_flush_postponed_start	redis.h	/^    time_t aof_flush_postponed_start; \/* UNIX time of postponed AOF flush *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_fsync	redis.h	/^    int aof_fsync;                  \/* Kind of fsync() policy *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_last_fsync	redis.h	/^    time_t aof_last_fsync;            \/* UNIX time of last fsync() *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_last_write_errno	redis.h	/^    int aof_last_write_errno;       \/* Valid if aof_last_write_status is ERR *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_last_write_status	redis.h	/^    int aof_last_write_status;      \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_lastbgrewrite_status	redis.h	/^    int aof_lastbgrewrite_status;   \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_load_truncated	redis.h	/^    int aof_load_truncated;         \/* Don't stop on unexpected AOF EOF. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_no_fsync_on_rewrite	redis.h	/^    int aof_no_fsync_on_rewrite;    \/* Don't fsync if a rewrite is in prog. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_pipe_read_ack_from_child	redis.h	/^    int aof_pipe_read_ack_from_child;$/;"	m	struct:redisServer	access:public
redisServer::aof_pipe_read_ack_from_parent	redis.h	/^    int aof_pipe_read_ack_from_parent;$/;"	m	struct:redisServer	access:public
redisServer::aof_pipe_read_data_from_parent	redis.h	/^    int aof_pipe_read_data_from_parent;$/;"	m	struct:redisServer	access:public
redisServer::aof_pipe_write_ack_to_child	redis.h	/^    int aof_pipe_write_ack_to_child;$/;"	m	struct:redisServer	access:public
redisServer::aof_pipe_write_ack_to_parent	redis.h	/^    int aof_pipe_write_ack_to_parent;$/;"	m	struct:redisServer	access:public
redisServer::aof_pipe_write_data_to_child	redis.h	/^    int aof_pipe_write_data_to_child;$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_base_size	redis.h	/^    off_t aof_rewrite_base_size;    \/* AOF size on latest startup or rewrite. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_buf_blocks	redis.h	/^    list *aof_rewrite_buf_blocks;   \/* Hold changes during an AOF rewrite. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_incremental_fsync	redis.h	/^    int aof_rewrite_incremental_fsync;\/* fsync incrementally while rewriting? *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_min_size	redis.h	/^    off_t aof_rewrite_min_size;     \/* the AOF file is at least N bytes. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_perc	redis.h	/^    int aof_rewrite_perc;           \/* Rewrite AOF if % growth is > M and... *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_scheduled	redis.h	/^    int aof_rewrite_scheduled;      \/* Rewrite once BGSAVE terminates. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_time_last	redis.h	/^    time_t aof_rewrite_time_last;   \/* Time used by last AOF rewrite run. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_rewrite_time_start	redis.h	/^    time_t aof_rewrite_time_start;  \/* Current AOF rewrite start time. *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_selected_db	redis.h	/^    int aof_selected_db; \/* Currently selected DB in AOF *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_state	redis.h	/^    int aof_state;                  \/* REDIS_AOF_(ON|OFF|WAIT_REWRITE) *\/$/;"	m	struct:redisServer	access:public
redisServer::aof_stop_sending_diff	redis.h	/^    int aof_stop_sending_diff;     \/* If true stop sending accumulated diffs$/;"	m	struct:redisServer	access:public
redisServer::arch_bits	redis.h	/^    int arch_bits;              \/* 32 or 64 depending on sizeof(long) *\/$/;"	m	struct:redisServer	access:public
redisServer::assert_failed	redis.h	/^    char *assert_failed;$/;"	m	struct:redisServer	access:public
redisServer::assert_file	redis.h	/^    char *assert_file;$/;"	m	struct:redisServer	access:public
redisServer::assert_line	redis.h	/^    int assert_line;$/;"	m	struct:redisServer	access:public
redisServer::bindaddr	redis.h	/^    char *bindaddr[REDIS_BINDADDR_MAX]; \/* Addresses we should bind to *\/$/;"	m	struct:redisServer	access:public
redisServer::bindaddr_count	redis.h	/^    int bindaddr_count;         \/* Number of addresses in server.bindaddr[] *\/$/;"	m	struct:redisServer	access:public
redisServer::bpop_blocked_clients	redis.h	/^    unsigned int bpop_blocked_clients; \/* Number of clients blocked by lists *\/$/;"	m	struct:redisServer	access:public
redisServer::bug_report_start	redis.h	/^    int bug_report_start; \/* True if bug report header was already logged. *\/$/;"	m	struct:redisServer	access:public
redisServer::cached_master	redis.h	/^    redisClient *cached_master; \/* Cached master to be reused for PSYNC. *\/$/;"	m	struct:redisServer	access:public
redisServer::cfd	redis.h	/^    int cfd[REDIS_BINDADDR_MAX];\/* Cluster bus listening socket *\/$/;"	m	struct:redisServer	access:public
redisServer::cfd_count	redis.h	/^    int cfd_count;              \/* Used slots in cfd[] *\/$/;"	m	struct:redisServer	access:public
redisServer::client_max_querybuf_len	redis.h	/^    size_t client_max_querybuf_len; \/* Limit for client query buffer length *\/$/;"	m	struct:redisServer	access:public
redisServer::client_obuf_limits	redis.h	/^    clientBufferLimitsConfig client_obuf_limits[REDIS_CLIENT_TYPE_COUNT];$/;"	m	struct:redisServer	access:public
redisServer::clients	redis.h	/^    list *clients;              \/* List of active clients *\/$/;"	m	struct:redisServer	access:public
redisServer::clients_pause_end_time	redis.h	/^    mstime_t clients_pause_end_time; \/* Time when we undo clients_paused *\/$/;"	m	struct:redisServer	access:public
redisServer::clients_paused	redis.h	/^    int clients_paused;         \/* True if clients are currently paused *\/$/;"	m	struct:redisServer	access:public
redisServer::clients_to_close	redis.h	/^    list *clients_to_close;     \/* Clients to close asynchronously *\/$/;"	m	struct:redisServer	access:public
redisServer::clients_waiting_acks	redis.h	/^    list *clients_waiting_acks;         \/* Clients waiting in WAIT command. *\/$/;"	m	struct:redisServer	access:public
redisServer::cluster	redis.h	/^    struct clusterState *cluster;  \/* State of the cluster *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::clusterState	access:public
redisServer::cluster_configfile	redis.h	/^    char *cluster_configfile; \/* Cluster auto-generated config file name. *\/$/;"	m	struct:redisServer	access:public
redisServer::cluster_enabled	redis.h	/^    int cluster_enabled;      \/* Is cluster enabled? *\/$/;"	m	struct:redisServer	access:public
redisServer::cluster_migration_barrier	redis.h	/^    int cluster_migration_barrier; \/* Cluster replicas migration barrier. *\/$/;"	m	struct:redisServer	access:public
redisServer::cluster_node_timeout	redis.h	/^    mstime_t cluster_node_timeout; \/* Cluster node timeout. *\/$/;"	m	struct:redisServer	access:public
redisServer::cluster_require_full_coverage	redis.h	/^    int cluster_require_full_coverage; \/* If true, put the cluster down if$/;"	m	struct:redisServer	access:public
redisServer::cluster_slave_validity_factor	redis.h	/^    int cluster_slave_validity_factor; \/* Slave max data age for failover. *\/$/;"	m	struct:redisServer	access:public
redisServer::commands	redis.h	/^    dict *commands;             \/* Command table *\/$/;"	m	struct:redisServer	access:public
redisServer::configfile	redis.h	/^    char *configfile;           \/* Absolute config file path, or NULL *\/$/;"	m	struct:redisServer	access:public
redisServer::cronloops	redis.h	/^    int cronloops;              \/* Number of times the cron function run *\/$/;"	m	struct:redisServer	access:public
redisServer::current_client	redis.h	/^    redisClient *current_client; \/* Current client, only used on crash report *\/$/;"	m	struct:redisServer	access:public
redisServer::daemonize	redis.h	/^    int daemonize;                  \/* True if running as a daemon *\/$/;"	m	struct:redisServer	access:public
redisServer::db	redis.h	/^    redisDb *db;$/;"	m	struct:redisServer	access:public
redisServer::dbnum	redis.h	/^    int dbnum;                      \/* Total number of configured DBs *\/$/;"	m	struct:redisServer	access:public
redisServer::delCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::redisCommand	access:public
redisServer::dirty	redis.h	/^    long long dirty;                \/* Changes to DB from the last save *\/$/;"	m	struct:redisServer	access:public
redisServer::dirty_before_bgsave	redis.h	/^    long long dirty_before_bgsave;  \/* Used to restore dirty on failed BGSAVE *\/$/;"	m	struct:redisServer	access:public
redisServer::el	redis.h	/^    aeEventLoop *el;$/;"	m	struct:redisServer	access:public
redisServer::get_ack_from_slaves	redis.h	/^    int get_ack_from_slaves;            \/* If true we send REPLCONF GETACK. *\/$/;"	m	struct:redisServer	access:public
redisServer::hash_max_ziplist_entries	redis.h	/^    size_t hash_max_ziplist_entries;$/;"	m	struct:redisServer	access:public
redisServer::hash_max_ziplist_value	redis.h	/^    size_t hash_max_ziplist_value;$/;"	m	struct:redisServer	access:public
redisServer::hll_sparse_max_bytes	redis.h	/^    size_t hll_sparse_max_bytes;$/;"	m	struct:redisServer	access:public
redisServer::hz	redis.h	/^    int hz;                     \/* serverCron() calls frequency in hertz *\/$/;"	m	struct:redisServer	access:public
redisServer::inst_metric	redis.h	/^    } inst_metric[REDIS_METRIC_COUNT];$/;"	m	struct:redisServer	typeref:struct:redisServer::__anon16	access:public
redisServer::ipfd	redis.h	/^    int ipfd[REDIS_BINDADDR_MAX]; \/* TCP socket file descriptors *\/$/;"	m	struct:redisServer	access:public
redisServer::ipfd_count	redis.h	/^    int ipfd_count;             \/* Used slots in ipfd[] *\/$/;"	m	struct:redisServer	access:public
redisServer::lastbgsave_status	redis.h	/^    int lastbgsave_status;          \/* REDIS_OK or REDIS_ERR *\/$/;"	m	struct:redisServer	access:public
redisServer::lastbgsave_try	redis.h	/^    time_t lastbgsave_try;          \/* Unix time of last attempted bgsave *\/$/;"	m	struct:redisServer	access:public
redisServer::lastsave	redis.h	/^    time_t lastsave;                \/* Unix time of last successful save *\/$/;"	m	struct:redisServer	access:public
redisServer::latency_events	redis.h	/^    dict *latency_events;$/;"	m	struct:redisServer	access:public
redisServer::latency_monitor_threshold	redis.h	/^    long long latency_monitor_threshold;$/;"	m	struct:redisServer	access:public
redisServer::list_max_ziplist_entries	redis.h	/^    size_t list_max_ziplist_entries;$/;"	m	struct:redisServer	access:public
redisServer::list_max_ziplist_value	redis.h	/^    size_t list_max_ziplist_value;$/;"	m	struct:redisServer	access:public
redisServer::loading	redis.h	/^    int loading;                \/* We are loading data from disk if true *\/$/;"	m	struct:redisServer	access:public
redisServer::loading_loaded_bytes	redis.h	/^    off_t loading_loaded_bytes;$/;"	m	struct:redisServer	access:public
redisServer::loading_process_events_interval_bytes	redis.h	/^    off_t loading_process_events_interval_bytes;$/;"	m	struct:redisServer	access:public
redisServer::loading_start_time	redis.h	/^    time_t loading_start_time;$/;"	m	struct:redisServer	access:public
redisServer::loading_total_bytes	redis.h	/^    off_t loading_total_bytes;$/;"	m	struct:redisServer	access:public
redisServer::logfile	redis.h	/^    char *logfile;                  \/* Path of log file *\/$/;"	m	struct:redisServer	access:public
redisServer::lpopCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::lpushCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::lruclock	redis.h	/^    unsigned lruclock:REDIS_LRU_BITS; \/* Clock for LRU eviction *\/$/;"	m	struct:redisServer	access:public
redisServer::lua	redis.h	/^    lua_State *lua; \/* The Lua interpreter. We use just one for all clients *\/$/;"	m	struct:redisServer	access:public
redisServer::lua_caller	redis.h	/^    redisClient *lua_caller;   \/* The client running EVAL right now, or NULL *\/$/;"	m	struct:redisServer	access:public
redisServer::lua_client	redis.h	/^    redisClient *lua_client;   \/* The "fake client" to query Redis from Lua *\/$/;"	m	struct:redisServer	access:public
redisServer::lua_kill	redis.h	/^    int lua_kill;         \/* Kill the script if true. *\/$/;"	m	struct:redisServer	access:public
redisServer::lua_random_dirty	redis.h	/^    int lua_random_dirty; \/* True if a random command was called during the$/;"	m	struct:redisServer	access:public
redisServer::lua_scripts	redis.h	/^    dict *lua_scripts;         \/* A dictionary of SHA1 -> Lua scripts *\/$/;"	m	struct:redisServer	access:public
redisServer::lua_time_limit	redis.h	/^    mstime_t lua_time_limit;  \/* Script timeout in milliseconds *\/$/;"	m	struct:redisServer	access:public
redisServer::lua_time_start	redis.h	/^    mstime_t lua_time_start;  \/* Start time of script, milliseconds time *\/$/;"	m	struct:redisServer	access:public
redisServer::lua_timedout	redis.h	/^    int lua_timedout;     \/* True if we reached the time limit for script$/;"	m	struct:redisServer	access:public
redisServer::lua_write_dirty	redis.h	/^    int lua_write_dirty;  \/* True if a write command was called during the$/;"	m	struct:redisServer	access:public
redisServer::master	redis.h	/^    redisClient *master;     \/* Client that is master for this slave *\/$/;"	m	struct:redisServer	access:public
redisServer::master_repl_offset	redis.h	/^    long long master_repl_offset;   \/* Global replication offset *\/$/;"	m	struct:redisServer	access:public
redisServer::masterauth	redis.h	/^    char *masterauth;               \/* AUTH with this password with master *\/$/;"	m	struct:redisServer	access:public
redisServer::masterhost	redis.h	/^    char *masterhost;               \/* Hostname of master *\/$/;"	m	struct:redisServer	access:public
redisServer::masterport	redis.h	/^    int masterport;                 \/* Port of master *\/$/;"	m	struct:redisServer	access:public
redisServer::maxclients	redis.h	/^    unsigned int maxclients;            \/* Max number of simultaneous clients *\/$/;"	m	struct:redisServer	access:public
redisServer::maxidletime	redis.h	/^    int maxidletime;                \/* Client timeout in seconds *\/$/;"	m	struct:redisServer	access:public
redisServer::maxmemory	redis.h	/^    unsigned long long maxmemory;   \/* Max number of memory bytes to use *\/$/;"	m	struct:redisServer	access:public
redisServer::maxmemory_policy	redis.h	/^    int maxmemory_policy;           \/* Policy for key eviction *\/$/;"	m	struct:redisServer	access:public
redisServer::maxmemory_samples	redis.h	/^    int maxmemory_samples;          \/* Pricision of random sampling *\/$/;"	m	struct:redisServer	access:public
redisServer::migrate_cached_sockets	redis.h	/^    dict *migrate_cached_sockets;\/* MIGRATE cached sockets *\/$/;"	m	struct:redisServer	access:public
redisServer::monitors	redis.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer	access:public
redisServer::mstime	redis.h	/^    long long mstime;       \/* Like 'unixtime' but with milliseconds resolution. *\/$/;"	m	struct:redisServer	access:public
redisServer::multiCommand	redis.h	/^    struct redisCommand *delCommand, *multiCommand, *lpushCommand, *lpopCommand,$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::neterr	redis.h	/^    char neterr[ANET_ERR_LEN];   \/* Error buffer for anet.c *\/$/;"	m	struct:redisServer	access:public
redisServer::next_client_id	redis.h	/^    uint64_t next_client_id;    \/* Next client unique ID. Incremental. *\/$/;"	m	struct:redisServer	access:public
redisServer::notify_keyspace_events	redis.h	/^    int notify_keyspace_events; \/* Events to propagate via Pub\/Sub. This is an$/;"	m	struct:redisServer	access:public
redisServer::orig_commands	redis.h	/^    dict *orig_commands;        \/* Command table before command renaming. *\/$/;"	m	struct:redisServer	access:public
redisServer::pid	redis.h	/^    pid_t pid;                  \/* Main process pid. *\/$/;"	m	struct:redisServer	access:public
redisServer::pidfile	redis.h	/^    char *pidfile;              \/* PID file path *\/$/;"	m	struct:redisServer	access:public
redisServer::port	redis.h	/^    int port;                   \/* TCP listening port *\/$/;"	m	struct:redisServer	access:public
redisServer::pubsub_channels	redis.h	/^    dict *pubsub_channels;  \/* Map channels to list of subscribed clients *\/$/;"	m	struct:redisServer	access:public
redisServer::pubsub_patterns	redis.h	/^    list *pubsub_patterns;  \/* A list of pubsub_patterns *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_checksum	redis.h	/^    int rdb_checksum;               \/* Use RDB checksum? *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_child_pid	redis.h	/^    pid_t rdb_child_pid;            \/* PID of RDB saving child *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_child_type	redis.h	/^    int rdb_child_type;             \/* Type of save by active child. *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_compression	redis.h	/^    int rdb_compression;            \/* Use compression in RDB? *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_filename	redis.h	/^    char *rdb_filename;             \/* Name of RDB file *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_pipe_read_result_from_child	redis.h	/^    int rdb_pipe_read_result_from_child; \/* of each slave in diskless SYNC. *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_pipe_write_result_to_parent	redis.h	/^    int rdb_pipe_write_result_to_parent; \/* RDB pipes used to return the state *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_save_time_last	redis.h	/^    time_t rdb_save_time_last;      \/* Time used by last RDB save run. *\/$/;"	m	struct:redisServer	access:public
redisServer::rdb_save_time_start	redis.h	/^    time_t rdb_save_time_start;     \/* Current RDB save start time. *\/$/;"	m	struct:redisServer	access:public
redisServer::ready_keys	redis.h	/^    list *ready_keys;        \/* List of readyList structures for BLPOP & co *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_backlog	redis.h	/^    char *repl_backlog;             \/* Replication backlog for partial syncs *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_backlog_histlen	redis.h	/^    long long repl_backlog_histlen; \/* Backlog actual data length *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_backlog_idx	redis.h	/^    long long repl_backlog_idx;     \/* Backlog circular buffer current offset *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_backlog_off	redis.h	/^    long long repl_backlog_off;     \/* Replication offset of first byte in the$/;"	m	struct:redisServer	access:public
redisServer::repl_backlog_size	redis.h	/^    long long repl_backlog_size;    \/* Backlog circular buffer size *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_backlog_time_limit	redis.h	/^    time_t repl_backlog_time_limit; \/* Time without slaves after the backlog$/;"	m	struct:redisServer	access:public
redisServer::repl_disable_tcp_nodelay	redis.h	/^    int repl_disable_tcp_nodelay;   \/* Disable TCP_NODELAY after SYNC? *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_diskless_sync	redis.h	/^    int repl_diskless_sync;         \/* Send RDB to slaves sockets directly. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_diskless_sync_delay	redis.h	/^    int repl_diskless_sync_delay;   \/* Delay to start a diskless repl BGSAVE. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_down_since	redis.h	/^    time_t repl_down_since; \/* Unix time at which link with master went down *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_good_slaves_count	redis.h	/^    int repl_good_slaves_count;     \/* Number of slaves with lag <= max_lag. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_master_initial_offset	redis.h	/^    long long repl_master_initial_offset;         \/* Master PSYNC offset. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_master_runid	redis.h	/^    char repl_master_runid[REDIS_RUN_ID_SIZE+1];  \/* Master run id for PSYNC. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_min_slaves_max_lag	redis.h	/^    int repl_min_slaves_max_lag;    \/* Max lag of <count> slaves to write. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_min_slaves_to_write	redis.h	/^    int repl_min_slaves_to_write;   \/* Min number of slaves to write. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_no_slaves_since	redis.h	/^    time_t repl_no_slaves_since;    \/* We have no slaves since that time.$/;"	m	struct:redisServer	access:public
redisServer::repl_ping_slave_period	redis.h	/^    int repl_ping_slave_period;     \/* Master pings the slave every N seconds *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_scriptcache_dict	redis.h	/^    dict *repl_scriptcache_dict;        \/* SHA1 all slaves are aware of. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_scriptcache_fifo	redis.h	/^    list *repl_scriptcache_fifo;        \/* First in, first out LRU eviction. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_scriptcache_size	redis.h	/^    unsigned int repl_scriptcache_size; \/* Max number of elements. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_serve_stale_data	redis.h	/^    int repl_serve_stale_data; \/* Serve stale data when link is down? *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_slave_ro	redis.h	/^    int repl_slave_ro;          \/* Slave is read only? *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_state	redis.h	/^    int repl_state;          \/* Replication status if the instance is a slave *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_syncio_timeout	redis.h	/^    int repl_syncio_timeout; \/* Timeout for synchronous I\/O calls *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_timeout	redis.h	/^    int repl_timeout;               \/* Timeout after N seconds of master idle *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_transfer_fd	redis.h	/^    int repl_transfer_fd;    \/* Slave -> Master SYNC temp file descriptor *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_transfer_last_fsync_off	redis.h	/^    off_t repl_transfer_last_fsync_off; \/* Offset when we fsync-ed last time. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_transfer_lastio	redis.h	/^    time_t repl_transfer_lastio; \/* Unix time of the latest read, for timeout *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_transfer_read	redis.h	/^    off_t repl_transfer_read; \/* Amount of RDB read from master during sync. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_transfer_s	redis.h	/^    int repl_transfer_s;     \/* Slave -> Master SYNC socket *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_transfer_size	redis.h	/^    off_t repl_transfer_size; \/* Size of RDB to read from master during sync. *\/$/;"	m	struct:redisServer	access:public
redisServer::repl_transfer_tmpfile	redis.h	/^    char *repl_transfer_tmpfile; \/* Slave-> master SYNC temp file name *\/$/;"	m	struct:redisServer	access:public
redisServer::requirepass	redis.h	/^    char *requirepass;          \/* Pass for AUTH command, or NULL *\/$/;"	m	struct:redisServer	access:public
redisServer::resident_set_size	redis.h	/^    size_t resident_set_size;       \/* RSS sampled in serverCron(). *\/$/;"	m	struct:redisServer	access:public
redisServer::rpopCommand	redis.h	/^                        *rpopCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
redisServer::runid	redis.h	/^    char runid[REDIS_RUN_ID_SIZE+1];  \/* ID always different at every exec. *\/$/;"	m	struct:redisServer	access:public
redisServer::saveparams	redis.h	/^    struct saveparam *saveparams;   \/* Save points array for RDB *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::saveparam	access:public
redisServer::saveparamslen	redis.h	/^    int saveparamslen;              \/* Number of saving points *\/$/;"	m	struct:redisServer	access:public
redisServer::sentinel_mode	redis.h	/^    int sentinel_mode;          \/* True if this instance is a Sentinel. *\/$/;"	m	struct:redisServer	access:public
redisServer::set_max_intset_entries	redis.h	/^    size_t set_max_intset_entries;$/;"	m	struct:redisServer	access:public
redisServer::shutdown_asap	redis.h	/^    int shutdown_asap;          \/* SHUTDOWN needed ASAP *\/$/;"	m	struct:redisServer	access:public
redisServer::slave_priority	redis.h	/^    int slave_priority;             \/* Reported in INFO and used by Sentinel. *\/$/;"	m	struct:redisServer	access:public
redisServer::slaves	redis.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer	access:public
redisServer::slaveseldb	redis.h	/^    int slaveseldb;                 \/* Last SELECTed DB in replication output *\/$/;"	m	struct:redisServer	access:public
redisServer::slowlog	redis.h	/^    list *slowlog;                  \/* SLOWLOG list of commands *\/$/;"	m	struct:redisServer	access:public
redisServer::slowlog_entry_id	redis.h	/^    long long slowlog_entry_id;     \/* SLOWLOG current entry ID *\/$/;"	m	struct:redisServer	access:public
redisServer::slowlog_log_slower_than	redis.h	/^    long long slowlog_log_slower_than; \/* SLOWLOG time limit (to get logged) *\/$/;"	m	struct:redisServer	access:public
redisServer::slowlog_max_len	redis.h	/^    unsigned long slowlog_max_len;     \/* SLOWLOG max number of items logged *\/$/;"	m	struct:redisServer	access:public
redisServer::sofd	redis.h	/^    int sofd;                   \/* Unix socket file descriptor *\/$/;"	m	struct:redisServer	access:public
redisServer::sort_alpha	redis.h	/^    int sort_alpha;$/;"	m	struct:redisServer	access:public
redisServer::sort_bypattern	redis.h	/^    int sort_bypattern;$/;"	m	struct:redisServer	access:public
redisServer::sort_desc	redis.h	/^    int sort_desc;$/;"	m	struct:redisServer	access:public
redisServer::sort_store	redis.h	/^    int sort_store;$/;"	m	struct:redisServer	access:public
redisServer::stat_evictedkeys	redis.h	/^    long long stat_evictedkeys;     \/* Number of evicted keys (maxmemory) *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_expiredkeys	redis.h	/^    long long stat_expiredkeys;     \/* Number of expired keys *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_fork_rate	redis.h	/^    double stat_fork_rate;          \/* Fork rate in GB\/sec. *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_fork_time	redis.h	/^    long long stat_fork_time;       \/* Time needed to perform latest fork() *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_keyspace_hits	redis.h	/^    long long stat_keyspace_hits;   \/* Number of successful lookups of keys *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_keyspace_misses	redis.h	/^    long long stat_keyspace_misses; \/* Number of failed lookups of keys *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_net_input_bytes	redis.h	/^    long long stat_net_input_bytes; \/* Bytes read from network. *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_net_output_bytes	redis.h	/^    long long stat_net_output_bytes; \/* Bytes written to network. *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_numcommands	redis.h	/^    long long stat_numcommands;     \/* Number of processed commands *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_numconnections	redis.h	/^    long long stat_numconnections;  \/* Number of connections received *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_peak_memory	redis.h	/^    size_t stat_peak_memory;        \/* Max used memory record *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_rejected_conn	redis.h	/^    long long stat_rejected_conn;   \/* Clients rejected because of maxclients *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_starttime	redis.h	/^    time_t stat_starttime;          \/* Server start time *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_sync_full	redis.h	/^    long long stat_sync_full;       \/* Number of full resyncs with slaves. *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_sync_partial_err	redis.h	/^    long long stat_sync_partial_err;\/* Number of unaccepted PSYNC requests. *\/$/;"	m	struct:redisServer	access:public
redisServer::stat_sync_partial_ok	redis.h	/^    long long stat_sync_partial_ok; \/* Number of accepted PSYNC requests. *\/$/;"	m	struct:redisServer	access:public
redisServer::stop_writes_on_bgsave_err	redis.h	/^    int stop_writes_on_bgsave_err;  \/* Don't allow writes if can't BGSAVE *\/$/;"	m	struct:redisServer	access:public
redisServer::syslog_enabled	redis.h	/^    int syslog_enabled;             \/* Is syslog enabled? *\/$/;"	m	struct:redisServer	access:public
redisServer::syslog_facility	redis.h	/^    int syslog_facility;            \/* Syslog facility *\/$/;"	m	struct:redisServer	access:public
redisServer::syslog_ident	redis.h	/^    char *syslog_ident;             \/* Syslog ident *\/$/;"	m	struct:redisServer	access:public
redisServer::tcp_backlog	redis.h	/^    int tcp_backlog;            \/* TCP listen() backlog *\/$/;"	m	struct:redisServer	access:public
redisServer::tcpkeepalive	redis.h	/^    int tcpkeepalive;               \/* Set SO_KEEPALIVE if non-zero. *\/$/;"	m	struct:redisServer	access:public
redisServer::unblocked_clients	redis.h	/^    list *unblocked_clients; \/* list of clients to unblock before next loop *\/$/;"	m	struct:redisServer	access:public
redisServer::unixsocket	redis.h	/^    char *unixsocket;           \/* UNIX socket path *\/$/;"	m	struct:redisServer	access:public
redisServer::unixsocketperm	redis.h	/^    mode_t unixsocketperm;      \/* UNIX socket permission *\/$/;"	m	struct:redisServer	access:public
redisServer::unixtime	redis.h	/^    time_t unixtime;        \/* Unix time sampled every cron cycle. *\/$/;"	m	struct:redisServer	access:public
redisServer::verbosity	redis.h	/^    int verbosity;                  \/* Loglevel in redis.conf *\/$/;"	m	struct:redisServer	access:public
redisServer::watchdog_period	redis.h	/^    int watchdog_period;  \/* Software watchdog period in ms. 0 = off *\/$/;"	m	struct:redisServer	access:public
redisServer::zset_max_ziplist_entries	redis.h	/^    size_t zset_max_ziplist_entries;$/;"	m	struct:redisServer	access:public
redisServer::zset_max_ziplist_value	redis.h	/^    size_t zset_max_ziplist_value;$/;"	m	struct:redisServer	access:public
redisSetProcTitle	redis.c	/^void redisSetProcTitle(char *title) {$/;"	f	signature:(char *title)
redisSetProcTitle	redis.h	/^void redisSetProcTitle(char *title);$/;"	p	signature:(char *title)
redisSortObject	redis.h	/^} redisSortObject;$/;"	t	typeref:struct:_redisSortObject
redisSortOperation	redis.h	/^} redisSortOperation;$/;"	t	typeref:struct:_redisSortOperation
redisSrand48	rand.c	/^void redisSrand48(int32_t seedval) {$/;"	f	signature:(int32_t seedval)
redisSrand48	rand.h	/^void redisSrand48(int32_t seedval);$/;"	p	signature:(int32_t seedval)
redis_fstat	config.h	/^#define redis_fstat /;"	d
redis_math_random	scripting.c	/^int redis_math_random (lua_State *L) {$/;"	f	signature:(lua_State *L)
redis_math_random	scripting.c	/^int redis_math_random (lua_State *L);$/;"	p	file:	signature:(lua_State *L)
redis_math_randomseed	scripting.c	/^int redis_math_randomseed (lua_State *L) {$/;"	f	signature:(lua_State *L)
redis_math_randomseed	scripting.c	/^int redis_math_randomseed (lua_State *L);$/;"	p	file:	signature:(lua_State *L)
redis_stat	config.h	/^#define redis_stat /;"	d
redisassert.h	redisassert.h	1;"	F
refcount	redis.h	/^    int refcount;$/;"	m	struct:redisObject	access:public
refreshGoodSlavesCount	redis.h	/^void refreshGoodSlavesCount(void);$/;"	p	signature:(void)
refreshGoodSlavesCount	replication.c	/^void refreshGoodSlavesCount(void) {$/;"	f	signature:(void)
registers	hyperloglog.c	/^    uint8_t registers[]; \/* Data bytes. *\/$/;"	m	struct:hllhdr	file:	access:public
rehashidx	dict.h	/^    long rehashidx; \/* rehashing not in progress if rehashidx == -1 *\/$/;"	m	struct:dict	access:public
release.c	release.c	1;"	F
release.h	release.h	1;"	F
releaseSentinelAddr	sentinel.c	/^void releaseSentinelAddr(sentinelAddr *sa) {$/;"	f	signature:(sentinelAddr *sa)
releaseSentinelRedisInstance	sentinel.c	/^void releaseSentinelRedisInstance(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
releaseSentinelRedisInstance	sentinel.c	/^void releaseSentinelRedisInstance(sentinelRedisInstance *ri);$/;"	p	file:	signature:(sentinelRedisInstance *ri)
release_hdr	Makefile	/^release_hdr := $(shell sh -c '.\/mkreleasehdr.sh')$/;"	m
removeExpire	db.c	/^int removeExpire(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
removeExpire	redis.h	/^int removeExpire(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
removeMatchingSentinelsFromMaster	sentinel.c	/^int removeMatchingSentinelsFromMaster(sentinelRedisInstance *master, char *ip, int port, char *runid) {$/;"	f	signature:(sentinelRedisInstance *master, char *ip, int port, char *runid)
renameCommand	db.c	/^void renameCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
renameCommand	redis.h	/^void renameCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
renameGenericCommand	db.c	/^void renameGenericCommand(redisClient *c, int nx) {$/;"	f	signature:(redisClient *c, int nx)
renamenxCommand	db.c	/^void renamenxCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
renamenxCommand	redis.h	/^void renamenxCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
repeat	redis-cli.c	/^    long repeat;$/;"	m	struct:config	file:	access:public
repl	redis-cli.c	/^static void repl(void) {$/;"	f	file:	signature:(void)
replScriptCacheDictType	redis.c	/^dictType replScriptCacheDictType = {$/;"	v
replScriptCacheDictType	redis.h	/^extern dictType replScriptCacheDictType;$/;"	x
repl_ack_off	redis.h	/^    long long repl_ack_off; \/* replication ack offset, if this is a slave *\/$/;"	m	struct:redisClient	access:public
repl_ack_time	redis.h	/^    long long repl_ack_time;\/* replication ack time, if this is a slave *\/$/;"	m	struct:redisClient	access:public
repl_backlog	redis.h	/^    char *repl_backlog;             \/* Replication backlog for partial syncs *\/$/;"	m	struct:redisServer	access:public
repl_backlog_histlen	redis.h	/^    long long repl_backlog_histlen; \/* Backlog actual data length *\/$/;"	m	struct:redisServer	access:public
repl_backlog_idx	redis.h	/^    long long repl_backlog_idx;     \/* Backlog circular buffer current offset *\/$/;"	m	struct:redisServer	access:public
repl_backlog_off	redis.h	/^    long long repl_backlog_off;     \/* Replication offset of first byte in the$/;"	m	struct:redisServer	access:public
repl_backlog_size	redis.h	/^    long long repl_backlog_size;    \/* Backlog circular buffer size *\/$/;"	m	struct:redisServer	access:public
repl_backlog_time_limit	redis.h	/^    time_t repl_backlog_time_limit; \/* Time without slaves after the backlog$/;"	m	struct:redisServer	access:public
repl_disable_tcp_nodelay	redis.h	/^    int repl_disable_tcp_nodelay;   \/* Disable TCP_NODELAY after SYNC? *\/$/;"	m	struct:redisServer	access:public
repl_diskless_sync	redis.h	/^    int repl_diskless_sync;         \/* Send RDB to slaves sockets directly. *\/$/;"	m	struct:redisServer	access:public
repl_diskless_sync_delay	redis.h	/^    int repl_diskless_sync_delay;   \/* Delay to start a diskless repl BGSAVE. *\/$/;"	m	struct:redisServer	access:public
repl_down_since	redis.h	/^    time_t repl_down_since; \/* Unix time at which link with master went down *\/$/;"	m	struct:redisServer	access:public
repl_good_slaves_count	redis.h	/^    int repl_good_slaves_count;     \/* Number of slaves with lag <= max_lag. *\/$/;"	m	struct:redisServer	access:public
repl_master_initial_offset	redis.h	/^    long long repl_master_initial_offset;         \/* Master PSYNC offset. *\/$/;"	m	struct:redisServer	access:public
repl_master_runid	redis.h	/^    char repl_master_runid[REDIS_RUN_ID_SIZE+1];  \/* Master run id for PSYNC. *\/$/;"	m	struct:redisServer	access:public
repl_min_slaves_max_lag	redis.h	/^    int repl_min_slaves_max_lag;    \/* Max lag of <count> slaves to write. *\/$/;"	m	struct:redisServer	access:public
repl_min_slaves_to_write	redis.h	/^    int repl_min_slaves_to_write;   \/* Min number of slaves to write. *\/$/;"	m	struct:redisServer	access:public
repl_no_slaves_since	redis.h	/^    time_t repl_no_slaves_since;    \/* We have no slaves since that time.$/;"	m	struct:redisServer	access:public
repl_offset	cluster.h	/^    long long repl_offset;      \/* Last known repl offset for this node. *\/$/;"	m	struct:clusterNode	access:public
repl_offset_time	cluster.h	/^    mstime_t repl_offset_time;  \/* Unix time we received offset for this node *\/$/;"	m	struct:clusterNode	access:public
repl_ping_slave_period	redis.h	/^    int repl_ping_slave_period;     \/* Master pings the slave every N seconds *\/$/;"	m	struct:redisServer	access:public
repl_put_online_on_ack	redis.h	/^    int repl_put_online_on_ack; \/* Install slave write handler on ACK. *\/$/;"	m	struct:redisClient	access:public
repl_scriptcache_dict	redis.h	/^    dict *repl_scriptcache_dict;        \/* SHA1 all slaves are aware of. *\/$/;"	m	struct:redisServer	access:public
repl_scriptcache_fifo	redis.h	/^    list *repl_scriptcache_fifo;        \/* First in, first out LRU eviction. *\/$/;"	m	struct:redisServer	access:public
repl_scriptcache_size	redis.h	/^    unsigned int repl_scriptcache_size; \/* Max number of elements. *\/$/;"	m	struct:redisServer	access:public
repl_serve_stale_data	redis.h	/^    int repl_serve_stale_data; \/* Serve stale data when link is down? *\/$/;"	m	struct:redisServer	access:public
repl_slave_ro	redis.h	/^    int repl_slave_ro;          \/* Slave is read only? *\/$/;"	m	struct:redisServer	access:public
repl_state	redis.h	/^    int repl_state;          \/* Replication status if the instance is a slave *\/$/;"	m	struct:redisServer	access:public
repl_syncio_timeout	redis.h	/^    int repl_syncio_timeout; \/* Timeout for synchronous I\/O calls *\/$/;"	m	struct:redisServer	access:public
repl_timeout	redis.h	/^    int repl_timeout;               \/* Timeout after N seconds of master idle *\/$/;"	m	struct:redisServer	access:public
repl_transfer_fd	redis.h	/^    int repl_transfer_fd;    \/* Slave -> Master SYNC temp file descriptor *\/$/;"	m	struct:redisServer	access:public
repl_transfer_last_fsync_off	redis.h	/^    off_t repl_transfer_last_fsync_off; \/* Offset when we fsync-ed last time. *\/$/;"	m	struct:redisServer	access:public
repl_transfer_lastio	redis.h	/^    time_t repl_transfer_lastio; \/* Unix time of the latest read, for timeout *\/$/;"	m	struct:redisServer	access:public
repl_transfer_read	redis.h	/^    off_t repl_transfer_read; \/* Amount of RDB read from master during sync. *\/$/;"	m	struct:redisServer	access:public
repl_transfer_s	redis.h	/^    int repl_transfer_s;     \/* Slave -> Master SYNC socket *\/$/;"	m	struct:redisServer	access:public
repl_transfer_size	redis.h	/^    off_t repl_transfer_size; \/* Size of RDB to read from master during sync. *\/$/;"	m	struct:redisServer	access:public
repl_transfer_tmpfile	redis.h	/^    char *repl_transfer_tmpfile; \/* Slave-> master SYNC temp file name *\/$/;"	m	struct:redisServer	access:public
replconfCommand	redis.h	/^void replconfCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
replconfCommand	replication.c	/^void replconfCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
repldbfd	redis.h	/^    int repldbfd;           \/* replication DB file descriptor *\/$/;"	m	struct:redisClient	access:public
repldboff	redis.h	/^    off_t repldboff;        \/* replication DB file offset *\/$/;"	m	struct:redisClient	access:public
repldbsize	redis.h	/^    off_t repldbsize;       \/* replication DB file size *\/$/;"	m	struct:redisClient	access:public
replication.c	replication.c	1;"	F
replicationAbortSyncTransfer	replication.c	/^void replicationAbortSyncTransfer(void) {$/;"	f	signature:(void)
replicationCacheMaster	redis.h	/^void replicationCacheMaster(redisClient *c);$/;"	p	signature:(redisClient *c)
replicationCacheMaster	replication.c	/^void replicationCacheMaster(redisClient *c) {$/;"	f	signature:(redisClient *c)
replicationCountAcksByOffset	redis.h	/^int replicationCountAcksByOffset(long long offset);$/;"	p	signature:(long long offset)
replicationCountAcksByOffset	replication.c	/^int replicationCountAcksByOffset(long long offset) {$/;"	f	signature:(long long offset)
replicationCron	redis.h	/^void replicationCron(void);$/;"	p	signature:(void)
replicationCron	replication.c	/^void replicationCron(void) {$/;"	f	signature:(void)
replicationDiscardCachedMaster	replication.c	/^void replicationDiscardCachedMaster(void) {$/;"	f	signature:(void)
replicationDiscardCachedMaster	replication.c	/^void replicationDiscardCachedMaster(void);$/;"	p	file:	signature:(void)
replicationEmptyDbCallback	replication.c	/^void replicationEmptyDbCallback(void *privdata) {$/;"	f	signature:(void *privdata)
replicationFeedMonitors	redis.h	/^void replicationFeedMonitors(redisClient *c, list *monitors, int dictid, robj **argv, int argc);$/;"	p	signature:(redisClient *c, list *monitors, int dictid, robj **argv, int argc)
replicationFeedMonitors	replication.c	/^void replicationFeedMonitors(redisClient *c, list *monitors, int dictid, robj **argv, int argc) {$/;"	f	signature:(redisClient *c, list *monitors, int dictid, robj **argv, int argc)
replicationFeedSlaves	redis.h	/^void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc);$/;"	p	signature:(list *slaves, int dictid, robj **argv, int argc)
replicationFeedSlaves	replication.c	/^void replicationFeedSlaves(list *slaves, int dictid, robj **argv, int argc) {$/;"	f	signature:(list *slaves, int dictid, robj **argv, int argc)
replicationGetSlaveName	redis.h	/^char *replicationGetSlaveName(redisClient *c);$/;"	p	signature:(redisClient *c)
replicationGetSlaveName	replication.c	/^char *replicationGetSlaveName(redisClient *c) {$/;"	f	signature:(redisClient *c)
replicationGetSlaveOffset	redis.h	/^long long replicationGetSlaveOffset(void);$/;"	p	signature:(void)
replicationGetSlaveOffset	replication.c	/^long long replicationGetSlaveOffset(void) {$/;"	f	signature:(void)
replicationHandleMasterDisconnection	redis.h	/^void replicationHandleMasterDisconnection(void);$/;"	p	signature:(void)
replicationHandleMasterDisconnection	replication.c	/^void replicationHandleMasterDisconnection(void) {$/;"	f	signature:(void)
replicationRequestAckFromSlaves	replication.c	/^void replicationRequestAckFromSlaves(void) {$/;"	f	signature:(void)
replicationResurrectCachedMaster	replication.c	/^void replicationResurrectCachedMaster(int newfd) {$/;"	f	signature:(int newfd)
replicationResurrectCachedMaster	replication.c	/^void replicationResurrectCachedMaster(int newfd);$/;"	p	file:	signature:(int newfd)
replicationScriptCacheAdd	redis.h	/^void replicationScriptCacheAdd(sds sha1);$/;"	p	signature:(sds sha1)
replicationScriptCacheAdd	replication.c	/^void replicationScriptCacheAdd(sds sha1) {$/;"	f	signature:(sds sha1)
replicationScriptCacheExists	redis.h	/^int replicationScriptCacheExists(sds sha1);$/;"	p	signature:(sds sha1)
replicationScriptCacheExists	replication.c	/^int replicationScriptCacheExists(sds sha1) {$/;"	f	signature:(sds sha1)
replicationScriptCacheFlush	redis.h	/^void replicationScriptCacheFlush(void);$/;"	p	signature:(void)
replicationScriptCacheFlush	replication.c	/^void replicationScriptCacheFlush(void) {$/;"	f	signature:(void)
replicationScriptCacheInit	redis.h	/^void replicationScriptCacheInit(void);$/;"	p	signature:(void)
replicationScriptCacheInit	replication.c	/^void replicationScriptCacheInit(void) {$/;"	f	signature:(void)
replicationSendAck	replication.c	/^void replicationSendAck(void) {$/;"	f	signature:(void)
replicationSendAck	replication.c	/^void replicationSendAck(void);$/;"	p	file:	signature:(void)
replicationSendNewlineToMaster	redis.h	/^void replicationSendNewlineToMaster(void);$/;"	p	signature:(void)
replicationSendNewlineToMaster	replication.c	/^void replicationSendNewlineToMaster(void) {$/;"	f	signature:(void)
replicationSetMaster	redis.h	/^void replicationSetMaster(char *ip, int port);$/;"	p	signature:(char *ip, int port)
replicationSetMaster	replication.c	/^void replicationSetMaster(char *ip, int port) {$/;"	f	signature:(char *ip, int port)
replicationSetupSlaveForFullResync	redis.h	/^int replicationSetupSlaveForFullResync(redisClient *slave, long long offset);$/;"	p	signature:(redisClient *slave, long long offset)
replicationSetupSlaveForFullResync	replication.c	/^int replicationSetupSlaveForFullResync(redisClient *slave, long long offset) {$/;"	f	signature:(redisClient *slave, long long offset)
replicationUnsetMaster	redis.h	/^void replicationUnsetMaster(void);$/;"	p	signature:(void)
replicationUnsetMaster	replication.c	/^void replicationUnsetMaster(void) {$/;"	f	signature:(void)
reploff	redis.h	/^    long long reploff;      \/* replication offset if this is our master *\/$/;"	m	struct:redisClient	access:public
reploffset	redis.h	/^    long long reploffset;   \/* Replication offset to reach. *\/$/;"	m	struct:blockingState	access:public
replpreamble	redis.h	/^    sds replpreamble;       \/* replication DB preamble. *\/$/;"	m	struct:redisClient	access:public
replrunid	redis.h	/^    char replrunid[REDIS_RUN_ID_SIZE+1]; \/* master run id if this is a master *\/$/;"	m	struct:redisClient	access:public
replstate	redis.h	/^    int replstate;          \/* replication state if this is a slave *\/$/;"	m	struct:redisClient	access:public
reply	redis.h	/^    list *reply;$/;"	m	struct:redisClient	access:public
replyToBlockedClientTimedOut	blocked.c	/^void replyToBlockedClientTimedOut(redisClient *c) {$/;"	f	signature:(redisClient *c)
replyToBlockedClientTimedOut	redis.h	/^void replyToBlockedClientTimedOut(redisClient *c);$/;"	p	signature:(redisClient *c)
reply_bytes	redis.h	/^    unsigned long reply_bytes; \/* Tot bytes of objects in reply list *\/$/;"	m	struct:redisClient	access:public
representRedisNodeFlags	cluster.c	/^sds representRedisNodeFlags(sds ci, uint16_t flags) {$/;"	f	signature:(sds ci, uint16_t flags)
representRedisNodeFlags	cluster.c	/^sds representRedisNodeFlags(sds ci, uint16_t flags);$/;"	p	file:	signature:(sds ci, uint16_t flags)
reqtype	redis.h	/^    int reqtype;$/;"	m	struct:redisClient	access:public
requests	redis-benchmark.c	/^    int requests;$/;"	m	struct:config	file:	access:public
requests_finished	redis-benchmark.c	/^    int requests_finished;$/;"	m	struct:config	file:	access:public
requests_issued	redis-benchmark.c	/^    int requests_issued;$/;"	m	struct:config	file:	access:public
requirepass	redis.h	/^    char *requirepass;          \/* Pass for AUTH command, or NULL *\/$/;"	m	struct:redisServer	access:public
reset	setproctitle.c	/^	_Bool reset;$/;"	m	struct:__anon28	file:	access:public
resetClient	networking.c	/^void resetClient(redisClient *c) {$/;"	f	signature:(redisClient *c)
resetClient	redis-benchmark.c	/^static void resetClient(client c) {$/;"	f	file:	signature:(client c)
resetClient	redis.h	/^void resetClient(redisClient *c);$/;"	p	signature:(redisClient *c)
resetCommandTableStats	redis.c	/^void resetCommandTableStats(void) {$/;"	f	signature:(void)
resetCommandTableStats	redis.h	/^void resetCommandTableStats(void);$/;"	p	signature:(void)
resetManualFailover	cluster.c	/^void resetManualFailover(void) {$/;"	f	signature:(void)
resetManualFailover	cluster.c	/^void resetManualFailover(void);$/;"	p	file:	signature:(void)
resetRefCount	object.c	/^robj *resetRefCount(robj *obj) {$/;"	f	signature:(robj *obj)
resetRefCount	redis.h	/^robj *resetRefCount(robj *obj);$/;"	p	signature:(robj *obj)
resetServerSaveParams	config.c	/^void resetServerSaveParams(void) {$/;"	f	signature:(void)
resetServerSaveParams	redis.h	/^void resetServerSaveParams(void);$/;"	p	signature:(void)
resetServerStats	redis.c	/^void resetServerStats(void) {$/;"	f	signature:(void)
resetServerStats	redis.h	/^void resetServerStats(void);$/;"	p	signature:(void)
reshard_cluster_cmd	redis-trib.rb	/^    def reshard_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
resident_set_size	redis.h	/^    size_t resident_set_size;       \/* RSS sampled in serverCron(). *\/$/;"	m	struct:redisServer	access:public
resizeReplicationBacklog	redis.h	/^void resizeReplicationBacklog(long long newsize);$/;"	p	signature:(long long newsize)
resizeReplicationBacklog	replication.c	/^void resizeReplicationBacklog(long long newsize) {$/;"	f	signature:(long long newsize)
restoreCommand	cluster.c	/^void restoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
restoreCommand	redis.h	/^void restoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
retry_num	sentinel.c	/^    int retry_num;          \/* Number of times we tried to execute it. *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
rev	dict.c	/^static unsigned long rev(unsigned long v) {$/;"	f	file:	signature:(unsigned long v)
rewriteAppendOnlyFile	aof.c	/^int rewriteAppendOnlyFile(char *filename) {$/;"	f	signature:(char *filename)
rewriteAppendOnlyFileBackground	aof.c	/^int rewriteAppendOnlyFileBackground(void) {$/;"	f	signature:(void)
rewriteAppendOnlyFileBackground	redis.h	/^int rewriteAppendOnlyFileBackground(void);$/;"	p	signature:(void)
rewriteClientCommandArgument	networking.c	/^void rewriteClientCommandArgument(redisClient *c, int i, robj *newval) {$/;"	f	signature:(redisClient *c, int i, robj *newval)
rewriteClientCommandArgument	redis.h	/^void rewriteClientCommandArgument(redisClient *c, int i, robj *newval);$/;"	p	signature:(redisClient *c, int i, robj *newval)
rewriteClientCommandVector	networking.c	/^void rewriteClientCommandVector(redisClient *c, int argc, ...) {$/;"	f	signature:(redisClient *c, int argc, ...)
rewriteClientCommandVector	redis.h	/^void rewriteClientCommandVector(redisClient *c, int argc, ...);$/;"	p	signature:(redisClient *c, int argc, ...)
rewriteConfig	config.c	/^int rewriteConfig(char *path) {$/;"	f	signature:(char *path)
rewriteConfig	redis.h	/^int rewriteConfig(char *path);$/;"	p	signature:(char *path)
rewriteConfigAddLineNumberToOption	config.c	/^void rewriteConfigAddLineNumberToOption(struct rewriteConfigState *state, sds option, int linenum) {$/;"	f	signature:(struct rewriteConfigState *state, sds option, int linenum)
rewriteConfigAppendLine	config.c	/^void rewriteConfigAppendLine(struct rewriteConfigState *state, sds line) {$/;"	f	signature:(struct rewriteConfigState *state, sds line)
rewriteConfigBindOption	config.c	/^void rewriteConfigBindOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigBytesOption	config.c	/^void rewriteConfigBytesOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {$/;"	f	signature:(struct rewriteConfigState *state, char *option, long long value, long long defvalue)
rewriteConfigClientoutputbufferlimitOption	config.c	/^void rewriteConfigClientoutputbufferlimitOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigDirOption	config.c	/^void rewriteConfigDirOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigEnumOption	config.c	/^void rewriteConfigEnumOption(struct rewriteConfigState *state, char *option, int value, ...) {$/;"	f	signature:(struct rewriteConfigState *state, char *option, int value, ...)
rewriteConfigFormatMemory	config.c	/^int rewriteConfigFormatMemory(char *buf, size_t len, long long bytes) {$/;"	f	signature:(char *buf, size_t len, long long bytes)
rewriteConfigGetContentFromState	config.c	/^sds rewriteConfigGetContentFromState(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigMarkAsProcessed	config.c	/^void rewriteConfigMarkAsProcessed(struct rewriteConfigState *state, char *option) {$/;"	f	signature:(struct rewriteConfigState *state, char *option)
rewriteConfigNotifykeyspaceeventsOption	config.c	/^void rewriteConfigNotifykeyspaceeventsOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigNumericalOption	config.c	/^void rewriteConfigNumericalOption(struct rewriteConfigState *state, char *option, long long value, long long defvalue) {$/;"	f	signature:(struct rewriteConfigState *state, char *option, long long value, long long defvalue)
rewriteConfigOctalOption	config.c	/^void rewriteConfigOctalOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {$/;"	f	signature:(struct rewriteConfigState *state, char *option, int value, int defvalue)
rewriteConfigOverwriteFile	config.c	/^int rewriteConfigOverwriteFile(char *configfile, sds content) {$/;"	f	signature:(char *configfile, sds content)
rewriteConfigReadOldFile	config.c	/^struct rewriteConfigState *rewriteConfigReadOldFile(char *path) {$/;"	f	signature:(char *path)
rewriteConfigReleaseState	config.c	/^void rewriteConfigReleaseState(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigRemoveOrphaned	config.c	/^void rewriteConfigRemoveOrphaned(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigRewriteLine	config.c	/^void rewriteConfigRewriteLine(struct rewriteConfigState *state, char *option, sds line, int force) {$/;"	f	signature:(struct rewriteConfigState *state, char *option, sds line, int force)
rewriteConfigRewriteLine	redis.h	/^void rewriteConfigRewriteLine(struct rewriteConfigState *state, char *option, sds line, int force);$/;"	p	signature:(struct rewriteConfigState *state, char *option, sds line, int force)
rewriteConfigSaveOption	config.c	/^void rewriteConfigSaveOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigSentinelOption	config.c	/^void rewriteConfigSentinelOption(struct rewriteConfigState *state);$/;"	p	file:	signature:(struct rewriteConfigState *state)
rewriteConfigSentinelOption	sentinel.c	/^void rewriteConfigSentinelOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigSlaveofOption	config.c	/^void rewriteConfigSlaveofOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigState	config.c	/^struct rewriteConfigState {$/;"	s	file:
rewriteConfigState	redis.h	/^struct rewriteConfigState; \/* Forward declaration to export API. *\/$/;"	x
rewriteConfigState::has_tail	config.c	/^    int has_tail;         \/* True if we already added directives that were$/;"	m	struct:rewriteConfigState	file:	access:public
rewriteConfigState::lines	config.c	/^    sds *lines;           \/* Current lines as an array of sds strings *\/$/;"	m	struct:rewriteConfigState	file:	access:public
rewriteConfigState::numlines	config.c	/^    int numlines;         \/* Number of lines in current config *\/$/;"	m	struct:rewriteConfigState	file:	access:public
rewriteConfigState::option_to_line	config.c	/^    dict *option_to_line; \/* Option -> list of config file lines map *\/$/;"	m	struct:rewriteConfigState	file:	access:public
rewriteConfigState::rewritten	config.c	/^    dict *rewritten;      \/* Dictionary of already processed options *\/$/;"	m	struct:rewriteConfigState	file:	access:public
rewriteConfigStringOption	config.c	/^void rewriteConfigStringOption(struct rewriteConfigState *state, char *option, char *value, char *defvalue) {$/;"	f	signature:(struct rewriteConfigState *state, char *option, char *value, char *defvalue)
rewriteConfigSyslogfacilityOption	config.c	/^void rewriteConfigSyslogfacilityOption(struct rewriteConfigState *state) {$/;"	f	signature:(struct rewriteConfigState *state)
rewriteConfigYesNoOption	config.c	/^void rewriteConfigYesNoOption(struct rewriteConfigState *state, char *option, int value, int defvalue) {$/;"	f	signature:(struct rewriteConfigState *state, char *option, int value, int defvalue)
rewriteHashObject	aof.c	/^int rewriteHashObject(rio *r, robj *key, robj *o) {$/;"	f	signature:(rio *r, robj *key, robj *o)
rewriteListObject	aof.c	/^int rewriteListObject(rio *r, robj *key, robj *o) {$/;"	f	signature:(rio *r, robj *key, robj *o)
rewriteSetObject	aof.c	/^int rewriteSetObject(rio *r, robj *key, robj *o) {$/;"	f	signature:(rio *r, robj *key, robj *o)
rewriteSortedSetObject	aof.c	/^int rewriteSortedSetObject(rio *r, robj *key, robj *o) {$/;"	f	signature:(rio *r, robj *key, robj *o)
rewritten	config.c	/^    dict *rewritten;      \/* Dictionary of already processed options *\/$/;"	m	struct:rewriteConfigState	file:	access:public
rfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:	access:public
rfileProc	ae.h	/^    aeFileProc *rfileProc;$/;"	m	struct:aeFileEvent	access:public
rio	rio.h	/^typedef struct _rio rio;$/;"	t	typeref:struct:_rio
rio.c	rio.c	1;"	F
rio.h	rio.h	1;"	F
rioBufferFlush	rio.c	/^static int rioBufferFlush(rio *r) {$/;"	f	file:	signature:(rio *r)
rioBufferIO	rio.c	/^static const rio rioBufferIO = {$/;"	v	file:
rioBufferRead	rio.c	/^static size_t rioBufferRead(rio *r, void *buf, size_t len) {$/;"	f	file:	signature:(rio *r, void *buf, size_t len)
rioBufferTell	rio.c	/^static off_t rioBufferTell(rio *r) {$/;"	f	file:	signature:(rio *r)
rioBufferWrite	rio.c	/^static size_t rioBufferWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:	signature:(rio *r, const void *buf, size_t len)
rioFdsetFlush	rio.c	/^static int rioFdsetFlush(rio *r) {$/;"	f	file:	signature:(rio *r)
rioFdsetIO	rio.c	/^static const rio rioFdsetIO = {$/;"	v	file:
rioFdsetRead	rio.c	/^static size_t rioFdsetRead(rio *r, void *buf, size_t len) {$/;"	f	file:	signature:(rio *r, void *buf, size_t len)
rioFdsetTell	rio.c	/^static off_t rioFdsetTell(rio *r) {$/;"	f	file:	signature:(rio *r)
rioFdsetWrite	rio.c	/^static size_t rioFdsetWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:	signature:(rio *r, const void *buf, size_t len)
rioFileFlush	rio.c	/^static int rioFileFlush(rio *r) {$/;"	f	file:	signature:(rio *r)
rioFileIO	rio.c	/^static const rio rioFileIO = {$/;"	v	file:
rioFileRead	rio.c	/^static size_t rioFileRead(rio *r, void *buf, size_t len) {$/;"	f	file:	signature:(rio *r, void *buf, size_t len)
rioFileTell	rio.c	/^static off_t rioFileTell(rio *r) {$/;"	f	file:	signature:(rio *r)
rioFileWrite	rio.c	/^static size_t rioFileWrite(rio *r, const void *buf, size_t len) {$/;"	f	file:	signature:(rio *r, const void *buf, size_t len)
rioFlush	rio.h	/^static inline int rioFlush(rio *r) {$/;"	f	signature:(rio *r)
rioFreeFdset	rio.c	/^void rioFreeFdset(rio *r) {$/;"	f	signature:(rio *r)
rioGenericUpdateChecksum	rio.c	/^void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len) {$/;"	f	signature:(rio *r, const void *buf, size_t len)
rioGenericUpdateChecksum	rio.h	/^void rioGenericUpdateChecksum(rio *r, const void *buf, size_t len);$/;"	p	signature:(rio *r, const void *buf, size_t len)
rioInitWithBuffer	rio.c	/^void rioInitWithBuffer(rio *r, sds s) {$/;"	f	signature:(rio *r, sds s)
rioInitWithBuffer	rio.h	/^void rioInitWithBuffer(rio *r, sds s);$/;"	p	signature:(rio *r, sds s)
rioInitWithFdset	rio.c	/^void rioInitWithFdset(rio *r, int *fds, int numfds) {$/;"	f	signature:(rio *r, int *fds, int numfds)
rioInitWithFdset	rio.h	/^void rioInitWithFdset(rio *r, int *fds, int numfds);$/;"	p	signature:(rio *r, int *fds, int numfds)
rioInitWithFile	rio.c	/^void rioInitWithFile(rio *r, FILE *fp) {$/;"	f	signature:(rio *r, FILE *fp)
rioInitWithFile	rio.h	/^void rioInitWithFile(rio *r, FILE *fp);$/;"	p	signature:(rio *r, FILE *fp)
rioRead	rio.h	/^static inline size_t rioRead(rio *r, void *buf, size_t len) {$/;"	f	signature:(rio *r, void *buf, size_t len)
rioSetAutoSync	rio.c	/^void rioSetAutoSync(rio *r, off_t bytes) {$/;"	f	signature:(rio *r, off_t bytes)
rioSetAutoSync	rio.h	/^void rioSetAutoSync(rio *r, off_t bytes);$/;"	p	signature:(rio *r, off_t bytes)
rioTell	rio.h	/^static inline off_t rioTell(rio *r) {$/;"	f	signature:(rio *r)
rioWrite	rio.h	/^static inline size_t rioWrite(rio *r, const void *buf, size_t len) {$/;"	f	signature:(rio *r, const void *buf, size_t len)
rioWriteBulkCount	rio.c	/^size_t rioWriteBulkCount(rio *r, char prefix, int count) {$/;"	f	signature:(rio *r, char prefix, int count)
rioWriteBulkCount	rio.h	/^size_t rioWriteBulkCount(rio *r, char prefix, int count);$/;"	p	signature:(rio *r, char prefix, int count)
rioWriteBulkDouble	rio.c	/^size_t rioWriteBulkDouble(rio *r, double d) {$/;"	f	signature:(rio *r, double d)
rioWriteBulkDouble	rio.h	/^size_t rioWriteBulkDouble(rio *r, double d);$/;"	p	signature:(rio *r, double d)
rioWriteBulkLongLong	rio.c	/^size_t rioWriteBulkLongLong(rio *r, long long l) {$/;"	f	signature:(rio *r, long long l)
rioWriteBulkLongLong	rio.h	/^size_t rioWriteBulkLongLong(rio *r, long long l);$/;"	p	signature:(rio *r, long long l)
rioWriteBulkObject	aof.c	/^int rioWriteBulkObject(rio *r, robj *obj) {$/;"	f	signature:(rio *r, robj *obj)
rioWriteBulkString	rio.c	/^size_t rioWriteBulkString(rio *r, const char *buf, size_t len) {$/;"	f	signature:(rio *r, const char *buf, size_t len)
rioWriteBulkString	rio.h	/^size_t rioWriteBulkString(rio *r, const char *buf, size_t len);$/;"	p	signature:(rio *r, const char *buf, size_t len)
rioWriteHashIteratorCursor	aof.c	/^static int rioWriteHashIteratorCursor(rio *r, hashTypeIterator *hi, int what) {$/;"	f	file:	signature:(rio *r, hashTypeIterator *hi, int what)
robj	redis.h	/^} robj;$/;"	t	typeref:struct:redisObject
rol	sha1.c	/^#define rol(/;"	d	file:
roleCommand	redis.h	/^void roleCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
roleCommand	replication.c	/^void roleCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
role_reported	sentinel.c	/^    int role_reported;$/;"	m	struct:sentinelRedisInstance	file:	access:public
role_reported_time	sentinel.c	/^    mstime_t role_reported_time;$/;"	m	struct:sentinelRedisInstance	file:	access:public
roslaveerr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
rpop	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
rpopCommand	redis.h	/^                        *rpopCommand;$/;"	m	struct:redisServer	typeref:struct:redisServer::	access:public
rpopCommand	redis.h	/^void rpopCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
rpopCommand	t_list.c	/^void rpopCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
rpoplpushCommand	redis.h	/^void rpoplpushCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
rpoplpushCommand	t_list.c	/^void rpoplpushCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
rpoplpushHandlePush	t_list.c	/^void rpoplpushHandlePush(redisClient *c, robj *dstkey, robj *dstobj, robj *value) {$/;"	f	signature:(redisClient *c, robj *dstkey, robj *dstobj, robj *value)
rpushCommand	redis.h	/^void rpushCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
rpushCommand	t_list.c	/^void rpushCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
rpushxCommand	redis.h	/^void rpushxCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
rpushxCommand	t_list.c	/^void rpushxCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
run_with_period	redis.h	/^#define run_with_period(/;"	d
runid	redis.h	/^    char runid[REDIS_RUN_ID_SIZE+1];  \/* ID always different at every exec. *\/$/;"	m	struct:redisServer	access:public
runid	sentinel.c	/^    char *runid;    \/* run ID of this instance. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
runid	sentinel.c	/^    char *runid;$/;"	m	struct:sentinelLeader	file:	access:public
running_scripts	sentinel.c	/^    int running_scripts;    \/* Number of scripts in execution right now. *\/$/;"	m	struct:sentinelState	file:	access:public
s64	dict.h	/^        int64_t s64;$/;"	m	union:dictEntry::__anon11	access:public
s_down_since_time	sentinel.c	/^    mstime_t s_down_since_time; \/* Subjectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
saddCommand	redis.h	/^void saddCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
saddCommand	t_set.c	/^void saddCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
safe	dict.h	/^    int table, safe;$/;"	m	struct:dictIterator	access:public
sameobjecterr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
sample	sparkline.h	/^struct sample {$/;"	s
sample::label	sparkline.h	/^    char *label;$/;"	m	struct:sample	access:public
sample::value	sparkline.h	/^    double value;$/;"	m	struct:sample	access:public
samples	latency.h	/^    struct latencySample samples[LATENCY_TS_LEN]; \/* Latest history. *\/$/;"	m	struct:latencyTimeSeries	typeref:struct:latencyTimeSeries::latencySample	access:public
samples	latency.h	/^    uint32_t samples;       \/* Number of non-zero samples. *\/$/;"	m	struct:latencyStats	access:public
samples	redis.h	/^        long long samples[REDIS_METRIC_SAMPLES];$/;"	m	struct:redisServer::__anon16	access:public
samples	sparkline.h	/^    struct sample *samples;$/;"	m	struct:sequence	typeref:struct:sequence::sample	access:public
saveCommand	rdb.c	/^void saveCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
saveCommand	redis.h	/^void saveCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
saveparam	redis.h	/^struct saveparam {$/;"	s
saveparam::changes	redis.h	/^    int changes;$/;"	m	struct:saveparam	access:public
saveparam::seconds	redis.h	/^    time_t seconds;$/;"	m	struct:saveparam	access:public
saveparams	redis.h	/^    struct saveparam *saveparams;   \/* Save points array for RDB *\/$/;"	m	struct:redisServer	typeref:struct:redisServer::saveparam	access:public
saveparamslen	redis.h	/^    int saveparamslen;              \/* Number of saving points *\/$/;"	m	struct:redisServer	access:public
scanCallback	db.c	/^void scanCallback(void *privdata, const dictEntry *de) {$/;"	f	signature:(void *privdata, const dictEntry *de)
scanCommand	db.c	/^void scanCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
scanCommand	redis.h	/^void scanCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
scanGenericCommand	db.c	/^void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor) {$/;"	f	signature:(redisClient *c, robj *o, unsigned long cursor)
scanGenericCommand	redis.h	/^void scanGenericCommand(redisClient *c, robj *o, unsigned long cursor);$/;"	p	signature:(redisClient *c, robj *o, unsigned long cursor)
scanMode	redis-cli.c	/^static void scanMode(void) {$/;"	f	file:	signature:(void)
scan_mode	redis-cli.c	/^    int scan_mode;$/;"	m	struct:config	file:	access:public
scardCommand	redis.h	/^void scardCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
scardCommand	t_set.c	/^void scardCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
score	redis.h	/^        double score;$/;"	m	union:_redisSortObject::__anon17	access:public
score	redis.h	/^    double score;$/;"	m	struct:zskiplistNode	access:public
score	t_zset.c	/^    double score;$/;"	m	struct:__anon36	file:	access:public
scriptCommand	redis.h	/^void scriptCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
scriptCommand	scripting.c	/^void scriptCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
scripting.c	scripting.c	1;"	F
scriptingEnableGlobalsProtection	scripting.c	/^void scriptingEnableGlobalsProtection(lua_State *lua) {$/;"	f	signature:(lua_State *lua)
scriptingInit	redis.h	/^void scriptingInit(void);$/;"	p	signature:(void)
scriptingInit	scripting.c	/^void scriptingInit(void) {$/;"	f	signature:(void)
scriptingRelease	scripting.c	/^void scriptingRelease(void) {$/;"	f	signature:(void)
scriptingReset	scripting.c	/^void scriptingReset(void) {$/;"	f	signature:(void)
scripts_queue	sentinel.c	/^    list *scripts_queue;    \/* Queue of user scripts to execute. *\/$/;"	m	struct:sentinelState	file:	access:public
sdiffCommand	redis.h	/^void sdiffCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sdiffCommand	t_set.c	/^void sdiffCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sdiffstoreCommand	redis.h	/^void sdiffstoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sdiffstoreCommand	t_set.c	/^void sdiffstoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sds	sds.h	/^typedef char *sds;$/;"	t
sds.c	sds.c	1;"	F
sds.h	sds.h	1;"	F
sdsAllocSize	sds.c	/^size_t sdsAllocSize(sds s) {$/;"	f	signature:(sds s)
sdsAllocSize	sds.h	/^size_t sdsAllocSize(sds s);$/;"	p	signature:(sds s)
sdsEncodedObject	redis.h	/^#define sdsEncodedObject(/;"	d
sdsIncrLen	sds.c	/^void sdsIncrLen(sds s, int incr) {$/;"	f	signature:(sds s, int incr)
sdsIncrLen	sds.h	/^void sdsIncrLen(sds s, int incr);$/;"	p	signature:(sds s, int incr)
sdsMakeRoomFor	sds.c	/^sds sdsMakeRoomFor(sds s, size_t addlen) {$/;"	f	signature:(sds s, size_t addlen)
sdsMakeRoomFor	sds.h	/^sds sdsMakeRoomFor(sds s, size_t addlen);$/;"	p	signature:(sds s, size_t addlen)
sdsRemoveFreeSpace	sds.c	/^sds sdsRemoveFreeSpace(sds s) {$/;"	f	signature:(sds s)
sdsRemoveFreeSpace	sds.h	/^sds sdsRemoveFreeSpace(sds s);$/;"	p	signature:(sds s)
sdsavail	sds.h	/^size_t sdsavail(const sds s);$/;"	p	signature:(const sds s)
sdsavail	sds.h	/^static inline size_t sdsavail(const sds s) {$/;"	f	signature:(const sds s)
sdscat	sds.c	/^sds sdscat(sds s, const char *t) {$/;"	f	signature:(sds s, const char *t)
sdscat	sds.h	/^sds sdscat(sds s, const char *t);$/;"	p	signature:(sds s, const char *t)
sdscatfmt	sds.c	/^sds sdscatfmt(sds s, char const *fmt, ...) {$/;"	f	signature:(sds s, char const *fmt, ...)
sdscatfmt	sds.h	/^sds sdscatfmt(sds s, char const *fmt, ...);$/;"	p	signature:(sds s, char const *fmt, ...)
sdscatlen	sds.c	/^sds sdscatlen(sds s, const void *t, size_t len) {$/;"	f	signature:(sds s, const void *t, size_t len)
sdscatlen	sds.h	/^sds sdscatlen(sds s, const void *t, size_t len);$/;"	p	signature:(sds s, const void *t, size_t len)
sdscatprintf	sds.c	/^sds sdscatprintf(sds s, const char *fmt, ...) {$/;"	f	signature:(sds s, const char *fmt, ...)
sdscatprintf	sds.h	/^sds sdscatprintf(sds s, const char *fmt, ...)$/;"	p	signature:(sds s, const char *fmt, ...)
sdscatprintf	sds.h	/^sds sdscatprintf(sds s, const char *fmt, ...);$/;"	p	signature:(sds s, const char *fmt, ...)
sdscatrepr	sds.c	/^sds sdscatrepr(sds s, const char *p, size_t len) {$/;"	f	signature:(sds s, const char *p, size_t len)
sdscatrepr	sds.h	/^sds sdscatrepr(sds s, const char *p, size_t len);$/;"	p	signature:(sds s, const char *p, size_t len)
sdscatsds	sds.c	/^sds sdscatsds(sds s, const sds t) {$/;"	f	signature:(sds s, const sds t)
sdscatsds	sds.h	/^sds sdscatsds(sds s, const sds t);$/;"	p	signature:(sds s, const sds t)
sdscatvprintf	sds.c	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap) {$/;"	f	signature:(sds s, const char *fmt, va_list ap)
sdscatvprintf	sds.h	/^sds sdscatvprintf(sds s, const char *fmt, va_list ap);$/;"	p	signature:(sds s, const char *fmt, va_list ap)
sdsclear	sds.c	/^void sdsclear(sds s) {$/;"	f	signature:(sds s)
sdsclear	sds.h	/^void sdsclear(sds s);$/;"	p	signature:(sds s)
sdscmp	sds.c	/^int sdscmp(const sds s1, const sds s2) {$/;"	f	signature:(const sds s1, const sds s2)
sdscmp	sds.h	/^int sdscmp(const sds s1, const sds s2);$/;"	p	signature:(const sds s1, const sds s2)
sdscpy	sds.c	/^sds sdscpy(sds s, const char *t) {$/;"	f	signature:(sds s, const char *t)
sdscpy	sds.h	/^sds sdscpy(sds s, const char *t);$/;"	p	signature:(sds s, const char *t)
sdscpylen	sds.c	/^sds sdscpylen(sds s, const char *t, size_t len) {$/;"	f	signature:(sds s, const char *t, size_t len)
sdscpylen	sds.h	/^sds sdscpylen(sds s, const char *t, size_t len);$/;"	p	signature:(sds s, const char *t, size_t len)
sdsdup	sds.c	/^sds sdsdup(const sds s) {$/;"	f	signature:(const sds s)
sdsdup	sds.h	/^sds sdsdup(const sds s);$/;"	p	signature:(const sds s)
sdsempty	sds.c	/^sds sdsempty(void) {$/;"	f	signature:(void)
sdsempty	sds.h	/^sds sdsempty(void);$/;"	p	signature:(void)
sdsfree	sds.c	/^void sdsfree(sds s) {$/;"	f	signature:(sds s)
sdsfree	sds.h	/^void sdsfree(sds s);$/;"	p	signature:(sds s)
sdsfreesplitres	sds.c	/^void sdsfreesplitres(sds *tokens, int count) {$/;"	f	signature:(sds *tokens, int count)
sdsfreesplitres	sds.h	/^void sdsfreesplitres(sds *tokens, int count);$/;"	p	signature:(sds *tokens, int count)
sdsfromlonglong	sds.c	/^sds sdsfromlonglong(long long value) {$/;"	f	signature:(long long value)
sdsfromlonglong	sds.h	/^sds sdsfromlonglong(long long value);$/;"	p	signature:(long long value)
sdsgrowzero	sds.c	/^sds sdsgrowzero(sds s, size_t len) {$/;"	f	signature:(sds s, size_t len)
sdsgrowzero	sds.h	/^sds sdsgrowzero(sds s, size_t len);$/;"	p	signature:(sds s, size_t len)
sdshdr	sds.h	/^struct sdshdr {$/;"	s
sdshdr::buf	sds.h	/^    char buf[];$/;"	m	struct:sdshdr	access:public
sdshdr::free	sds.h	/^    unsigned int free;$/;"	m	struct:sdshdr	access:public
sdshdr::len	sds.h	/^    unsigned int len;$/;"	m	struct:sdshdr	access:public
sdsjoin	sds.c	/^sds sdsjoin(char **argv, int argc, char *sep) {$/;"	f	signature:(char **argv, int argc, char *sep)
sdsjoin	sds.h	/^sds sdsjoin(char **argv, int argc, char *sep);$/;"	p	signature:(char **argv, int argc, char *sep)
sdslen	sds.h	/^size_t sdslen(const sds s);$/;"	p	signature:(const sds s)
sdslen	sds.h	/^static inline size_t sdslen(const sds s) {$/;"	f	signature:(const sds s)
sdsll2str	sds.c	/^int sdsll2str(char *s, long long value) {$/;"	f	signature:(char *s, long long value)
sdsmapchars	sds.c	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {$/;"	f	signature:(sds s, const char *from, const char *to, size_t setlen)
sdsmapchars	sds.h	/^sds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);$/;"	p	signature:(sds s, const char *from, const char *to, size_t setlen)
sdsnew	sds.c	/^sds sdsnew(const char *init) {$/;"	f	signature:(const char *init)
sdsnew	sds.h	/^sds sdsnew(const char *init);$/;"	p	signature:(const char *init)
sdsnewlen	sds.c	/^sds sdsnewlen(const void *init, size_t initlen) {$/;"	f	signature:(const void *init, size_t initlen)
sdsnewlen	sds.h	/^sds sdsnewlen(const void *init, size_t initlen);$/;"	p	signature:(const void *init, size_t initlen)
sdsrange	sds.c	/^void sdsrange(sds s, int start, int end) {$/;"	f	signature:(sds s, int start, int end)
sdsrange	sds.h	/^void sdsrange(sds s, int start, int end);$/;"	p	signature:(sds s, int start, int end)
sdssplitargs	sds.c	/^sds *sdssplitargs(const char *line, int *argc) {$/;"	f	signature:(const char *line, int *argc)
sdssplitargs	sds.h	/^sds *sdssplitargs(const char *line, int *argc);$/;"	p	signature:(const char *line, int *argc)
sdssplitlen	sds.c	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count) {$/;"	f	signature:(const char *s, int len, const char *sep, int seplen, int *count)
sdssplitlen	sds.h	/^sds *sdssplitlen(const char *s, int len, const char *sep, int seplen, int *count);$/;"	p	signature:(const char *s, int len, const char *sep, int seplen, int *count)
sdstolower	sds.c	/^void sdstolower(sds s) {$/;"	f	signature:(sds s)
sdstolower	sds.h	/^void sdstolower(sds s);$/;"	p	signature:(sds s)
sdstoupper	sds.c	/^void sdstoupper(sds s) {$/;"	f	signature:(sds s)
sdstoupper	sds.h	/^void sdstoupper(sds s);$/;"	p	signature:(sds s)
sdstrim	sds.c	/^sds sdstrim(sds s, const char *cset) {$/;"	f	signature:(sds s, const char *cset)
sdstrim	sds.h	/^sds sdstrim(sds s, const char *cset);$/;"	p	signature:(sds s, const char *cset)
sdsull2str	sds.c	/^int sdsull2str(char *s, unsigned long long v) {$/;"	f	signature:(char *s, unsigned long long v)
sdsupdatelen	sds.c	/^void sdsupdatelen(sds s) {$/;"	f	signature:(sds s)
sdsupdatelen	sds.h	/^void sdsupdatelen(sds s);$/;"	p	signature:(sds s)
seconds	redis.h	/^    time_t seconds;$/;"	m	struct:saveparam	access:public
select	redis.h	/^    *select[REDIS_SHARED_SELECT_CMDS],$/;"	m	struct:sharedObjectsStruct	access:public
selectCommand	db.c	/^void selectCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
selectCommand	redis.h	/^void selectCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
selectDb	db.c	/^int selectDb(redisClient *c, int id) {$/;"	f	signature:(redisClient *c, int id)
selectDb	redis.h	/^int selectDb(redisClient *c, int id);$/;"	p	signature:(redisClient *c, int id)
sendBulkToSlave	replication.c	/^void sendBulkToSlave(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
sendReplyToClient	networking.c	/^void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
sendReplyToClient	redis.h	/^void sendReplyToClient(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
sendScan	redis-cli.c	/^static redisReply *sendScan(unsigned long long *it) {$/;"	f	file:	signature:(unsigned long long *it)
sendSync	redis-cli.c	/^unsigned long long sendSync(int fd) {$/;"	f	signature:(int fd)
sendSynchronousCommand	replication.c	/^char *sendSynchronousCommand(int flags, int fd, ...) {$/;"	f	signature:(int flags, int fd, ...)
sender	cluster.h	/^    char sender[REDIS_CLUSTER_NAMELEN]; \/* Name of the sender node *\/$/;"	m	struct:__anon9	access:public
sentinel	sentinel.c	/^} sentinel;$/;"	v	typeref:struct:sentinelState
sentinel.c	sentinel.c	1;"	F
sentinelAbortFailover	sentinel.c	/^void sentinelAbortFailover(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelAbortFailover	sentinel.c	/^void sentinelAbortFailover(sentinelRedisInstance *ri);$/;"	p	file:	signature:(sentinelRedisInstance *ri)
sentinelAddFlagsToDictOfRedisInstances	sentinel.c	/^void sentinelAddFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f	signature:(dict *instances, int flags)
sentinelAddr	sentinel.c	/^typedef struct sentinelAddr {$/;"	s	file:
sentinelAddr	sentinel.c	/^} sentinelAddr;$/;"	t	typeref:struct:sentinelAddr	file:
sentinelAddr::ip	sentinel.c	/^    char *ip;$/;"	m	struct:sentinelAddr	file:	access:public
sentinelAddr::port	sentinel.c	/^    int port;$/;"	m	struct:sentinelAddr	file:	access:public
sentinelAddrIsEqual	sentinel.c	/^int sentinelAddrIsEqual(sentinelAddr *a, sentinelAddr *b) {$/;"	f	signature:(sentinelAddr *a, sentinelAddr *b)
sentinelAskMasterStateToOtherSentinels	sentinel.c	/^void sentinelAskMasterStateToOtherSentinels(sentinelRedisInstance *master, int flags) {$/;"	f	signature:(sentinelRedisInstance *master, int flags)
sentinelCallClientReconfScript	sentinel.c	/^void sentinelCallClientReconfScript(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to) {$/;"	f	signature:(sentinelRedisInstance *master, int role, char *state, sentinelAddr *from, sentinelAddr *to)
sentinelCheckObjectivelyDown	sentinel.c	/^void sentinelCheckObjectivelyDown(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelCheckSubjectivelyDown	sentinel.c	/^void sentinelCheckSubjectivelyDown(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelCheckTiltCondition	sentinel.c	/^void sentinelCheckTiltCondition(void) {$/;"	f	signature:(void)
sentinelCollectTerminatedScripts	sentinel.c	/^void sentinelCollectTerminatedScripts(void) {$/;"	f	signature:(void)
sentinelCommand	sentinel.c	/^void sentinelCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sentinelCommand	sentinel.c	/^void sentinelCommand(redisClient *c);$/;"	p	file:	signature:(redisClient *c)
sentinelDelFlagsToDictOfRedisInstances	sentinel.c	/^void sentinelDelFlagsToDictOfRedisInstances(dict *instances, int flags) {$/;"	f	signature:(dict *instances, int flags)
sentinelDiscardReplyCallback	sentinel.c	/^void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelDiscardReplyCallback	sentinel.c	/^void sentinelDiscardReplyCallback(redisAsyncContext *c, void *reply, void *privdata);$/;"	p	file:	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelDisconnectCallback	sentinel.c	/^void sentinelDisconnectCallback(const redisAsyncContext *c, int status) {$/;"	f	signature:(const redisAsyncContext *c, int status)
sentinelDisconnectCallback	sentinel.c	/^void sentinelDisconnectCallback(const redisAsyncContext *c, int status);$/;"	p	file:	signature:(const redisAsyncContext *c, int status)
sentinelDisconnectInstanceFromContext	sentinel.c	/^void sentinelDisconnectInstanceFromContext(const redisAsyncContext *c) {$/;"	f	signature:(const redisAsyncContext *c)
sentinelDisconnectInstanceFromContext	sentinel.c	/^void sentinelDisconnectInstanceFromContext(const redisAsyncContext *c);$/;"	p	file:	signature:(const redisAsyncContext *c)
sentinelEvent	sentinel.c	/^void sentinelEvent(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...);$/;"	p	file:	signature:(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...)
sentinelEvent	sentinel.c	/^void sentinelEvent(int level, char *type, sentinelRedisInstance *ri,$/;"	f	signature:(int level, char *type, sentinelRedisInstance *ri, const char *fmt, ...)
sentinelFailoverDetectEnd	sentinel.c	/^void sentinelFailoverDetectEnd(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelFailoverReconfNextSlave	sentinel.c	/^void sentinelFailoverReconfNextSlave(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelFailoverSelectSlave	sentinel.c	/^void sentinelFailoverSelectSlave(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelFailoverSendSlaveOfNoOne	sentinel.c	/^void sentinelFailoverSendSlaveOfNoOne(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelFailoverStateMachine	sentinel.c	/^void sentinelFailoverStateMachine(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelFailoverStateStr	sentinel.c	/^const char *sentinelFailoverStateStr(int state) {$/;"	f	signature:(int state)
sentinelFailoverSwitchToPromotedSlave	sentinel.c	/^void sentinelFailoverSwitchToPromotedSlave(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelFailoverWaitPromotion	sentinel.c	/^void sentinelFailoverWaitPromotion(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelFailoverWaitStart	sentinel.c	/^void sentinelFailoverWaitStart(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelFlushConfig	sentinel.c	/^void sentinelFlushConfig(void) {$/;"	f	signature:(void)
sentinelFlushConfig	sentinel.c	/^void sentinelFlushConfig(void);$/;"	p	file:	signature:(void)
sentinelForceHelloUpdateDictOfRedisInstances	sentinel.c	/^void sentinelForceHelloUpdateDictOfRedisInstances(dict *instances) {$/;"	f	signature:(dict *instances)
sentinelForceHelloUpdateForMaster	sentinel.c	/^int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelForceHelloUpdateForMaster	sentinel.c	/^int sentinelForceHelloUpdateForMaster(sentinelRedisInstance *master);$/;"	p	file:	signature:(sentinelRedisInstance *master)
sentinelGenerateInitialMonitorEvents	sentinel.c	/^void sentinelGenerateInitialMonitorEvents(void) {$/;"	f	signature:(void)
sentinelGenerateInitialMonitorEvents	sentinel.c	/^void sentinelGenerateInitialMonitorEvents(void);$/;"	p	file:	signature:(void)
sentinelGetCurrentMasterAddress	sentinel.c	/^sentinelAddr *sentinelGetCurrentMasterAddress(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelGetLeader	sentinel.c	/^char *sentinelGetLeader(sentinelRedisInstance *master, uint64_t epoch) {$/;"	f	signature:(sentinelRedisInstance *master, uint64_t epoch)
sentinelGetMasterByName	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByName(char *name) {$/;"	f	signature:(char *name)
sentinelGetMasterByName	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByName(char *name);$/;"	p	file:	signature:(char *name)
sentinelGetMasterByNameOrReplyError	sentinel.c	/^sentinelRedisInstance *sentinelGetMasterByNameOrReplyError(redisClient *c,$/;"	f	signature:(redisClient *c, robj *name)
sentinelGetObjectiveLeader	sentinel.c	/^char *sentinelGetObjectiveLeader(sentinelRedisInstance *master);$/;"	p	file:	signature:(sentinelRedisInstance *master)
sentinelGetScriptListNodeByPid	sentinel.c	/^listNode *sentinelGetScriptListNodeByPid(pid_t pid) {$/;"	f	signature:(pid_t pid)
sentinelGetSubjectiveLeader	sentinel.c	/^char *sentinelGetSubjectiveLeader(sentinelRedisInstance *master);$/;"	p	file:	signature:(sentinelRedisInstance *master)
sentinelHandleConfiguration	redis.h	/^char *sentinelHandleConfiguration(char **argv, int argc);$/;"	p	signature:(char **argv, int argc)
sentinelHandleConfiguration	sentinel.c	/^char *sentinelHandleConfiguration(char **argv, int argc) {$/;"	f	signature:(char **argv, int argc)
sentinelHandleDictOfRedisInstances	sentinel.c	/^void sentinelHandleDictOfRedisInstances(dict *instances) {$/;"	f	signature:(dict *instances)
sentinelHandleRedisInstance	sentinel.c	/^void sentinelHandleRedisInstance(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelInfoCommand	sentinel.c	/^void sentinelInfoCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sentinelInfoCommand	sentinel.c	/^void sentinelInfoCommand(redisClient *c);$/;"	p	file:	signature:(redisClient *c)
sentinelInfoReplyCallback	sentinel.c	/^void sentinelInfoReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelIsQuorumReachable	sentinel.c	/^int sentinelIsQuorumReachable(sentinelRedisInstance *master, int *usableptr) {$/;"	f	signature:(sentinelRedisInstance *master, int *usableptr)
sentinelIsRunning	redis.h	/^void sentinelIsRunning(void);$/;"	p	signature:(void)
sentinelIsRunning	sentinel.c	/^void sentinelIsRunning(void) {$/;"	f	signature:(void)
sentinelKillLink	sentinel.c	/^void sentinelKillLink(sentinelRedisInstance *ri, redisAsyncContext *c) {$/;"	f	signature:(sentinelRedisInstance *ri, redisAsyncContext *c)
sentinelKillLink	sentinel.c	/^void sentinelKillLink(sentinelRedisInstance *ri, redisAsyncContext *c);$/;"	p	file:	signature:(sentinelRedisInstance *ri, redisAsyncContext *c)
sentinelKillTimedoutScripts	sentinel.c	/^void sentinelKillTimedoutScripts(void) {$/;"	f	signature:(void)
sentinelLeader	sentinel.c	/^struct sentinelLeader {$/;"	s	file:
sentinelLeader::runid	sentinel.c	/^    char *runid;$/;"	m	struct:sentinelLeader	file:	access:public
sentinelLeader::votes	sentinel.c	/^    unsigned long votes;$/;"	m	struct:sentinelLeader	file:	access:public
sentinelLeaderIncr	sentinel.c	/^int sentinelLeaderIncr(dict *counters, char *runid) {$/;"	f	signature:(dict *counters, char *runid)
sentinelLinkEstablishedCallback	sentinel.c	/^void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status) {$/;"	f	signature:(const redisAsyncContext *c, int status)
sentinelLinkEstablishedCallback	sentinel.c	/^void sentinelLinkEstablishedCallback(const redisAsyncContext *c, int status);$/;"	p	file:	signature:(const redisAsyncContext *c, int status)
sentinelMasterLooksSane	sentinel.c	/^int sentinelMasterLooksSane(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelPendingScriptsCommand	sentinel.c	/^void sentinelPendingScriptsCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sentinelPingReplyCallback	sentinel.c	/^void sentinelPingReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelProcessHelloMessage	sentinel.c	/^void sentinelProcessHelloMessage(char *hello, int hello_len) {$/;"	f	signature:(char *hello, int hello_len)
sentinelPropagateDownAfterPeriod	sentinel.c	/^void sentinelPropagateDownAfterPeriod(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelPublishCommand	sentinel.c	/^void sentinelPublishCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sentinelPublishCommand	sentinel.c	/^void sentinelPublishCommand(redisClient *c);$/;"	p	file:	signature:(redisClient *c)
sentinelPublishReplyCallback	sentinel.c	/^void sentinelPublishReplyCallback(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReceiveHelloMessages	sentinel.c	/^void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReceiveHelloMessages	sentinel.c	/^void sentinelReceiveHelloMessages(redisAsyncContext *c, void *reply, void *privdata);$/;"	p	file:	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReceiveIsMasterDownReply	sentinel.c	/^void sentinelReceiveIsMasterDownReply(redisAsyncContext *c, void *reply, void *privdata) {$/;"	f	signature:(redisAsyncContext *c, void *reply, void *privdata)
sentinelReconnectInstance	sentinel.c	/^void sentinelReconnectInstance(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelRedisInstance	sentinel.c	/^typedef struct sentinelRedisInstance {$/;"	s	file:
sentinelRedisInstance	sentinel.c	/^} sentinelRedisInstance;$/;"	t	typeref:struct:sentinelRedisInstance	file:
sentinelRedisInstance::addr	sentinel.c	/^    sentinelAddr *addr; \/* Master host. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::auth_pass	sentinel.c	/^    char *auth_pass;    \/* Password to use for AUTH against master & slaves. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::cc	sentinel.c	/^    redisAsyncContext *cc; \/* Hiredis context for commands. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::cc_conn_time	sentinel.c	/^    mstime_t cc_conn_time; \/* cc connection time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::client_reconfig_script	sentinel.c	/^    char *client_reconfig_script;$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::config_epoch	sentinel.c	/^    uint64_t config_epoch;  \/* Configuration epoch. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::down_after_period	sentinel.c	/^    mstime_t down_after_period; \/* Consider it down after that period. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_delay_logged	sentinel.c	/^    mstime_t failover_delay_logged; \/* For what failover_start_time value we$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_epoch	sentinel.c	/^    uint64_t failover_epoch; \/* Epoch of the currently started failover. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_start_time	sentinel.c	/^    mstime_t failover_start_time;   \/* Last failover attempt start time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_state	sentinel.c	/^    int failover_state; \/* See SENTINEL_FAILOVER_STATE_* defines. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_state_change_time	sentinel.c	/^    mstime_t failover_state_change_time;$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::failover_timeout	sentinel.c	/^    mstime_t failover_timeout;      \/* Max time to refresh failover state. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::flags	sentinel.c	/^    int flags;      \/* See SRI_... defines *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::info_refresh	sentinel.c	/^    mstime_t info_refresh;  \/* Time at which we received INFO output from it. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_avail_time	sentinel.c	/^    mstime_t last_avail_time; \/* Last time the instance replied to ping with$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_hello_time	sentinel.c	/^    mstime_t last_hello_time; \/* Only used if SRI_SENTINEL is set. Last time$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_master_down_reply_time	sentinel.c	/^    mstime_t last_master_down_reply_time; \/* Time of last reply to$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_ping_time	sentinel.c	/^    mstime_t last_ping_time;  \/* Last time a pending ping was sent in the$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_pong_time	sentinel.c	/^    mstime_t last_pong_time;  \/* Last time the instance replied to ping,$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::last_pub_time	sentinel.c	/^    mstime_t last_pub_time;   \/* Last time we sent hello via Pub\/Sub. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::leader	sentinel.c	/^    char *leader;       \/* If this is a master instance, this is the runid of$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::leader_epoch	sentinel.c	/^    uint64_t leader_epoch; \/* Epoch of the 'leader' field. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::master	sentinel.c	/^    struct sentinelRedisInstance *master; \/* Master instance if it's slave. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
sentinelRedisInstance::master_link_down_time	sentinel.c	/^    mstime_t master_link_down_time; \/* Slave replication link down time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::name	sentinel.c	/^    char *name;     \/* Master name from the point of view of this sentinel. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::notification_script	sentinel.c	/^    char *notification_script;$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::o_down_since_time	sentinel.c	/^    mstime_t o_down_since_time; \/* Objectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::parallel_syncs	sentinel.c	/^    int parallel_syncs; \/* How many slaves to reconfigure at same time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::pc	sentinel.c	/^    redisAsyncContext *pc; \/* Hiredis context for Pub \/ Sub. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::pc_conn_time	sentinel.c	/^    mstime_t pc_conn_time; \/* pc connection time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::pc_last_activity	sentinel.c	/^    mstime_t pc_last_activity; \/* Last time we received any message. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::pending_commands	sentinel.c	/^    int pending_commands;   \/* Number of commands sent waiting for a reply. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::promoted_slave	sentinel.c	/^    struct sentinelRedisInstance *promoted_slave; \/* Promoted slave instance. *\/$/;"	m	struct:sentinelRedisInstance	typeref:struct:sentinelRedisInstance::sentinelRedisInstance	file:	access:public
sentinelRedisInstance::quorum	sentinel.c	/^    unsigned int quorum;\/* Number of sentinels that need to agree on failure. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::role_reported	sentinel.c	/^    int role_reported;$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::role_reported_time	sentinel.c	/^    mstime_t role_reported_time;$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::runid	sentinel.c	/^    char *runid;    \/* run ID of this instance. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::s_down_since_time	sentinel.c	/^    mstime_t s_down_since_time; \/* Subjectively down since time. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::sentinels	sentinel.c	/^    dict *sentinels;    \/* Other sentinels monitoring the same master. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_conf_change_time	sentinel.c	/^    mstime_t slave_conf_change_time; \/* Last time slave master addr changed. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_master_host	sentinel.c	/^    char *slave_master_host;    \/* Master host as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_master_link_status	sentinel.c	/^    int slave_master_link_status; \/* Master link status as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_master_port	sentinel.c	/^    int slave_master_port;      \/* Master port as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_priority	sentinel.c	/^    int slave_priority; \/* Slave priority according to its INFO output. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_reconf_sent_time	sentinel.c	/^    mstime_t slave_reconf_sent_time; \/* Time at which we sent SLAVE OF <new> *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slave_repl_offset	sentinel.c	/^    unsigned long long slave_repl_offset; \/* Slave replication offset. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstance::slaves	sentinel.c	/^    dict *slaves;       \/* Slaves for this master instance. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentinelRedisInstanceLookupSlave	sentinel.c	/^sentinelRedisInstance *sentinelRedisInstanceLookupSlave($/;"	f	signature:( sentinelRedisInstance *ri, char *ip, int port)
sentinelRedisInstanceNoDownFor	sentinel.c	/^int sentinelRedisInstanceNoDownFor(sentinelRedisInstance *ri, mstime_t ms) {$/;"	f	signature:(sentinelRedisInstance *ri, mstime_t ms)
sentinelRedisInstanceTypeStr	sentinel.c	/^const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelRedisInstanceTypeStr	sentinel.c	/^const char *sentinelRedisInstanceTypeStr(sentinelRedisInstance *ri);$/;"	p	file:	signature:(sentinelRedisInstance *ri)
sentinelRefreshInstanceInfo	sentinel.c	/^void sentinelRefreshInstanceInfo(sentinelRedisInstance *ri, const char *info) {$/;"	f	signature:(sentinelRedisInstance *ri, const char *info)
sentinelReleaseScriptJob	sentinel.c	/^void sentinelReleaseScriptJob(sentinelScriptJob *sj) {$/;"	f	signature:(sentinelScriptJob *sj)
sentinelResetMaster	sentinel.c	/^void sentinelResetMaster(sentinelRedisInstance *ri, int flags) {$/;"	f	signature:(sentinelRedisInstance *ri, int flags)
sentinelResetMasterAndChangeAddress	sentinel.c	/^int sentinelResetMasterAndChangeAddress(sentinelRedisInstance *master, char *ip, int port) {$/;"	f	signature:(sentinelRedisInstance *master, char *ip, int port)
sentinelResetMastersByPattern	sentinel.c	/^int sentinelResetMastersByPattern(char *pattern, int flags) {$/;"	f	signature:(char *pattern, int flags)
sentinelRoleCommand	sentinel.c	/^void sentinelRoleCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sentinelRoleCommand	sentinel.c	/^void sentinelRoleCommand(redisClient *c);$/;"	p	file:	signature:(redisClient *c)
sentinelRunPendingScripts	sentinel.c	/^void sentinelRunPendingScripts(void) {$/;"	f	signature:(void)
sentinelScheduleScriptExecution	sentinel.c	/^void sentinelScheduleScriptExecution(char *path, ...) {$/;"	f	signature:(char *path, ...)
sentinelScheduleScriptExecution	sentinel.c	/^void sentinelScheduleScriptExecution(char *path, ...);$/;"	p	file:	signature:(char *path, ...)
sentinelScriptJob	sentinel.c	/^typedef struct sentinelScriptJob {$/;"	s	file:
sentinelScriptJob	sentinel.c	/^} sentinelScriptJob;$/;"	t	typeref:struct:sentinelScriptJob	file:
sentinelScriptJob::argv	sentinel.c	/^    char **argv;            \/* Arguments to call the script. *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::flags	sentinel.c	/^    int flags;              \/* Script job flags: SENTINEL_SCRIPT_* *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::pid	sentinel.c	/^    pid_t pid;              \/* Script execution pid. *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::retry_num	sentinel.c	/^    int retry_num;          \/* Number of times we tried to execute it. *\/$/;"	m	struct:sentinelScriptJob	file:	access:public
sentinelScriptJob::start_time	sentinel.c	/^    mstime_t start_time;    \/* Script execution time if the script is running,$/;"	m	struct:sentinelScriptJob	file:	access:public
sentinelScriptRetryDelay	sentinel.c	/^mstime_t sentinelScriptRetryDelay(int retry_num) {$/;"	f	signature:(int retry_num)
sentinelSelectSlave	sentinel.c	/^sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelSelectSlave	sentinel.c	/^sentinelRedisInstance *sentinelSelectSlave(sentinelRedisInstance *master);$/;"	p	file:	signature:(sentinelRedisInstance *master)
sentinelSendAuthIfNeeded	sentinel.c	/^void sentinelSendAuthIfNeeded(sentinelRedisInstance *ri, redisAsyncContext *c) {$/;"	f	signature:(sentinelRedisInstance *ri, redisAsyncContext *c)
sentinelSendHello	sentinel.c	/^int sentinelSendHello(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelSendPeriodicCommands	sentinel.c	/^void sentinelSendPeriodicCommands(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelSendPing	sentinel.c	/^int sentinelSendPing(sentinelRedisInstance *ri) {$/;"	f	signature:(sentinelRedisInstance *ri)
sentinelSendPing	sentinel.c	/^int sentinelSendPing(sentinelRedisInstance *ri);$/;"	p	file:	signature:(sentinelRedisInstance *ri)
sentinelSendSlaveOf	sentinel.c	/^int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port) {$/;"	f	signature:(sentinelRedisInstance *ri, char *host, int port)
sentinelSendSlaveOf	sentinel.c	/^int sentinelSendSlaveOf(sentinelRedisInstance *ri, char *host, int port);$/;"	p	file:	signature:(sentinelRedisInstance *ri, char *host, int port)
sentinelSetClientName	sentinel.c	/^void sentinelSetClientName(sentinelRedisInstance *ri, redisAsyncContext *c, char *type) {$/;"	f	signature:(sentinelRedisInstance *ri, redisAsyncContext *c, char *type)
sentinelSetCommand	sentinel.c	/^void sentinelSetCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sentinelSetCommand	sentinel.c	/^void sentinelSetCommand(redisClient *c);$/;"	p	file:	signature:(redisClient *c)
sentinelStartFailover	sentinel.c	/^void sentinelStartFailover(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelStartFailover	sentinel.c	/^void sentinelStartFailover(sentinelRedisInstance *master);$/;"	p	file:	signature:(sentinelRedisInstance *master)
sentinelStartFailoverIfNeeded	sentinel.c	/^int sentinelStartFailoverIfNeeded(sentinelRedisInstance *master) {$/;"	f	signature:(sentinelRedisInstance *master)
sentinelState	sentinel.c	/^struct sentinelState {$/;"	s	file:
sentinelState::announce_ip	sentinel.c	/^    char *announce_ip;      \/* IP addr that is gossiped to other sentinels if$/;"	m	struct:sentinelState	file:	access:public
sentinelState::announce_port	sentinel.c	/^    int announce_port;      \/* Port that is gossiped to other sentinels if$/;"	m	struct:sentinelState	file:	access:public
sentinelState::current_epoch	sentinel.c	/^    uint64_t current_epoch;     \/* Current epoch. *\/$/;"	m	struct:sentinelState	file:	access:public
sentinelState::masters	sentinel.c	/^    dict *masters;      \/* Dictionary of master sentinelRedisInstances.$/;"	m	struct:sentinelState	file:	access:public
sentinelState::previous_time	sentinel.c	/^    mstime_t previous_time;     \/* Last time we ran the time handler. *\/$/;"	m	struct:sentinelState	file:	access:public
sentinelState::running_scripts	sentinel.c	/^    int running_scripts;    \/* Number of scripts in execution right now. *\/$/;"	m	struct:sentinelState	file:	access:public
sentinelState::scripts_queue	sentinel.c	/^    list *scripts_queue;    \/* Queue of user scripts to execute. *\/$/;"	m	struct:sentinelState	file:	access:public
sentinelState::tilt	sentinel.c	/^    int tilt;           \/* Are we in TILT mode? *\/$/;"	m	struct:sentinelState	file:	access:public
sentinelState::tilt_start_time	sentinel.c	/^    mstime_t tilt_start_time;   \/* When TITL started. *\/$/;"	m	struct:sentinelState	file:	access:public
sentinelTimer	redis.h	/^void sentinelTimer(void);$/;"	p	signature:(void)
sentinelTimer	sentinel.c	/^void sentinelTimer(void) {$/;"	f	signature:(void)
sentinelVoteLeader	sentinel.c	/^char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch) {$/;"	f	signature:(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch)
sentinelVoteLeader	sentinel.c	/^char *sentinelVoteLeader(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch);$/;"	p	file:	signature:(sentinelRedisInstance *master, uint64_t req_epoch, char *req_runid, uint64_t *leader_epoch)
sentinel_mode	redis.h	/^    int sentinel_mode;          \/* True if this instance is a Sentinel. *\/$/;"	m	struct:redisServer	access:public
sentinelcmds	sentinel.c	/^struct redisCommand sentinelcmds[] = {$/;"	v	typeref:struct:redisCommand
sentinels	sentinel.c	/^    dict *sentinels;    \/* Other sentinels monitoring the same master. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
sentlen	redis.h	/^    int sentlen;            \/* Amount of bytes already sent in the current$/;"	m	struct:redisClient	access:public
sequence	sparkline.h	/^struct sequence {$/;"	s
sequence::labels	sparkline.h	/^    int labels;$/;"	m	struct:sequence	access:public
sequence::length	sparkline.h	/^    int length;$/;"	m	struct:sequence	access:public
sequence::max	sparkline.h	/^    double min, max;$/;"	m	struct:sequence	access:public
sequence::min	sparkline.h	/^    double min, max;$/;"	m	struct:sequence	access:public
sequence::samples	sparkline.h	/^    struct sample *samples;$/;"	m	struct:sequence	typeref:struct:sequence::sample	access:public
serveClientBlockedOnList	t_list.c	/^int serveClientBlockedOnList(redisClient *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)$/;"	f	signature:(redisClient *receiver, robj *key, robj *dstkey, redisDb *db, robj *value, int where)
server	redis.c	/^struct redisServer server; \/* server global state *\/$/;"	v	typeref:struct:redisServer
server	redis.h	/^extern struct redisServer server;$/;"	x
serverCron	redis.c	/^int serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f	signature:(struct aeEventLoop *eventLoop, long long id, void *clientData)
set	t_zset.c	/^        } set;$/;"	m	union:__anon30::__anon31	typeref:union:__anon30::__anon31::_iterset	file:	access:public
setCommand	redis.h	/^void setCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
setCommand	t_string.c	/^void setCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
setDeferredMultiBulkLength	networking.c	/^void setDeferredMultiBulkLength(redisClient *c, void *node, long length) {$/;"	f	signature:(redisClient *c, void *node, long length)
setDeferredMultiBulkLength	redis.h	/^void setDeferredMultiBulkLength(redisClient *c, void *node, long length);$/;"	p	signature:(redisClient *c, void *node, long length)
setDictType	redis.c	/^dictType setDictType = {$/;"	v
setDictType	redis.h	/^extern dictType setDictType;$/;"	x
setExpire	db.c	/^void setExpire(redisDb *db, robj *key, long long when) {$/;"	f	signature:(redisDb *db, robj *key, long long when)
setExpire	redis.h	/^void setExpire(redisDb *db, robj *key, long long when);$/;"	p	signature:(redisDb *db, robj *key, long long when)
setGenericCommand	t_string.c	/^void setGenericCommand(redisClient *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply) {$/;"	f	signature:(redisClient *c, int flags, robj *key, robj *val, robj *expire, int unit, robj *ok_reply, robj *abort_reply)
setKey	db.c	/^void setKey(redisDb *db, robj *key, robj *val) {$/;"	f	signature:(redisDb *db, robj *key, robj *val)
setKey	redis.h	/^void setKey(redisDb *db, robj *key, robj *val);$/;"	p	signature:(redisDb *db, robj *key, robj *val)
setProtocolError	networking.c	/^static void setProtocolError(redisClient *c, int pos) {$/;"	f	file:	signature:(redisClient *c, int pos)
setProtocolError	networking.c	/^static void setProtocolError(redisClient *c, int pos);$/;"	p	file:	signature:(redisClient *c, int pos)
setTypeAdd	redis.h	/^int setTypeAdd(robj *subject, robj *value);$/;"	p	signature:(robj *subject, robj *value)
setTypeAdd	t_set.c	/^int setTypeAdd(robj *subject, robj *value) {$/;"	f	signature:(robj *subject, robj *value)
setTypeConvert	redis.h	/^void setTypeConvert(robj *subject, int enc);$/;"	p	signature:(robj *subject, int enc)
setTypeConvert	t_set.c	/^void setTypeConvert(robj *setobj, int enc) {$/;"	f	signature:(robj *setobj, int enc)
setTypeCreate	redis.h	/^robj *setTypeCreate(robj *value);$/;"	p	signature:(robj *value)
setTypeCreate	t_set.c	/^robj *setTypeCreate(robj *value) {$/;"	f	signature:(robj *value)
setTypeInitIterator	redis.h	/^setTypeIterator *setTypeInitIterator(robj *subject);$/;"	p	signature:(robj *subject)
setTypeInitIterator	t_set.c	/^setTypeIterator *setTypeInitIterator(robj *subject) {$/;"	f	signature:(robj *subject)
setTypeIsMember	redis.h	/^int setTypeIsMember(robj *subject, robj *value);$/;"	p	signature:(robj *subject, robj *value)
setTypeIsMember	t_set.c	/^int setTypeIsMember(robj *subject, robj *value) {$/;"	f	signature:(robj *subject, robj *value)
setTypeIterator	redis.h	/^} setTypeIterator;$/;"	t	typeref:struct:__anon20
setTypeNext	redis.h	/^int setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele);$/;"	p	signature:(setTypeIterator *si, robj **objele, int64_t *llele)
setTypeNext	t_set.c	/^int setTypeNext(setTypeIterator *si, robj **objele, int64_t *llele) {$/;"	f	signature:(setTypeIterator *si, robj **objele, int64_t *llele)
setTypeNextObject	redis.h	/^robj *setTypeNextObject(setTypeIterator *si);$/;"	p	signature:(setTypeIterator *si)
setTypeNextObject	t_set.c	/^robj *setTypeNextObject(setTypeIterator *si) {$/;"	f	signature:(setTypeIterator *si)
setTypeRandomElement	redis.h	/^int setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele);$/;"	p	signature:(robj *setobj, robj **objele, int64_t *llele)
setTypeRandomElement	t_set.c	/^int setTypeRandomElement(robj *setobj, robj **objele, int64_t *llele) {$/;"	f	signature:(robj *setobj, robj **objele, int64_t *llele)
setTypeReleaseIterator	redis.h	/^void setTypeReleaseIterator(setTypeIterator *si);$/;"	p	signature:(setTypeIterator *si)
setTypeReleaseIterator	t_set.c	/^void setTypeReleaseIterator(setTypeIterator *si) {$/;"	f	signature:(setTypeIterator *si)
setTypeRemove	redis.h	/^int setTypeRemove(robj *subject, robj *value);$/;"	p	signature:(robj *subject, robj *value)
setTypeRemove	t_set.c	/^int setTypeRemove(robj *setobj, robj *value) {$/;"	f	signature:(robj *setobj, robj *value)
setTypeSize	redis.h	/^unsigned long setTypeSize(robj *subject);$/;"	p	signature:(robj *subject)
setTypeSize	t_set.c	/^unsigned long setTypeSize(robj *subject) {$/;"	f	signature:(robj *subject)
set_as_replica	redis-trib.rb	/^    def set_as_replica(node_id)$/;"	f	class:ClusterNode
set_max_intset_entries	redis.h	/^    size_t set_max_intset_entries;$/;"	m	struct:redisServer	access:public
set_timeout_cluster_cmd	redis-trib.rb	/^    def set_timeout_cluster_cmd(argv,opt)$/;"	f	class:RedisTrib.alloc_slots
setbitCommand	bitops.c	/^void setbitCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
setbitCommand	redis.h	/^void setbitCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
setexCommand	redis.h	/^void setexCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
setexCommand	t_string.c	/^void setexCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
setnxCommand	redis.h	/^void setnxCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
setnxCommand	t_string.c	/^void setnxCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
setproctitle	config.h	/^void setproctitle(const char *fmt, ...);$/;"	p	signature:(const char *fmt, ...)
setproctitle	setproctitle.c	/^void setproctitle(const char *fmt, ...) {$/;"	f	signature:(const char *fmt, ...)
setproctitle.c	setproctitle.c	1;"	F
setrangeCommand	redis.h	/^void setrangeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
setrangeCommand	t_string.c	/^void setrangeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
setsize	ae.h	/^    int setsize; \/* max number of file descriptors tracked *\/$/;"	m	struct:aeEventLoop	access:public
setupSignalHandlers	redis.c	/^void setupSignalHandlers(void) {$/;"	f	signature:(void)
setupSignalHandlers	redis.h	/^void setupSignalHandlers(void);$/;"	p	signature:(void)
sflags	redis.h	/^    char *sflags; \/* Flags as string representation, one char per flag. *\/$/;"	m	struct:redisCommand	access:public
sha1.c	sha1.c	1;"	F
sha1.h	sha1.h	1;"	F
sha1hex	scripting.c	/^void sha1hex(char *digest, char *script, size_t len) {$/;"	f	signature:(char *digest, char *script, size_t len)
sha1hex	scripting.c	/^void sha1hex(char *digest, char *script, size_t len);$/;"	p	file:	signature:(char *digest, char *script, size_t len)
shaScriptObjectDictType	redis.c	/^dictType shaScriptObjectDictType = {$/;"	v
shaScriptObjectDictType	redis.h	/^extern dictType shaScriptObjectDictType;$/;"	x
shared	redis.c	/^struct sharedObjectsStruct shared;$/;"	v	typeref:struct:sharedObjectsStruct
shared	redis.h	/^extern struct sharedObjectsStruct shared;$/;"	x
sharedObjectsStruct	redis.h	/^struct sharedObjectsStruct {$/;"	s
sharedObjectsStruct::bgsaveerr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::bulkhdr	redis.h	/^    *bulkhdr[REDIS_SHARED_BULKHDR_LEN];  \/* "$<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::busykeyerr	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::cnegone	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::colon	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::cone	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::crlf	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::czero	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::del	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::emptybulk	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::emptymultibulk	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::emptyscan	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::err	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::execaborterr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::integers	redis.h	/^    *integers[REDIS_SHARED_INTEGERS],$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::loadingerr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::lpop	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::lpush	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::masterdownerr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::maxstring	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::mbulkhdr	redis.h	/^    *mbulkhdr[REDIS_SHARED_BULKHDR_LEN], \/* "*<value>\\r\\n" *\/$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::messagebulk	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::minstring	redis.h	/^    *lpush, *emptyscan, *minstring, *maxstring,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::noautherr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::nokeyerr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::noreplicaserr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::noscripterr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::nullbulk	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::nullmultibulk	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::ok	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::oomerr	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::outofrangeerr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::plus	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::pmessagebulk	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::pong	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::psubscribebulk	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::punsubscribebulk	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::queued	redis.h	/^    *colon, *nullbulk, *nullmultibulk, *queued,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::roslaveerr	redis.h	/^    *masterdownerr, *roslaveerr, *execaborterr, *noautherr, *noreplicaserr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::rpop	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::sameobjecterr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::select	redis.h	/^    *select[REDIS_SHARED_SELECT_CMDS],$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::slowscripterr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::space	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::subscribebulk	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::syntaxerr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::unsubscribebulk	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
sharedObjectsStruct::wrongtypeerr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
showLatencyDistLegend	redis-cli.c	/^void showLatencyDistLegend(void) {$/;"	f	signature:(void)
showLatencyDistSamples	redis-cli.c	/^void showLatencyDistSamples(struct distsamples *samples, long long tot) {$/;"	f	signature:(struct distsamples *samples, long long tot)
showLatencyReport	redis-benchmark.c	/^static void showLatencyReport(void) {$/;"	f	file:	signature:(void)
showThroughput	redis-benchmark.c	/^int showThroughput(struct aeEventLoop *eventLoop, long long id, void *clientData) {$/;"	f	signature:(struct aeEventLoop *eventLoop, long long id, void *clientData)
show_help	redis-trib.rb	/^def show_help$/;"	f	class:RedisTrib
show_nodes	redis-trib.rb	/^    def show_nodes$/;"	f	class:RedisTrib.alloc_slots
show_reshard_table	redis-trib.rb	/^    def show_reshard_table(table)$/;"	f	class:RedisTrib.alloc_slots
shutdown	redis-cli.c	/^    int shutdown;$/;"	m	struct:config	file:	access:public
shutdownCommand	db.c	/^void shutdownCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
shutdownCommand	redis.h	/^void shutdownCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
shutdown_asap	redis.h	/^    int shutdown_asap;          \/* SHUTDOWN needed ASAP *\/$/;"	m	struct:redisServer	access:public
sig	cluster.h	/^    char sig[4];        \/* Siganture "RCmb" (Redis Cluster message bus). *\/$/;"	m	struct:__anon9	access:public
sigShutdownHandler	redis.c	/^static void sigShutdownHandler(int sig) {$/;"	f	file:	signature:(int sig)
signalFlushedDb	db.c	/^void signalFlushedDb(int dbid) {$/;"	f	signature:(int dbid)
signalFlushedDb	redis.h	/^void signalFlushedDb(int dbid);$/;"	p	signature:(int dbid)
signalListAsReady	redis.h	/^void signalListAsReady(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
signalListAsReady	t_list.c	/^void signalListAsReady(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
signalModifiedKey	db.c	/^void signalModifiedKey(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
signalModifiedKey	redis.h	/^void signalModifiedKey(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
sigsegvHandler	debug.c	/^void sigsegvHandler(int sig, siginfo_t *info, void *secret) {$/;"	f	signature:(int sig, siginfo_t *info, void *secret)
sigsegvHandler	redis.h	/^void sigsegvHandler(int sig, siginfo_t *info, void *secret);$/;"	p	signature:(int sig, siginfo_t *info, void *secret)
since	help.h	/^  char *since;$/;"	m	struct:commandHelp	access:public
sinterCommand	redis.h	/^void sinterCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sinterCommand	t_set.c	/^void sinterCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sinterGenericCommand	t_set.c	/^void sinterGenericCommand(redisClient *c, robj **setkeys, unsigned long setnum, robj *dstkey) {$/;"	f	signature:(redisClient *c, robj **setkeys, unsigned long setnum, robj *dstkey)
sinterstoreCommand	redis.h	/^void sinterstoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sinterstoreCommand	t_set.c	/^void sinterstoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sismemberCommand	redis.h	/^void sismemberCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sismemberCommand	t_set.c	/^void sismemberCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
size	cluster.h	/^    int size;             \/* Num of master nodes with at least one slot *\/$/;"	m	struct:clusterState	access:public
size	dict.h	/^    unsigned long size;$/;"	m	struct:dictht	access:public
size	redis-check-dump.c	/^    size_t size;$/;"	m	struct:__anon12	file:	access:public
sizemask	dict.h	/^    unsigned long sizemask;$/;"	m	struct:dictht	access:public
sl	t_zset.c	/^            } sl;$/;"	m	union:__anon30::__anon31::_iterzset	typeref:struct:__anon30::__anon31::_iterzset::__anon35	file:	access:public
slaveIsInHandshakeState	replication.c	/^int slaveIsInHandshakeState(void) {$/;"	f	signature:(void)
slaveMode	redis-cli.c	/^static void slaveMode(void) {$/;"	f	file:	signature:(void)
slaveMode	redis-cli.c	/^static void slaveMode(void);$/;"	p	file:	signature:(void)
slaveTryPartialResynchronization	replication.c	/^int slaveTryPartialResynchronization(int fd, int read_reply) {$/;"	f	signature:(int fd, int read_reply)
slave_capa	redis.h	/^    int slave_capa;         \/* Slave capabilities: SLAVE_CAPA_* bitwise OR. *\/$/;"	m	struct:redisClient	access:public
slave_conf_change_time	sentinel.c	/^    mstime_t slave_conf_change_time; \/* Last time slave master addr changed. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slave_listening_port	redis.h	/^    int slave_listening_port; \/* As configured with: SLAVECONF listening-port *\/$/;"	m	struct:redisClient	access:public
slave_master_host	sentinel.c	/^    char *slave_master_host;    \/* Master host as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slave_master_link_status	sentinel.c	/^    int slave_master_link_status; \/* Master link status as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slave_master_port	sentinel.c	/^    int slave_master_port;      \/* Master port as reported by INFO *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slave_mode	redis-cli.c	/^    int slave_mode;$/;"	m	struct:config	file:	access:public
slave_priority	redis.h	/^    int slave_priority;             \/* Reported in INFO and used by Sentinel. *\/$/;"	m	struct:redisServer	access:public
slave_priority	sentinel.c	/^    int slave_priority; \/* Slave priority according to its INFO output. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slave_reconf_sent_time	sentinel.c	/^    mstime_t slave_reconf_sent_time; \/* Time at which we sent SLAVE OF <new> *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slave_repl_offset	sentinel.c	/^    unsigned long long slave_repl_offset; \/* Slave replication offset. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slaveof	cluster.h	/^    char slaveof[REDIS_CLUSTER_NAMELEN];$/;"	m	struct:__anon9	access:public
slaveof	cluster.h	/^    struct clusterNode *slaveof; \/* pointer to the master node *\/$/;"	m	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
slaveofCommand	redis.h	/^void slaveofCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
slaveofCommand	replication.c	/^void slaveofCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
slaves	cluster.h	/^    struct clusterNode **slaves; \/* pointers to slave nodes *\/$/;"	m	struct:clusterNode	typeref:struct:clusterNode::clusterNode	access:public
slaves	redis.h	/^    list *slaves, *monitors;    \/* List of slaves and MONITORs *\/$/;"	m	struct:redisServer	access:public
slaves	sentinel.c	/^    dict *slaves;       \/* Slaves for this master instance. *\/$/;"	m	struct:sentinelRedisInstance	file:	access:public
slaveseldb	redis.h	/^    int slaveseldb;                 \/* Last SELECTed DB in replication output *\/$/;"	m	struct:redisServer	access:public
slotToKeyAdd	db.c	/^void slotToKeyAdd(robj *key) {$/;"	f	signature:(robj *key)
slotToKeyAdd	db.c	/^void slotToKeyAdd(robj *key);$/;"	p	file:	signature:(robj *key)
slotToKeyDel	db.c	/^void slotToKeyDel(robj *key) {$/;"	f	signature:(robj *key)
slotToKeyDel	db.c	/^void slotToKeyDel(robj *key);$/;"	p	file:	signature:(robj *key)
slotToKeyFlush	db.c	/^void slotToKeyFlush(void) {$/;"	f	signature:(void)
slotToKeyFlush	db.c	/^void slotToKeyFlush(void);$/;"	p	file:	signature:(void)
slots	cluster.h	/^    clusterNode *slots[REDIS_CLUSTER_SLOTS];$/;"	m	struct:clusterState	access:public
slots	cluster.h	/^    unsigned char slots[REDIS_CLUSTER_SLOTS\/8]; \/* Slots bitmap. *\/$/;"	m	struct:__anon4	access:public
slots	cluster.h	/^    unsigned char slots[REDIS_CLUSTER_SLOTS\/8]; \/* slots handled by this node *\/$/;"	m	struct:clusterNode	access:public
slots	redis-trib.rb	/^    def slots$/;"	f	class:ClusterNode
slots_to_keys	cluster.h	/^    zskiplist *slots_to_keys;$/;"	m	struct:clusterState	access:public
slowlog	redis.h	/^    list *slowlog;                  \/* SLOWLOG list of commands *\/$/;"	m	struct:redisServer	access:public
slowlog.c	slowlog.c	1;"	F
slowlog.h	slowlog.h	1;"	F
slowlogCommand	slowlog.c	/^void slowlogCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
slowlogCommand	slowlog.h	/^void slowlogCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
slowlogCreateEntry	slowlog.c	/^slowlogEntry *slowlogCreateEntry(robj **argv, int argc, long long duration) {$/;"	f	signature:(robj **argv, int argc, long long duration)
slowlogEntry	slowlog.h	/^typedef struct slowlogEntry {$/;"	s
slowlogEntry	slowlog.h	/^} slowlogEntry;$/;"	t	typeref:struct:slowlogEntry
slowlogEntry::argc	slowlog.h	/^    int argc;$/;"	m	struct:slowlogEntry	access:public
slowlogEntry::argv	slowlog.h	/^    robj **argv;$/;"	m	struct:slowlogEntry	access:public
slowlogEntry::duration	slowlog.h	/^    long long duration; \/* Time spent by the query, in nanoseconds. *\/$/;"	m	struct:slowlogEntry	access:public
slowlogEntry::id	slowlog.h	/^    long long id;       \/* Unique entry identifier. *\/$/;"	m	struct:slowlogEntry	access:public
slowlogEntry::time	slowlog.h	/^    time_t time;        \/* Unix time at which the query was executed. *\/$/;"	m	struct:slowlogEntry	access:public
slowlogFreeEntry	slowlog.c	/^void slowlogFreeEntry(void *septr) {$/;"	f	signature:(void *septr)
slowlogInit	slowlog.c	/^void slowlogInit(void) {$/;"	f	signature:(void)
slowlogInit	slowlog.h	/^void slowlogInit(void);$/;"	p	signature:(void)
slowlogPushEntryIfNeeded	slowlog.c	/^void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration) {$/;"	f	signature:(robj **argv, int argc, long long duration)
slowlogPushEntryIfNeeded	slowlog.h	/^void slowlogPushEntryIfNeeded(robj **argv, int argc, long long duration);$/;"	p	signature:(robj **argv, int argc, long long duration)
slowlogReset	slowlog.c	/^void slowlogReset(void) {$/;"	f	signature:(void)
slowlog_entry_id	redis.h	/^    long long slowlog_entry_id;     \/* SLOWLOG current entry ID *\/$/;"	m	struct:redisServer	access:public
slowlog_log_slower_than	redis.h	/^    long long slowlog_log_slower_than; \/* SLOWLOG time limit (to get logged) *\/$/;"	m	struct:redisServer	access:public
slowlog_max_len	redis.h	/^    unsigned long slowlog_max_len;     \/* SLOWLOG max number of items logged *\/$/;"	m	struct:redisServer	access:public
slowscripterr	redis.h	/^    *outofrangeerr, *noscripterr, *loadingerr, *slowscripterr, *bgsaveerr,$/;"	m	struct:sharedObjectsStruct	access:public
smoveCommand	redis.h	/^void smoveCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
smoveCommand	t_set.c	/^void smoveCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sndbuf	cluster.h	/^    sds sndbuf;                 \/* Packet send buffer *\/$/;"	m	struct:clusterLink	access:public
sofd	redis.h	/^    int sofd;                   \/* Unix socket file descriptor *\/$/;"	m	struct:redisServer	access:public
soft_limit_bytes	redis.h	/^    unsigned long long soft_limit_bytes;$/;"	m	struct:clientBufferLimitsConfig	access:public
soft_limit_seconds	redis.h	/^    time_t soft_limit_seconds;$/;"	m	struct:clientBufferLimitsConfig	access:public
solarisfixes.h	solarisfixes.h	1;"	F
sort.c	sort.c	1;"	F
sortCommand	redis.h	/^void sortCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sortCommand	sort.c	/^void sortCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sortCompare	sort.c	/^int sortCompare(const void *s1, const void *s2) {$/;"	f	signature:(const void *s1, const void *s2)
sortGetKeys	db.c	/^int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
sortGetKeys	redis.h	/^int *sortGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys);$/;"	p	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
sort_alpha	redis.h	/^    int sort_alpha;$/;"	m	struct:redisServer	access:public
sort_bypattern	redis.h	/^    int sort_bypattern;$/;"	m	struct:redisServer	access:public
sort_desc	redis.h	/^    int sort_desc;$/;"	m	struct:redisServer	access:public
sort_store	redis.h	/^    int sort_store;$/;"	m	struct:redisServer	access:public
space	redis.h	/^    robj *crlf, *ok, *err, *emptybulk, *czero, *cone, *cnegone, *pong, *space,$/;"	m	struct:sharedObjectsStruct	access:public
span	redis.h	/^        unsigned int span;$/;"	m	struct:zskiplistNode::zskiplistLevel	access:public
sparkline.c	sparkline.c	1;"	F
sparkline.h	sparkline.h	1;"	F
sparklineRender	sparkline.c	/^sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags) {$/;"	f	signature:(sds output, struct sequence *seq, int columns, int rows, int flags)
sparklineRender	sparkline.h	/^sds sparklineRender(sds output, struct sequence *seq, int columns, int rows, int flags);$/;"	p	signature:(sds output, struct sequence *seq, int columns, int rows, int flags)
sparklineRenderRange	sparkline.c	/^sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags) {$/;"	f	signature:(sds output, struct sequence *seq, int rows, int offset, int len, int flags)
sparklineRenderRange	sparkline.h	/^sds sparklineRenderRange(sds output, struct sequence *seq, int rows, int offset, int len, int flags);$/;"	p	signature:(sds output, struct sequence *seq, int rows, int offset, int len, int flags)
sparklineSequenceAddSample	sparkline.c	/^void sparklineSequenceAddSample(struct sequence *seq, double value, char *label) {$/;"	f	signature:(struct sequence *seq, double value, char *label)
sparklineSequenceAddSample	sparkline.h	/^void sparklineSequenceAddSample(struct sequence *seq, double value, char *label);$/;"	p	signature:(struct sequence *seq, double value, char *label)
spectrum_palette	redis-cli.c	/^int *spectrum_palette;$/;"	v
spectrum_palette_color	redis-cli.c	/^int spectrum_palette_color[] = {0,233,234,235,237,239,241,243,245,247,144,143,142,184,226,214,208,202,196};$/;"	v
spectrum_palette_color_size	redis-cli.c	/^int spectrum_palette_color_size = 19;$/;"	v
spectrum_palette_mono	redis-cli.c	/^int spectrum_palette_mono[] = {0,233,234,235,237,239,241,243,245,247,249,251,253};$/;"	v
spectrum_palette_mono_size	redis-cli.c	/^int spectrum_palette_mono_size = 13;$/;"	v
spectrum_palette_size	redis-cli.c	/^int spectrum_palette_size;$/;"	v
spopCommand	redis.h	/^void spopCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
spopCommand	t_set.c	/^void spopCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
spt_clearenv	setproctitle.c	/^static int spt_clearenv(void) {$/;"	f	file:	signature:(void)
spt_copyargs	setproctitle.c	/^static int spt_copyargs(int argc, char *argv[]) {$/;"	f	file:	signature:(int argc, char *argv[])
spt_copyenv	setproctitle.c	/^static int spt_copyenv(char *oldenv[]) {$/;"	f	file:	signature:(char *oldenv[])
spt_init	config.h	/^void spt_init(int argc, char *argv[]);$/;"	p	signature:(int argc, char *argv[])
spt_init	setproctitle.c	/^void spt_init(int argc, char *argv[]) {$/;"	f	signature:(int argc, char *argv[])
spt_min	setproctitle.c	/^static inline size_t spt_min(size_t a, size_t b) {$/;"	f	file:	signature:(size_t a, size_t b)
sptr	t_zset.c	/^                unsigned char *eptr, *sptr;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
srandmemberCommand	redis.h	/^void srandmemberCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
srandmemberCommand	t_set.c	/^void srandmemberCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
srandmemberWithCountCommand	t_set.c	/^void srandmemberWithCountCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sremCommand	redis.h	/^void sremCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sremCommand	t_set.c	/^void sremCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sscanCommand	redis.h	/^void sscanCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sscanCommand	t_set.c	/^void sscanCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
start	redis-benchmark.c	/^    long long start;        \/* Start time of a request *\/$/;"	m	struct:_client	file:	access:public
start	redis-benchmark.c	/^    long long start;$/;"	m	struct:config	file:	access:public
startAppendOnly	aof.c	/^int startAppendOnly(void) {$/;"	f	signature:(void)
startAppendOnly	redis.h	/^int startAppendOnly(void);$/;"	p	signature:(void)
startBgsaveForReplication	replication.c	/^int startBgsaveForReplication(int mincapa) {$/;"	f	signature:(int mincapa)
startLoading	rdb.c	/^void startLoading(FILE *fp) {$/;"	f	signature:(FILE *fp)
startLoading	redis.h	/^void startLoading(FILE *fp);$/;"	p	signature:(FILE *fp)
start_time	sentinel.c	/^    mstime_t start_time;    \/* Script execution time if the script is running,$/;"	m	struct:sentinelScriptJob	file:	access:public
statMode	redis-cli.c	/^static void statMode(void) {$/;"	f	file:	signature:(void)
stat_evictedkeys	redis.h	/^    long long stat_evictedkeys;     \/* Number of evicted keys (maxmemory) *\/$/;"	m	struct:redisServer	access:public
stat_expiredkeys	redis.h	/^    long long stat_expiredkeys;     \/* Number of expired keys *\/$/;"	m	struct:redisServer	access:public
stat_fork_rate	redis.h	/^    double stat_fork_rate;          \/* Fork rate in GB\/sec. *\/$/;"	m	struct:redisServer	access:public
stat_fork_time	redis.h	/^    long long stat_fork_time;       \/* Time needed to perform latest fork() *\/$/;"	m	struct:redisServer	access:public
stat_keyspace_hits	redis.h	/^    long long stat_keyspace_hits;   \/* Number of successful lookups of keys *\/$/;"	m	struct:redisServer	access:public
stat_keyspace_misses	redis.h	/^    long long stat_keyspace_misses; \/* Number of failed lookups of keys *\/$/;"	m	struct:redisServer	access:public
stat_mode	redis-cli.c	/^    int stat_mode;$/;"	m	struct:config	file:	access:public
stat_net_input_bytes	redis.h	/^    long long stat_net_input_bytes; \/* Bytes read from network. *\/$/;"	m	struct:redisServer	access:public
stat_net_output_bytes	redis.h	/^    long long stat_net_output_bytes; \/* Bytes written to network. *\/$/;"	m	struct:redisServer	access:public
stat_numcommands	redis.h	/^    long long stat_numcommands;     \/* Number of processed commands *\/$/;"	m	struct:redisServer	access:public
stat_numconnections	redis.h	/^    long long stat_numconnections;  \/* Number of connections received *\/$/;"	m	struct:redisServer	access:public
stat_peak_memory	redis.h	/^    size_t stat_peak_memory;        \/* Max used memory record *\/$/;"	m	struct:redisServer	access:public
stat_rejected_conn	redis.h	/^    long long stat_rejected_conn;   \/* Clients rejected because of maxclients *\/$/;"	m	struct:redisServer	access:public
stat_starttime	redis.h	/^    time_t stat_starttime;          \/* Server start time *\/$/;"	m	struct:redisServer	access:public
stat_sync_full	redis.h	/^    long long stat_sync_full;       \/* Number of full resyncs with slaves. *\/$/;"	m	struct:redisServer	access:public
stat_sync_partial_err	redis.h	/^    long long stat_sync_partial_err;\/* Number of unaccepted PSYNC requests. *\/$/;"	m	struct:redisServer	access:public
stat_sync_partial_ok	redis.h	/^    long long stat_sync_partial_ok; \/* Number of accepted PSYNC requests. *\/$/;"	m	struct:redisServer	access:public
state	cluster.h	/^    int state;            \/* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... *\/$/;"	m	struct:clusterState	access:public
state	cluster.h	/^    unsigned char state; \/* Cluster state from the POV of the sender *\/$/;"	m	struct:__anon9	access:public
state	rio.h	/^            int *state;     \/* Error state of each fd. 0 (if ok) or errno. *\/$/;"	m	struct:_rio::__anon24::__anon27	access:public
state	sha1.h	/^    uint32_t state[5];$/;"	m	struct:__anon29	access:public
stats_bus_messages_received	cluster.h	/^    long long stats_bus_messages_received; \/* Num of msg rcvd via cluster bus.*\/$/;"	m	struct:clusterState	access:public
stats_bus_messages_sent	cluster.h	/^    long long stats_bus_messages_sent;  \/* Num of msg sent via cluster bus. *\/$/;"	m	struct:clusterState	access:public
stdinarg	redis-cli.c	/^    int stdinarg; \/* get last arg from stdin. (-x option) *\/$/;"	m	struct:config	file:	access:public
stop	ae.h	/^    int stop;$/;"	m	struct:aeEventLoop	access:public
stopAppendOnly	aof.c	/^void stopAppendOnly(void) {$/;"	f	signature:(void)
stopAppendOnly	redis.h	/^void stopAppendOnly(void);$/;"	p	signature:(void)
stopLoading	rdb.c	/^void stopLoading(void) {$/;"	f	signature:(void)
stopLoading	redis.h	/^void stopLoading(void);$/;"	p	signature:(void)
stop_writes_on_bgsave_err	redis.h	/^    int stop_writes_on_bgsave_err;  \/* Don't allow writes if can't BGSAVE *\/$/;"	m	struct:redisServer	access:public
strEncoding	object.c	/^char *strEncoding(int encoding) {$/;"	f	signature:(int encoding)
strEncoding	redis.h	/^char *strEncoding(int encoding);$/;"	p	signature:(int encoding)
stress	ziplist.c	/^void stress(int pos, int num, int maxsize, int dnum) {$/;"	f	signature:(int pos, int num, int maxsize, int dnum)
string2l	util.c	/^int string2l(const char *s, size_t slen, long *lval) {$/;"	f	signature:(const char *s, size_t slen, long *lval)
string2l	util.h	/^int string2l(const char *s, size_t slen, long *value);$/;"	p	signature:(const char *s, size_t slen, long *value)
string2ll	util.c	/^int string2ll(const char *s, size_t slen, long long *value) {$/;"	f	signature:(const char *s, size_t slen, long long *value)
string2ll	util.h	/^int string2ll(const char *s, size_t slen, long long *value);$/;"	p	signature:(const char *s, size_t slen, long long *value)
stringObjectLen	object.c	/^size_t stringObjectLen(robj *o) {$/;"	f	signature:(robj *o)
stringObjectLen	redis.h	/^size_t stringObjectLen(robj *o);$/;"	p	signature:(robj *o)
stringmatch	util.c	/^int stringmatch(const char *pattern, const char *string, int nocase) {$/;"	f	signature:(const char *pattern, const char *string, int nocase)
stringmatch	util.h	/^int stringmatch(const char *p, const char *s, int nocase);$/;"	p	signature:(const char *p, const char *s, int nocase)
stringmatchlen	util.c	/^int stringmatchlen(const char *pattern, int patternLen,$/;"	f	signature:(const char *pattern, int patternLen, const char *string, int stringLen, int nocase)
stringmatchlen	util.h	/^int stringmatchlen(const char *p, int plen, const char *s, int slen, int nocase);$/;"	p	signature:(const char *p, int plen, const char *s, int slen, int nocase)
strlenCommand	redis.h	/^void strlenCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
strlenCommand	t_string.c	/^void strlenCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
strtold	object.c	/^#define strtold(/;"	d	file:
subject	redis.h	/^    robj *subject;$/;"	m	struct:__anon18	access:public
subject	redis.h	/^    robj *subject;$/;"	m	struct:__anon20	access:public
subject	redis.h	/^    robj *subject;$/;"	m	struct:__anon21	access:public
subject	t_zset.c	/^    robj *subject;$/;"	m	struct:__anon30	file:	access:public
subscribeCommand	pubsub.c	/^void subscribeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
subscribeCommand	redis.h	/^void subscribeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
subscribebulk	redis.h	/^    *busykeyerr, *oomerr, *plus, *messagebulk, *pmessagebulk, *subscribebulk,$/;"	m	struct:sharedObjectsStruct	access:public
success	redis-check-dump.c	/^    char success;$/;"	m	struct:__anon14	file:	access:public
summary	help.h	/^  char *summary;$/;"	m	struct:commandHelp	access:public
sunionCommand	redis.h	/^void sunionCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sunionCommand	t_set.c	/^void sunionCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
sunionDiffGenericCommand	t_set.c	/^void sunionDiffGenericCommand(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op) {$/;"	f	signature:(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op)
sunionDiffGenericCommand	t_set.c	/^void sunionDiffGenericCommand(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op);$/;"	p	file:	signature:(redisClient *c, robj **setkeys, int setnum, robj *dstkey, int op)
sunionstoreCommand	redis.h	/^void sunionstoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
sunionstoreCommand	t_set.c	/^void sunionstoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
swap	pqsort.c	/^#define swap(/;"	d	file:
swapcode	pqsort.c	/^#define swapcode(/;"	d	file:
swapfunc	pqsort.c	/^static inline void	 swapfunc (char *, char *, size_t, int);$/;"	p	file:	signature:(char *, char *, size_t, int)
swapfunc	pqsort.c	/^swapfunc(char *a, char *b, size_t n, int swaptype)$/;"	f	file:	signature:(char *a, char *b, size_t n, int swaptype)
syncCommand	redis.h	/^void syncCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
syncCommand	replication.c	/^void syncCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
syncRead	redis.h	/^ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout);$/;"	p	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncRead	syncio.c	/^ssize_t syncRead(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncReadLine	redis.h	/^ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout);$/;"	p	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncReadLine	syncio.c	/^ssize_t syncReadLine(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncWithMaster	replication.c	/^void syncWithMaster(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
syncWrite	redis.h	/^ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout);$/;"	p	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncWrite	syncio.c	/^ssize_t syncWrite(int fd, char *ptr, ssize_t size, long long timeout) {$/;"	f	signature:(int fd, char *ptr, ssize_t size, long long timeout)
syncio.c	syncio.c	1;"	F
syntaxerr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
syslog_enabled	redis.h	/^    int syslog_enabled;             \/* Is syslog enabled? *\/$/;"	m	struct:redisServer	access:public
syslog_facility	redis.h	/^    int syslog_facility;            \/* Syslog facility *\/$/;"	m	struct:redisServer	access:public
syslog_ident	redis.h	/^    char *syslog_ident;             \/* Syslog ident *\/$/;"	m	struct:redisServer	access:public
t_hash.c	t_hash.c	1;"	F
t_list.c	t_list.c	1;"	F
t_set.c	t_set.c	1;"	F
t_string.c	t_string.c	1;"	F
t_zset.c	t_zset.c	1;"	F
table	dict.h	/^    dictEntry **table;$/;"	m	struct:dictht	access:public
table	dict.h	/^    int table, safe;$/;"	m	struct:dictIterator	access:public
tail	adlist.h	/^    listNode *tail;$/;"	m	struct:list	access:public
tail	redis.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::	access:public
target	redis.h	/^    int argc, dbid, target;$/;"	m	struct:redisOp	access:public
target	redis.h	/^    robj *target;           \/* The key that should receive the element,$/;"	m	struct:blockingState	access:public
tcp_backlog	redis.h	/^    int tcp_backlog;            \/* TCP listen() backlog *\/$/;"	m	struct:redisServer	access:public
tcpkeepalive	redis.h	/^    int tcpkeepalive;               \/* Set SO_KEEPALIVE if non-zero. *\/$/;"	m	struct:redisServer	access:public
tell	rio.h	/^    off_t (*tell)(struct _rio *);$/;"	m	struct:_rio	access:public
test_cond	testhelp.h	/^#define test_cond(/;"	d
test_is_selected	redis-benchmark.c	/^int test_is_selected(char *name) {$/;"	f	signature:(char *name)
test_report	testhelp.h	/^#define test_report(/;"	d
test_string2l	util.c	/^void test_string2l(void) {$/;"	f	signature:(void)
test_string2ll	util.c	/^void test_string2ll(void) {$/;"	f	signature:(void)
testhelp.h	testhelp.h	1;"	F
tests	redis-benchmark.c	/^    char *tests;$/;"	m	struct:config	file:	access:public
tilt	sentinel.c	/^    int tilt;           \/* Are we in TILT mode? *\/$/;"	m	struct:sentinelState	file:	access:public
tilt_start_time	sentinel.c	/^    mstime_t tilt_start_time;   \/* When TITL started. *\/$/;"	m	struct:sentinelState	file:	access:public
time	bio.c	/^    time_t time; \/* Time at which the job was created. *\/$/;"	m	struct:bio_job	file:	access:public
time	cluster.h	/^    mstime_t time;             \/* Time of the last report from this node. *\/$/;"	m	struct:clusterNodeFailReport	access:public
time	latency.h	/^    int32_t time; \/* We don't use time_t to force 4 bytes usage everywhere. *\/$/;"	m	struct:latencySample	access:public
time	slowlog.h	/^    time_t time;        \/* Unix time at which the query was executed. *\/$/;"	m	struct:slowlogEntry	access:public
timeCommand	redis.c	/^void timeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
timeCommand	redis.h	/^void timeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
timeEventHead	ae.h	/^    aeTimeEvent *timeEventHead;$/;"	m	struct:aeEventLoop	access:public
timeEventNextId	ae.h	/^    long long timeEventNextId;$/;"	m	struct:aeEventLoop	access:public
timeInMilliseconds	dict.c	/^long long timeInMilliseconds(void) {$/;"	f	signature:(void)
timeProc	ae.h	/^    aeTimeProc *timeProc;$/;"	m	struct:aeTimeEvent	access:public
time_independent_strcmp	redis.c	/^int time_independent_strcmp(char *a, char *b) {$/;"	f	signature:(char *a, char *b)
timeout	redis.h	/^    mstime_t timeout;       \/* Blocking operation timeout. If UNIX current time$/;"	m	struct:blockingState	access:public
title	redis-benchmark.c	/^    const char *title;$/;"	m	struct:config	file:	access:public
toIntType	redis-cli.c	/^static int toIntType(char *key, char *type) {$/;"	f	file:	signature:(char *key, char *type)
to_s	redis-trib.rb	/^    def to_s$/;"	f	class:ClusterNode
todo_before_sleep	cluster.h	/^    int todo_before_sleep; \/* Things to do in clusterBeforeSleep(). *\/$/;"	m	struct:clusterState	access:public
totlatency	redis-benchmark.c	/^    long long totlatency;$/;"	m	struct:config	file:	access:public
totlen	cluster.h	/^    uint32_t totlen;    \/* Total length of this message *\/$/;"	m	struct:__anon9	access:public
touchWatchedKey	multi.c	/^void touchWatchedKey(redisDb *db, robj *key) {$/;"	f	signature:(redisDb *db, robj *key)
touchWatchedKey	redis.h	/^void touchWatchedKey(redisDb *db, robj *key);$/;"	p	signature:(redisDb *db, robj *key)
touchWatchedKeysOnFlush	multi.c	/^void touchWatchedKeysOnFlush(int dbid) {$/;"	f	signature:(int dbid)
touchWatchedKeysOnFlush	redis.h	/^void touchWatchedKeysOnFlush(int dbid);$/;"	p	signature:(int dbid)
trackInstantaneousMetric	redis.c	/^void trackInstantaneousMetric(int metric, long long current_reading) {$/;"	f	signature:(int metric, long long current_reading)
tryObjectEncoding	object.c	/^robj *tryObjectEncoding(robj *o) {$/;"	f	signature:(robj *o)
tryObjectEncoding	redis.h	/^robj *tryObjectEncoding(robj *o);$/;"	p	signature:(robj *o)
tryResizeHashTables	redis.c	/^void tryResizeHashTables(int dbid) {$/;"	f	signature:(int dbid)
ttlCommand	db.c	/^void ttlCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
ttlCommand	redis.h	/^void ttlCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
ttlGenericCommand	db.c	/^void ttlGenericCommand(redisClient *c, int output_ms) {$/;"	f	signature:(redisClient *c, int output_ms)
type	cluster.h	/^    uint16_t type;      \/* Message type *\/$/;"	m	struct:__anon9	access:public
type	dict.h	/^    dictType *type;$/;"	m	struct:dict	access:public
type	redis-check-dump.c	/^    int type;$/;"	m	struct:__anon14	file:	access:public
type	redis-cli.c	/^    int type;$/;"	m	struct:__anon15	file:	access:public
type	redis.h	/^    int type;$/;"	m	struct:_redisSortOperation	access:public
type	redis.h	/^    unsigned type:4;$/;"	m	struct:redisObject	access:public
type	t_zset.c	/^    int type; \/* Set, sorted set *\/$/;"	m	struct:__anon30	file:	access:public
typeCommand	db.c	/^void typeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
typeCommand	redis.h	/^void typeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
types	redis-check-dump.c	/^static char types[MAX_TYPES_NUM][MAX_TYPE_NAME_LEN];$/;"	v	file:
u	redis.h	/^    } u;$/;"	m	struct:_redisSortObject	typeref:union:_redisSortObject::__anon17	access:public
u16	lzfP.h	/^    typedef unsigned int u16;$/;"	t
u16	lzfP.h	/^    typedef unsigned short u16;$/;"	t
u64	dict.h	/^        uint64_t u64;$/;"	m	union:dictEntry::__anon11	access:public
u8	lzfP.h	/^typedef unsigned char u8;$/;"	t
u_int	solarisfixes.h	/^#define u_int /;"	d
u_int32_t	solarisfixes.h	/^#define u_int32_t /;"	d
uname_S	Makefile	/^uname_S := $(shell sh -c 'uname -s 2>\/dev\/null || echo not')$/;"	m
unblockClient	blocked.c	/^void unblockClient(redisClient *c) {$/;"	f	signature:(redisClient *c)
unblockClient	redis.h	/^void unblockClient(redisClient *c);$/;"	p	signature:(redisClient *c)
unblockClientWaitingData	redis.h	/^void unblockClientWaitingData(redisClient *c);$/;"	p	signature:(redisClient *c)
unblockClientWaitingData	t_list.c	/^void unblockClientWaitingData(redisClient *c) {$/;"	f	signature:(redisClient *c)
unblockClientWaitingReplicas	redis.h	/^void unblockClientWaitingReplicas(redisClient *c);$/;"	p	signature:(redisClient *c)
unblockClientWaitingReplicas	replication.c	/^void unblockClientWaitingReplicas(redisClient *c) {$/;"	f	signature:(redisClient *c)
unblocked_clients	redis.h	/^    list *unblocked_clients; \/* list of clients to unblock before next loop *\/$/;"	m	struct:redisServer	access:public
undoConnectWithMaster	replication.c	/^void undoConnectWithMaster(void) {$/;"	f	signature:(void)
unixsocket	redis.h	/^    char *unixsocket;           \/* UNIX socket path *\/$/;"	m	struct:redisServer	access:public
unixsocketperm	redis.h	/^    mode_t unixsocketperm;      \/* UNIX socket permission *\/$/;"	m	struct:redisServer	access:public
unixtime	redis.h	/^    time_t unixtime;        \/* Unix time sampled every cron cycle. *\/$/;"	m	struct:redisServer	access:public
unsubscribeCommand	pubsub.c	/^void unsubscribeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
unsubscribeCommand	redis.h	/^void unsubscribeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
unsubscribebulk	redis.h	/^    *unsubscribebulk, *psubscribebulk, *punsubscribebulk, *del, *rpop, *lpop,$/;"	m	struct:sharedObjectsStruct	access:public
unwatchAllKeys	multi.c	/^void unwatchAllKeys(redisClient *c) {$/;"	f	signature:(redisClient *c)
unwatchAllKeys	redis.h	/^void unwatchAllKeys(redisClient *c);$/;"	p	signature:(redisClient *c)
unwatchCommand	multi.c	/^void unwatchCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
unwatchCommand	redis.h	/^void unwatchCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
update	cluster.h	/^    } update;$/;"	m	union:clusterMsgData	typeref:struct:clusterMsgData::__anon8	access:public
updateCachedTime	redis.c	/^void updateCachedTime(void) {$/;"	f	signature:(void)
updateCachedTime	redis.h	/^void updateCachedTime(void);$/;"	p	signature:(void)
updateDictResizePolicy	redis.c	/^void updateDictResizePolicy(void) {$/;"	f	signature:(void)
updateDictResizePolicy	redis.h	/^void updateDictResizePolicy(void);$/;"	p	signature:(void)
updateSlavesWaitingBgsave	redis.h	/^void updateSlavesWaitingBgsave(int bgsaveerr, int type);$/;"	p	signature:(int bgsaveerr, int type)
updateSlavesWaitingBgsave	replication.c	/^void updateSlavesWaitingBgsave(int bgsaveerr, int type) {$/;"	f	signature:(int bgsaveerr, int type)
update_cksum	rio.h	/^    void (*update_cksum)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio	access:public
update_zmalloc_stat_add	zmalloc.c	/^#define update_zmalloc_stat_add(/;"	d	file:
update_zmalloc_stat_alloc	zmalloc.c	/^#define update_zmalloc_stat_alloc(/;"	d	file:
update_zmalloc_stat_free	zmalloc.c	/^#define update_zmalloc_stat_free(/;"	d	file:
update_zmalloc_stat_sub	zmalloc.c	/^#define update_zmalloc_stat_sub(/;"	d	file:
usage	redis-cli.c	/^static void usage(void) {$/;"	f	file:	signature:(void)
usage	redis-cli.c	/^static void usage(void);$/;"	p	file:	signature:(void)
usage	redis.c	/^void usage(void) {$/;"	f	signature:(void)
usage	redis.h	/^void usage(void);$/;"	p	signature:(void)
usec	intset.c	/^long long usec(void) {$/;"	f	signature:(void)
usec	ziplist.c	/^long long usec(void) {$/;"	f	signature:(void)
used	aof.c	/^    unsigned long used, free;$/;"	m	struct:aofrwblock	file:	access:public
used	dict.h	/^    unsigned long used;$/;"	m	struct:dictht	access:public
used_memory	zmalloc.c	/^static size_t used_memory = 0;$/;"	v	file:
used_memory_mutex	zmalloc.c	/^pthread_mutex_t used_memory_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
ustime	redis-benchmark.c	/^static long long ustime(void) {$/;"	f	file:	signature:(void)
ustime	redis-cli.c	/^static long long ustime(void) {$/;"	f	file:	signature:(void)
ustime	redis.c	/^long long ustime(void) {$/;"	f	signature:(void)
ustime	redis.h	/^long long ustime(void);$/;"	p	signature:(void)
util.c	util.c	1;"	F
util.h	util.h	1;"	F
v	dict.h	/^    } v;$/;"	m	struct:dictEntry	typeref:union:dictEntry::__anon11	access:public
val	dict.h	/^        void *val;$/;"	m	union:dictEntry::__anon11	access:public
valDestructor	dict.h	/^    void (*valDestructor)(void *privdata, void *obj);$/;"	m	struct:dictType	access:public
valDup	dict.h	/^    void *(*valDup)(void *privdata, const void *obj);$/;"	m	struct:dictType	access:public
validSyslogFacilities	config.c	/^} validSyslogFacilities[] = {$/;"	v	typeref:struct:__anon10	file:
value	adlist.h	/^    void *value;$/;"	m	struct:listNode	access:public
value	config.c	/^    const int       value;$/;"	m	struct:__anon10	file:	access:public
value	sparkline.h	/^    double value;$/;"	m	struct:sample	access:public
vecswap	pqsort.c	/^#define vecswap(/;"	d	file:
ver	cluster.h	/^    uint16_t ver;       \/* Protocol version, currently set to 0. *\/$/;"	m	struct:__anon9	access:public
verbosity	redis.h	/^    int verbosity;                  \/* Loglevel in redis.conf *\/$/;"	m	struct:redisServer	access:public
verify	ziplist.c	/^void verify(unsigned char *zl, zlentry *e) {$/;"	f	signature:(unsigned char *zl, zlentry *e)
verifyClusterConfigWithData	cluster.c	/^int verifyClusterConfigWithData(void) {$/;"	f	signature:(void)
verifyClusterConfigWithData	redis.h	/^int verifyClusterConfigWithData(void);$/;"	p	signature:(void)
verifyDumpPayload	cluster.c	/^int verifyDumpPayload(unsigned char *p, size_t len) {$/;"	f	signature:(unsigned char *p, size_t len)
version	redis.c	/^void version(void) {$/;"	f	signature:(void)
version.h	version.h	1;"	F
voted_time	cluster.h	/^    mstime_t voted_time;     \/* Last time we voted for a slave of this master *\/$/;"	m	struct:clusterNode	access:public
votes	sentinel.c	/^    unsigned long votes;$/;"	m	struct:sentinelLeader	file:	access:public
vptr	redis.h	/^    unsigned char *fptr, *vptr;$/;"	m	struct:__anon21	access:public
waitCommand	redis.h	/^void waitCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
waitCommand	replication.c	/^void waitCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
wait_cluster_join	redis-trib.rb	/^    def wait_cluster_join$/;"	f	class:RedisTrib
watchCommand	multi.c	/^void watchCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
watchCommand	redis.h	/^void watchCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
watchForKey	multi.c	/^void watchForKey(redisClient *c, robj *key) {$/;"	f	signature:(redisClient *c, robj *key)
watchdogScheduleSignal	debug.c	/^void watchdogScheduleSignal(int period) {$/;"	f	signature:(int period)
watchdogScheduleSignal	redis.h	/^void watchdogScheduleSignal(int period);$/;"	p	signature:(int period)
watchdogSignalHandler	debug.c	/^void watchdogSignalHandler(int sig, siginfo_t *info, void *secret) {$/;"	f	signature:(int sig, siginfo_t *info, void *secret)
watchdog_period	redis.h	/^    int watchdog_period;  \/* Software watchdog period in ms. 0 = off *\/$/;"	m	struct:redisServer	access:public
watchedKey	multi.c	/^typedef struct watchedKey {$/;"	s	file:
watchedKey	multi.c	/^} watchedKey;$/;"	t	typeref:struct:watchedKey	file:
watchedKey::db	multi.c	/^    redisDb *db;$/;"	m	struct:watchedKey	file:	access:public
watchedKey::key	multi.c	/^    robj *key;$/;"	m	struct:watchedKey	file:	access:public
watched_keys	redis.h	/^    dict *watched_keys;         \/* WATCHED keys for MULTI\/EXEC CAS *\/$/;"	m	struct:redisDb	access:public
watched_keys	redis.h	/^    list *watched_keys;     \/* Keys WATCHED for MULTI\/EXEC CAS *\/$/;"	m	struct:redisClient	access:public
weight	t_zset.c	/^    double weight;$/;"	m	struct:__anon30	file:	access:public
wfds	ae_select.c	/^    fd_set rfds, wfds;$/;"	m	struct:aeApiState	file:	access:public
wfileProc	ae.h	/^    aeFileProc *wfileProc;$/;"	m	struct:aeFileEvent	access:public
when_ms	ae.h	/^    long when_ms; \/* milliseconds *\/$/;"	m	struct:aeTimeEvent	access:public
when_sec	ae.h	/^    long when_sec; \/* seconds *\/$/;"	m	struct:aeTimeEvent	access:public
woff	redis.h	/^    long long woff;         \/* Last write global replication offset. *\/$/;"	m	struct:redisClient	access:public
write	rio.h	/^    size_t (*write)(struct _rio *, const void *buf, size_t len);$/;"	m	struct:_rio	access:public
writeHandler	redis-benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask) {$/;"	f	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
writeHandler	redis-benchmark.c	/^static void writeHandler(aeEventLoop *el, int fd, void *privdata, int mask);$/;"	p	file:	signature:(aeEventLoop *el, int fd, void *privdata, int mask)
writing	sentinel.c	/^    int reading, writing;$/;"	m	struct:redisAeEvents	file:	access:public
written	redis-benchmark.c	/^    unsigned int written;   \/* Bytes of 'obuf' already written *\/$/;"	m	struct:_client	file:	access:public
wrongtypeerr	redis.h	/^    *emptymultibulk, *wrongtypeerr, *nokeyerr, *syntaxerr, *sameobjecterr,$/;"	m	struct:sharedObjectsStruct	access:public
ws	memtest.c	/^static struct winsize ws;$/;"	v	typeref:struct:winsize	file:
x	rand.c	/^static uint32_t x[3] = { X0, X1, X2 }, a[3] = { A0, A1, A2 }, c = C;$/;"	v	file:
xorDigest	debug.c	/^void xorDigest(unsigned char *digest, void *ptr, size_t len) {$/;"	f	signature:(unsigned char *digest, void *ptr, size_t len)
xorObjectDigest	debug.c	/^void xorObjectDigest(unsigned char *digest, robj *o) {$/;"	f	signature:(unsigned char *digest, robj *o)
xputs	redis-trib.rb	/^def xputs(s)$/;"	f
yes_or_die	redis-trib.rb	/^    def yes_or_die(msg)$/;"	f	class:RedisTrib.alloc_slots
yesnotoi	config.c	/^int yesnotoi(char *s) {$/;"	f	signature:(char *s)
yesnotoi	sentinel.c	/^int yesnotoi(char *s);$/;"	p	file:	signature:(char *s)
zaddCommand	redis.h	/^void zaddCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zaddCommand	t_zset.c	/^void zaddCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zaddGenericCommand	t_zset.c	/^void zaddGenericCommand(redisClient *c, int flags) {$/;"	f	signature:(redisClient *c, int flags)
zcalloc	zmalloc.c	/^void *zcalloc(size_t size) {$/;"	f	signature:(size_t size)
zcalloc	zmalloc.h	/^void *zcalloc(size_t size);$/;"	p	signature:(size_t size)
zcardCommand	redis.h	/^void zcardCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zcardCommand	t_zset.c	/^void zcardCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zcountCommand	redis.h	/^void zcountCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zcountCommand	t_zset.c	/^void zcountCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zfree	zmalloc.c	/^void zfree(void *ptr) {$/;"	f	signature:(void *ptr)
zfree	zmalloc.h	/^void zfree(void *ptr);$/;"	p	signature:(void *ptr)
zi	redis.h	/^    unsigned char *zi;  \/* Entry in ziplist *\/$/;"	m	struct:__anon19	access:public
zi	redis.h	/^    unsigned char *zi;$/;"	m	struct:__anon18	access:public
zincrbyCommand	redis.h	/^void zincrbyCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zincrbyCommand	t_zset.c	/^void zincrbyCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zinterstoreCommand	redis.h	/^void zinterstoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zinterstoreCommand	t_zset.c	/^void zinterstoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zipEncodeLength	ziplist.c	/^static unsigned int zipEncodeLength(unsigned char *p, unsigned char encoding, unsigned int rawlen) {$/;"	f	file:	signature:(unsigned char *p, unsigned char encoding, unsigned int rawlen)
zipEntry	ziplist.c	/^static zlentry zipEntry(unsigned char *p) {$/;"	f	file:	signature:(unsigned char *p)
zipIntSize	ziplist.c	/^static unsigned int zipIntSize(unsigned char encoding) {$/;"	f	file:	signature:(unsigned char encoding)
zipLoadInteger	ziplist.c	/^static int64_t zipLoadInteger(unsigned char *p, unsigned char encoding) {$/;"	f	file:	signature:(unsigned char *p, unsigned char encoding)
zipPrevEncodeLength	ziplist.c	/^static unsigned int zipPrevEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:	signature:(unsigned char *p, unsigned int len)
zipPrevEncodeLengthForceLarge	ziplist.c	/^static void zipPrevEncodeLengthForceLarge(unsigned char *p, unsigned int len) {$/;"	f	file:	signature:(unsigned char *p, unsigned int len)
zipPrevLenByteDiff	ziplist.c	/^static int zipPrevLenByteDiff(unsigned char *p, unsigned int len) {$/;"	f	file:	signature:(unsigned char *p, unsigned int len)
zipRawEntryLength	ziplist.c	/^static unsigned int zipRawEntryLength(unsigned char *p) {$/;"	f	file:	signature:(unsigned char *p)
zipSaveInteger	ziplist.c	/^static void zipSaveInteger(unsigned char *p, int64_t value, unsigned char encoding) {$/;"	f	file:	signature:(unsigned char *p, int64_t value, unsigned char encoding)
zipTryEncoding	ziplist.c	/^static int zipTryEncoding(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding) {$/;"	f	file:	signature:(unsigned char *entry, unsigned int entrylen, long long *v, unsigned char *encoding)
ziplist.c	ziplist.c	1;"	F
ziplist.h	ziplist.h	1;"	F
ziplistBlobLen	ziplist.c	/^size_t ziplistBlobLen(unsigned char *zl) {$/;"	f	signature:(unsigned char *zl)
ziplistBlobLen	ziplist.h	/^size_t ziplistBlobLen(unsigned char *zl);$/;"	p	signature:(unsigned char *zl)
ziplistCompare	ziplist.c	/^unsigned int ziplistCompare(unsigned char *p, unsigned char *sstr, unsigned int slen) {$/;"	f	signature:(unsigned char *p, unsigned char *sstr, unsigned int slen)
ziplistCompare	ziplist.h	/^unsigned int ziplistCompare(unsigned char *p, unsigned char *s, unsigned int slen);$/;"	p	signature:(unsigned char *p, unsigned char *s, unsigned int slen)
ziplistDelete	ziplist.c	/^unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p) {$/;"	f	signature:(unsigned char *zl, unsigned char **p)
ziplistDelete	ziplist.h	/^unsigned char *ziplistDelete(unsigned char *zl, unsigned char **p);$/;"	p	signature:(unsigned char *zl, unsigned char **p)
ziplistDeleteRange	ziplist.c	/^unsigned char *ziplistDeleteRange(unsigned char *zl, unsigned int index, unsigned int num) {$/;"	f	signature:(unsigned char *zl, unsigned int index, unsigned int num)
ziplistDeleteRange	ziplist.h	/^unsigned char *ziplistDeleteRange(unsigned char *zl, unsigned int index, unsigned int num);$/;"	p	signature:(unsigned char *zl, unsigned int index, unsigned int num)
ziplistFind	ziplist.c	/^unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip) {$/;"	f	signature:(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip)
ziplistFind	ziplist.h	/^unsigned char *ziplistFind(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip);$/;"	p	signature:(unsigned char *p, unsigned char *vstr, unsigned int vlen, unsigned int skip)
ziplistGet	ziplist.c	/^unsigned int ziplistGet(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval) {$/;"	f	signature:(unsigned char *p, unsigned char **sstr, unsigned int *slen, long long *sval)
ziplistGet	ziplist.h	/^unsigned int ziplistGet(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval);$/;"	p	signature:(unsigned char *p, unsigned char **sval, unsigned int *slen, long long *lval)
ziplistGetObject	t_zset.c	/^robj *ziplistGetObject(unsigned char *sptr) {$/;"	f	signature:(unsigned char *sptr)
ziplistIndex	ziplist.c	/^unsigned char *ziplistIndex(unsigned char *zl, int index) {$/;"	f	signature:(unsigned char *zl, int index)
ziplistIndex	ziplist.h	/^unsigned char *ziplistIndex(unsigned char *zl, int index);$/;"	p	signature:(unsigned char *zl, int index)
ziplistInsert	ziplist.c	/^unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen) {$/;"	f	signature:(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)
ziplistInsert	ziplist.h	/^unsigned char *ziplistInsert(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen);$/;"	p	signature:(unsigned char *zl, unsigned char *p, unsigned char *s, unsigned int slen)
ziplistLen	ziplist.c	/^unsigned int ziplistLen(unsigned char *zl) {$/;"	f	signature:(unsigned char *zl)
ziplistLen	ziplist.h	/^unsigned int ziplistLen(unsigned char *zl);$/;"	p	signature:(unsigned char *zl)
ziplistNew	ziplist.c	/^unsigned char *ziplistNew(void) {$/;"	f	signature:(void)
ziplistNew	ziplist.h	/^unsigned char *ziplistNew(void);$/;"	p	signature:(void)
ziplistNext	ziplist.c	/^unsigned char *ziplistNext(unsigned char *zl, unsigned char *p) {$/;"	f	signature:(unsigned char *zl, unsigned char *p)
ziplistNext	ziplist.h	/^unsigned char *ziplistNext(unsigned char *zl, unsigned char *p);$/;"	p	signature:(unsigned char *zl, unsigned char *p)
ziplistPrev	ziplist.c	/^unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p) {$/;"	f	signature:(unsigned char *zl, unsigned char *p)
ziplistPrev	ziplist.h	/^unsigned char *ziplistPrev(unsigned char *zl, unsigned char *p);$/;"	p	signature:(unsigned char *zl, unsigned char *p)
ziplistPush	ziplist.c	/^unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where) {$/;"	f	signature:(unsigned char *zl, unsigned char *s, unsigned int slen, int where)
ziplistPush	ziplist.h	/^unsigned char *ziplistPush(unsigned char *zl, unsigned char *s, unsigned int slen, int where);$/;"	p	signature:(unsigned char *zl, unsigned char *s, unsigned int slen, int where)
ziplistRepr	ziplist.c	/^void ziplistRepr(unsigned char *zl) {$/;"	f	signature:(unsigned char *zl)
ziplistResize	ziplist.c	/^static unsigned char *ziplistResize(unsigned char *zl, unsigned int len) {$/;"	f	file:	signature:(unsigned char *zl, unsigned int len)
zipmap.c	zipmap.c	1;"	F
zipmap.h	zipmap.h	1;"	F
zipmapBlobLen	zipmap.c	/^size_t zipmapBlobLen(unsigned char *zm) {$/;"	f	signature:(unsigned char *zm)
zipmapBlobLen	zipmap.h	/^size_t zipmapBlobLen(unsigned char *zm);$/;"	p	signature:(unsigned char *zm)
zipmapDecodeLength	zipmap.c	/^static unsigned int zipmapDecodeLength(unsigned char *p) {$/;"	f	file:	signature:(unsigned char *p)
zipmapDel	zipmap.c	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted) {$/;"	f	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted)
zipmapDel	zipmap.h	/^unsigned char *zipmapDel(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted);$/;"	p	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, int *deleted)
zipmapEncodeLength	zipmap.c	/^static unsigned int zipmapEncodeLength(unsigned char *p, unsigned int len) {$/;"	f	file:	signature:(unsigned char *p, unsigned int len)
zipmapExists	zipmap.c	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen) {$/;"	f	signature:(unsigned char *zm, unsigned char *key, unsigned int klen)
zipmapExists	zipmap.h	/^int zipmapExists(unsigned char *zm, unsigned char *key, unsigned int klen);$/;"	p	signature:(unsigned char *zm, unsigned char *key, unsigned int klen)
zipmapGet	zipmap.c	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen) {$/;"	f	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen)
zipmapGet	zipmap.h	/^int zipmapGet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen);$/;"	p	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char **value, unsigned int *vlen)
zipmapLen	zipmap.c	/^unsigned int zipmapLen(unsigned char *zm) {$/;"	f	signature:(unsigned char *zm)
zipmapLen	zipmap.h	/^unsigned int zipmapLen(unsigned char *zm);$/;"	p	signature:(unsigned char *zm)
zipmapLookupRaw	zipmap.c	/^static unsigned char *zipmapLookupRaw(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen) {$/;"	f	file:	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned int *totlen)
zipmapNew	zipmap.c	/^unsigned char *zipmapNew(void) {$/;"	f	signature:(void)
zipmapNew	zipmap.h	/^unsigned char *zipmapNew(void);$/;"	p	signature:(void)
zipmapNext	zipmap.c	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen) {$/;"	f	signature:(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen)
zipmapNext	zipmap.h	/^unsigned char *zipmapNext(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen);$/;"	p	signature:(unsigned char *zm, unsigned char **key, unsigned int *klen, unsigned char **value, unsigned int *vlen)
zipmapRawEntryLength	zipmap.c	/^static unsigned int zipmapRawEntryLength(unsigned char *p) {$/;"	f	file:	signature:(unsigned char *p)
zipmapRawKeyLength	zipmap.c	/^static unsigned int zipmapRawKeyLength(unsigned char *p) {$/;"	f	file:	signature:(unsigned char *p)
zipmapRawValueLength	zipmap.c	/^static unsigned int zipmapRawValueLength(unsigned char *p) {$/;"	f	file:	signature:(unsigned char *p)
zipmapRepr	zipmap.c	/^void zipmapRepr(unsigned char *p) {$/;"	f	signature:(unsigned char *p)
zipmapRepr	zipmap.h	/^void zipmapRepr(unsigned char *p);$/;"	p	signature:(unsigned char *p)
zipmapRequiredLength	zipmap.c	/^static unsigned long zipmapRequiredLength(unsigned int klen, unsigned int vlen) {$/;"	f	file:	signature:(unsigned int klen, unsigned int vlen)
zipmapResize	zipmap.c	/^static inline unsigned char *zipmapResize(unsigned char *zm, unsigned int len) {$/;"	f	file:	signature:(unsigned char *zm, unsigned int len)
zipmapRewind	zipmap.c	/^unsigned char *zipmapRewind(unsigned char *zm) {$/;"	f	signature:(unsigned char *zm)
zipmapRewind	zipmap.h	/^unsigned char *zipmapRewind(unsigned char *zm);$/;"	p	signature:(unsigned char *zm)
zipmapSet	zipmap.c	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update) {$/;"	f	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update)
zipmapSet	zipmap.h	/^unsigned char *zipmapSet(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update);$/;"	p	signature:(unsigned char *zm, unsigned char *key, unsigned int klen, unsigned char *val, unsigned int vlen, int *update)
zl	t_zset.c	/^                unsigned char *zl;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
zl	t_zset.c	/^            } zl;$/;"	m	union:__anon30::__anon31::_iterzset	typeref:struct:__anon30::__anon31::_iterzset::__anon34	file:	access:public
zlentry	ziplist.c	/^typedef struct zlentry {$/;"	s	file:
zlentry	ziplist.c	/^} zlentry;$/;"	t	typeref:struct:zlentry	file:
zlentry::encoding	ziplist.c	/^    unsigned char encoding;$/;"	m	struct:zlentry	file:	access:public
zlentry::headersize	ziplist.c	/^    unsigned int headersize;$/;"	m	struct:zlentry	file:	access:public
zlentry::len	ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:	access:public
zlentry::lensize	ziplist.c	/^    unsigned int lensize, len;$/;"	m	struct:zlentry	file:	access:public
zlentry::p	ziplist.c	/^    unsigned char *p;$/;"	m	struct:zlentry	file:	access:public
zlentry::prevrawlen	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:	access:public
zlentry::prevrawlensize	ziplist.c	/^    unsigned int prevrawlensize, prevrawlen;$/;"	m	struct:zlentry	file:	access:public
zlexcountCommand	redis.h	/^void zlexcountCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zlexcountCommand	t_zset.c	/^void zlexcountCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zlexrangespec	redis.h	/^} zlexrangespec;$/;"	t	typeref:struct:__anon23
zlibc_free	zmalloc.c	/^void zlibc_free(void *ptr) {$/;"	f	signature:(void *ptr)
zlibc_free	zmalloc.h	/^void zlibc_free(void *ptr);$/;"	p	signature:(void *ptr)
zmalloc	zmalloc.c	/^void *zmalloc(size_t size) {$/;"	f	signature:(size_t size)
zmalloc	zmalloc.h	/^void *zmalloc(size_t size);$/;"	p	signature:(size_t size)
zmalloc.c	zmalloc.c	1;"	F
zmalloc.h	zmalloc.h	1;"	F
zmalloc_default_oom	zmalloc.c	/^static void zmalloc_default_oom(size_t size) {$/;"	f	file:	signature:(size_t size)
zmalloc_enable_thread_safeness	zmalloc.c	/^void zmalloc_enable_thread_safeness(void) {$/;"	f	signature:(void)
zmalloc_enable_thread_safeness	zmalloc.h	/^void zmalloc_enable_thread_safeness(void);$/;"	p	signature:(void)
zmalloc_get_fragmentation_ratio	zmalloc.c	/^float zmalloc_get_fragmentation_ratio(size_t rss) {$/;"	f	signature:(size_t rss)
zmalloc_get_fragmentation_ratio	zmalloc.h	/^float zmalloc_get_fragmentation_ratio(size_t rss);$/;"	p	signature:(size_t rss)
zmalloc_get_private_dirty	zmalloc.c	/^size_t zmalloc_get_private_dirty(void) {$/;"	f	signature:(void)
zmalloc_get_private_dirty	zmalloc.h	/^size_t zmalloc_get_private_dirty(void);$/;"	p	signature:(void)
zmalloc_get_rss	zmalloc.c	/^size_t zmalloc_get_rss(void) {$/;"	f	signature:(void)
zmalloc_get_rss	zmalloc.h	/^size_t zmalloc_get_rss(void);$/;"	p	signature:(void)
zmalloc_get_smap_bytes_by_field	zmalloc.c	/^size_t zmalloc_get_smap_bytes_by_field(char *field) {$/;"	f	signature:(char *field)
zmalloc_get_smap_bytes_by_field	zmalloc.h	/^size_t zmalloc_get_smap_bytes_by_field(char *field);$/;"	p	signature:(char *field)
zmalloc_oom_handler	zmalloc.c	/^static void (*zmalloc_oom_handler)(size_t) = zmalloc_default_oom;$/;"	v	file:
zmalloc_set_oom_handler	zmalloc.c	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t)) {$/;"	f	signature:(void (*oom_handler)(size_t))
zmalloc_set_oom_handler	zmalloc.h	/^void zmalloc_set_oom_handler(void (*oom_handler)(size_t));$/;"	p	signature:(void (*oom_handler)(size_t))
zmalloc_size	zmalloc.c	/^size_t zmalloc_size(void *ptr) {$/;"	f	signature:(void *ptr)
zmalloc_size	zmalloc.h	/^#define zmalloc_size(/;"	d
zmalloc_size	zmalloc.h	/^size_t zmalloc_size(void *ptr);$/;"	p	signature:(void *ptr)
zmalloc_size_sds	networking.c	/^size_t zmalloc_size_sds(sds s) {$/;"	f	signature:(sds s)
zmalloc_thread_safe	zmalloc.c	/^static int zmalloc_thread_safe = 0;$/;"	v	file:
zmalloc_used_memory	zmalloc.c	/^size_t zmalloc_used_memory(void) {$/;"	f	signature:(void)
zmalloc_used_memory	zmalloc.h	/^size_t zmalloc_used_memory(void);$/;"	p	signature:(void)
zrangeCommand	redis.h	/^void zrangeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrangeCommand	t_zset.c	/^void zrangeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrangeGenericCommand	t_zset.c	/^void zrangeGenericCommand(redisClient *c, int reverse) {$/;"	f	signature:(redisClient *c, int reverse)
zrangebylexCommand	redis.h	/^void zrangebylexCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrangebylexCommand	t_zset.c	/^void zrangebylexCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrangebyscoreCommand	redis.h	/^void zrangebyscoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrangebyscoreCommand	t_zset.c	/^void zrangebyscoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrangespec	redis.h	/^} zrangespec;$/;"	t	typeref:struct:__anon22
zrankCommand	redis.h	/^void zrankCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrankCommand	t_zset.c	/^void zrankCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrankGenericCommand	t_zset.c	/^void zrankGenericCommand(redisClient *c, int reverse) {$/;"	f	signature:(redisClient *c, int reverse)
zrealloc	zmalloc.c	/^void *zrealloc(void *ptr, size_t size) {$/;"	f	signature:(void *ptr, size_t size)
zrealloc	zmalloc.h	/^void *zrealloc(void *ptr, size_t size);$/;"	p	signature:(void *ptr, size_t size)
zremCommand	redis.h	/^void zremCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zremCommand	t_zset.c	/^void zremCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zremrangeGenericCommand	t_zset.c	/^void zremrangeGenericCommand(redisClient *c, int rangetype) {$/;"	f	signature:(redisClient *c, int rangetype)
zremrangebylexCommand	redis.h	/^void zremrangebylexCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zremrangebylexCommand	t_zset.c	/^void zremrangebylexCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zremrangebyrankCommand	redis.h	/^void zremrangebyrankCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zremrangebyrankCommand	t_zset.c	/^void zremrangebyrankCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zremrangebyscoreCommand	redis.h	/^void zremrangebyscoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zremrangebyscoreCommand	t_zset.c	/^void zremrangebyscoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrevrangeCommand	redis.h	/^void zrevrangeCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrevrangeCommand	t_zset.c	/^void zrevrangeCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrevrangebylexCommand	redis.h	/^void zrevrangebylexCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrevrangebylexCommand	t_zset.c	/^void zrevrangebylexCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrevrangebyscoreCommand	redis.h	/^void zrevrangebyscoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrevrangebyscoreCommand	t_zset.c	/^void zrevrangebyscoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zrevrankCommand	redis.h	/^void zrevrankCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zrevrankCommand	t_zset.c	/^void zrevrankCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zs	t_zset.c	/^                zset *zs;$/;"	m	struct:__anon30::__anon31::_iterzset::__anon35	file:	access:public
zscanCommand	redis.h	/^void zscanCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zscanCommand	t_zset.c	/^void zscanCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zscoreCommand	redis.h	/^void zscoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zscoreCommand	t_zset.c	/^void zscoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zset	redis.h	/^typedef struct zset {$/;"	s
zset	redis.h	/^} zset;$/;"	t	typeref:struct:zset
zset	t_zset.c	/^        } zset;$/;"	m	union:__anon30::__anon31	typeref:union:__anon30::__anon31::_iterzset	file:	access:public
zset::dict	redis.h	/^    dict *dict;$/;"	m	struct:zset	access:public
zset::zsl	redis.h	/^    zskiplist *zsl;$/;"	m	struct:zset	access:public
zsetConvert	redis.h	/^void zsetConvert(robj *zobj, int encoding);$/;"	p	signature:(robj *zobj, int encoding)
zsetConvert	t_zset.c	/^void zsetConvert(robj *zobj, int encoding) {$/;"	f	signature:(robj *zobj, int encoding)
zsetDictType	redis.c	/^dictType zsetDictType = {$/;"	v
zsetDictType	redis.h	/^extern dictType zsetDictType;$/;"	x
zsetLength	redis.h	/^unsigned int zsetLength(robj *zobj);$/;"	p	signature:(robj *zobj)
zsetLength	t_zset.c	/^unsigned int zsetLength(robj *zobj) {$/;"	f	signature:(robj *zobj)
zset_max_ziplist_entries	redis.h	/^    size_t zset_max_ziplist_entries;$/;"	m	struct:redisServer	access:public
zset_max_ziplist_value	redis.h	/^    size_t zset_max_ziplist_value;$/;"	m	struct:redisServer	access:public
zsetopsrc	t_zset.c	/^} zsetopsrc;$/;"	t	typeref:struct:__anon30	file:
zsetopval	t_zset.c	/^} zsetopval;$/;"	t	typeref:struct:__anon36	file:
zskiplist	redis.h	/^typedef struct zskiplist {$/;"	s
zskiplist	redis.h	/^} zskiplist;$/;"	t	typeref:struct:zskiplist
zskiplist::header	redis.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::zskiplistNode	access:public
zskiplist::length	redis.h	/^    unsigned long length;$/;"	m	struct:zskiplist	access:public
zskiplist::level	redis.h	/^    int level;$/;"	m	struct:zskiplist	access:public
zskiplist::tail	redis.h	/^    struct zskiplistNode *header, *tail;$/;"	m	struct:zskiplist	typeref:struct:zskiplist::	access:public
zskiplistLevel	redis.h	/^    struct zskiplistLevel {$/;"	s	struct:zskiplistNode	access:public
zskiplistNode	redis.h	/^typedef struct zskiplistNode {$/;"	s
zskiplistNode	redis.h	/^} zskiplistNode;$/;"	t	typeref:struct:zskiplistNode
zskiplistNode::backward	redis.h	/^    struct zskiplistNode *backward;$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistNode	access:public
zskiplistNode::level	redis.h	/^    } level[];$/;"	m	struct:zskiplistNode	typeref:struct:zskiplistNode::zskiplistLevel	access:public
zskiplistNode::obj	redis.h	/^    robj *obj;$/;"	m	struct:zskiplistNode	access:public
zskiplistNode::score	redis.h	/^    double score;$/;"	m	struct:zskiplistNode	access:public
zskiplistNode::zskiplistLevel	redis.h	/^    struct zskiplistLevel {$/;"	s	struct:zskiplistNode	access:public
zskiplistNode::zskiplistLevel::forward	redis.h	/^        struct zskiplistNode *forward;$/;"	m	struct:zskiplistNode::zskiplistLevel	typeref:struct:zskiplistNode::zskiplistLevel::zskiplistNode	access:public
zskiplistNode::zskiplistLevel::span	redis.h	/^        unsigned int span;$/;"	m	struct:zskiplistNode::zskiplistLevel	access:public
zsl	redis.h	/^    zskiplist *zsl;$/;"	m	struct:zset	access:public
zslCreate	redis.h	/^zskiplist *zslCreate(void);$/;"	p	signature:(void)
zslCreate	t_zset.c	/^zskiplist *zslCreate(void) {$/;"	f	signature:(void)
zslCreateNode	t_zset.c	/^zskiplistNode *zslCreateNode(int level, double score, robj *obj) {$/;"	f	signature:(int level, double score, robj *obj)
zslDelete	redis.h	/^int zslDelete(zskiplist *zsl, double score, robj *obj);$/;"	p	signature:(zskiplist *zsl, double score, robj *obj)
zslDelete	t_zset.c	/^int zslDelete(zskiplist *zsl, double score, robj *obj) {$/;"	f	signature:(zskiplist *zsl, double score, robj *obj)
zslDeleteNode	t_zset.c	/^void zslDeleteNode(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update) {$/;"	f	signature:(zskiplist *zsl, zskiplistNode *x, zskiplistNode **update)
zslDeleteRangeByLex	t_zset.c	/^unsigned long zslDeleteRangeByLex(zskiplist *zsl, zlexrangespec *range, dict *dict) {$/;"	f	signature:(zskiplist *zsl, zlexrangespec *range, dict *dict)
zslDeleteRangeByRank	t_zset.c	/^unsigned long zslDeleteRangeByRank(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict) {$/;"	f	signature:(zskiplist *zsl, unsigned int start, unsigned int end, dict *dict)
zslDeleteRangeByScore	t_zset.c	/^unsigned long zslDeleteRangeByScore(zskiplist *zsl, zrangespec *range, dict *dict) {$/;"	f	signature:(zskiplist *zsl, zrangespec *range, dict *dict)
zslFirstInLexRange	t_zset.c	/^zskiplistNode *zslFirstInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f	signature:(zskiplist *zsl, zlexrangespec *range)
zslFirstInRange	redis.h	/^zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range);$/;"	p	signature:(zskiplist *zsl, zrangespec *range)
zslFirstInRange	t_zset.c	/^zskiplistNode *zslFirstInRange(zskiplist *zsl, zrangespec *range) {$/;"	f	signature:(zskiplist *zsl, zrangespec *range)
zslFree	redis.h	/^void zslFree(zskiplist *zsl);$/;"	p	signature:(zskiplist *zsl)
zslFree	t_zset.c	/^void zslFree(zskiplist *zsl) {$/;"	f	signature:(zskiplist *zsl)
zslFreeLexRange	t_zset.c	/^void zslFreeLexRange(zlexrangespec *spec) {$/;"	f	signature:(zlexrangespec *spec)
zslFreeNode	t_zset.c	/^void zslFreeNode(zskiplistNode *node) {$/;"	f	signature:(zskiplistNode *node)
zslGetElementByRank	sort.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank);$/;"	p	file:	signature:(zskiplist *zsl, unsigned long rank)
zslGetElementByRank	t_zset.c	/^zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {$/;"	f	signature:(zskiplist *zsl, unsigned long rank)
zslGetRank	redis.h	/^unsigned long zslGetRank(zskiplist *zsl, double score, robj *o);$/;"	p	signature:(zskiplist *zsl, double score, robj *o)
zslGetRank	t_zset.c	/^unsigned long zslGetRank(zskiplist *zsl, double score, robj *o) {$/;"	f	signature:(zskiplist *zsl, double score, robj *o)
zslInsert	redis.h	/^zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj);$/;"	p	signature:(zskiplist *zsl, double score, robj *obj)
zslInsert	t_zset.c	/^zskiplistNode *zslInsert(zskiplist *zsl, double score, robj *obj) {$/;"	f	signature:(zskiplist *zsl, double score, robj *obj)
zslIsInLexRange	t_zset.c	/^int zslIsInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f	signature:(zskiplist *zsl, zlexrangespec *range)
zslIsInRange	t_zset.c	/^int zslIsInRange(zskiplist *zsl, zrangespec *range) {$/;"	f	signature:(zskiplist *zsl, zrangespec *range)
zslLastInLexRange	t_zset.c	/^zskiplistNode *zslLastInLexRange(zskiplist *zsl, zlexrangespec *range) {$/;"	f	signature:(zskiplist *zsl, zlexrangespec *range)
zslLastInRange	redis.h	/^zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range);$/;"	p	signature:(zskiplist *zsl, zrangespec *range)
zslLastInRange	t_zset.c	/^zskiplistNode *zslLastInRange(zskiplist *zsl, zrangespec *range) {$/;"	f	signature:(zskiplist *zsl, zrangespec *range)
zslLexValueGteMin	t_zset.c	/^static int zslLexValueGteMin(robj *value, zlexrangespec *spec) {$/;"	f	file:	signature:(robj *value, zlexrangespec *spec)
zslLexValueGteMin	t_zset.c	/^static int zslLexValueGteMin(robj *value, zlexrangespec *spec);$/;"	p	file:	signature:(robj *value, zlexrangespec *spec)
zslLexValueLteMax	t_zset.c	/^static int zslLexValueLteMax(robj *value, zlexrangespec *spec) {$/;"	f	file:	signature:(robj *value, zlexrangespec *spec)
zslLexValueLteMax	t_zset.c	/^static int zslLexValueLteMax(robj *value, zlexrangespec *spec);$/;"	p	file:	signature:(robj *value, zlexrangespec *spec)
zslParseLexRange	t_zset.c	/^static int zslParseLexRange(robj *min, robj *max, zlexrangespec *spec) {$/;"	f	file:	signature:(robj *min, robj *max, zlexrangespec *spec)
zslParseLexRangeItem	t_zset.c	/^int zslParseLexRangeItem(robj *item, robj **dest, int *ex) {$/;"	f	signature:(robj *item, robj **dest, int *ex)
zslParseRange	t_zset.c	/^static int zslParseRange(robj *min, robj *max, zrangespec *spec) {$/;"	f	file:	signature:(robj *min, robj *max, zrangespec *spec)
zslRandomLevel	t_zset.c	/^int zslRandomLevel(void) {$/;"	f	signature:(void)
zslValueGteMin	t_zset.c	/^static int zslValueGteMin(double value, zrangespec *spec) {$/;"	f	file:	signature:(double value, zrangespec *spec)
zslValueLteMax	t_zset.c	/^static int zslValueLteMax(double value, zrangespec *spec) {$/;"	f	file:	signature:(double value, zrangespec *spec)
zstrdup	zmalloc.c	/^char *zstrdup(const char *s) {$/;"	f	signature:(const char *s)
zstrdup	zmalloc.h	/^char *zstrdup(const char *s);$/;"	p	signature:(const char *s)
zuiBufferFromValue	t_zset.c	/^int zuiBufferFromValue(zsetopval *val) {$/;"	f	signature:(zsetopval *val)
zuiClearIterator	t_zset.c	/^void zuiClearIterator(zsetopsrc *op) {$/;"	f	signature:(zsetopsrc *op)
zuiCompareByCardinality	t_zset.c	/^int zuiCompareByCardinality(const void *s1, const void *s2) {$/;"	f	signature:(const void *s1, const void *s2)
zuiFind	t_zset.c	/^int zuiFind(zsetopsrc *op, zsetopval *val, double *score) {$/;"	f	signature:(zsetopsrc *op, zsetopval *val, double *score)
zuiInitIterator	t_zset.c	/^void zuiInitIterator(zsetopsrc *op) {$/;"	f	signature:(zsetopsrc *op)
zuiLength	t_zset.c	/^int zuiLength(zsetopsrc *op) {$/;"	f	signature:(zsetopsrc *op)
zuiLongLongFromValue	t_zset.c	/^int zuiLongLongFromValue(zsetopval *val) {$/;"	f	signature:(zsetopval *val)
zuiNext	t_zset.c	/^int zuiNext(zsetopsrc *op, zsetopval *val) {$/;"	f	signature:(zsetopsrc *op, zsetopval *val)
zuiObjectFromValue	t_zset.c	/^robj *zuiObjectFromValue(zsetopval *val) {$/;"	f	signature:(zsetopval *val)
zunionInterAggregate	t_zset.c	/^inline static void zunionInterAggregate(double *target, double val, int aggregate) {$/;"	f	file:	signature:(double *target, double val, int aggregate)
zunionInterDictValue	t_zset.c	/^#define zunionInterDictValue(/;"	d	file:
zunionInterGenericCommand	t_zset.c	/^void zunionInterGenericCommand(redisClient *c, robj *dstkey, int op) {$/;"	f	signature:(redisClient *c, robj *dstkey, int op)
zunionInterGetKeys	db.c	/^int *zunionInterGetKeys(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {$/;"	f	signature:(struct redisCommand *cmd, robj **argv, int argc, int *numkeys)
zunionInterGetKeys	redis.h	/^int *zunionInterGetKeys(struct redisCommand *cmd,robj **argv, int argc, int *numkeys);$/;"	p	signature:(struct redisCommand *cmd,robj **argv, int argc, int *numkeys)
zunionstoreCommand	redis.h	/^void zunionstoreCommand(redisClient *c);$/;"	p	signature:(redisClient *c)
zunionstoreCommand	t_zset.c	/^void zunionstoreCommand(redisClient *c) {$/;"	f	signature:(redisClient *c)
zzlCompareElements	t_zset.c	/^int zzlCompareElements(unsigned char *eptr, unsigned char *cstr, unsigned int clen) {$/;"	f	signature:(unsigned char *eptr, unsigned char *cstr, unsigned int clen)
zzlDelete	t_zset.c	/^unsigned char *zzlDelete(unsigned char *zl, unsigned char *eptr) {$/;"	f	signature:(unsigned char *zl, unsigned char *eptr)
zzlDeleteRangeByLex	t_zset.c	/^unsigned char *zzlDeleteRangeByLex(unsigned char *zl, zlexrangespec *range, unsigned long *deleted) {$/;"	f	signature:(unsigned char *zl, zlexrangespec *range, unsigned long *deleted)
zzlDeleteRangeByRank	t_zset.c	/^unsigned char *zzlDeleteRangeByRank(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted) {$/;"	f	signature:(unsigned char *zl, unsigned int start, unsigned int end, unsigned long *deleted)
zzlDeleteRangeByScore	t_zset.c	/^unsigned char *zzlDeleteRangeByScore(unsigned char *zl, zrangespec *range, unsigned long *deleted) {$/;"	f	signature:(unsigned char *zl, zrangespec *range, unsigned long *deleted)
zzlFind	t_zset.c	/^unsigned char *zzlFind(unsigned char *zl, robj *ele, double *score) {$/;"	f	signature:(unsigned char *zl, robj *ele, double *score)
zzlFirstInLexRange	t_zset.c	/^unsigned char *zzlFirstInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f	signature:(unsigned char *zl, zlexrangespec *range)
zzlFirstInRange	t_zset.c	/^unsigned char *zzlFirstInRange(unsigned char *zl, zrangespec *range) {$/;"	f	signature:(unsigned char *zl, zrangespec *range)
zzlGetScore	redis.h	/^double zzlGetScore(unsigned char *sptr);$/;"	p	signature:(unsigned char *sptr)
zzlGetScore	t_zset.c	/^double zzlGetScore(unsigned char *sptr) {$/;"	f	signature:(unsigned char *sptr)
zzlInsert	redis.h	/^unsigned char *zzlInsert(unsigned char *zl, robj *ele, double score);$/;"	p	signature:(unsigned char *zl, robj *ele, double score)
zzlInsert	t_zset.c	/^unsigned char *zzlInsert(unsigned char *zl, robj *ele, double score) {$/;"	f	signature:(unsigned char *zl, robj *ele, double score)
zzlInsertAt	t_zset.c	/^unsigned char *zzlInsertAt(unsigned char *zl, unsigned char *eptr, robj *ele, double score) {$/;"	f	signature:(unsigned char *zl, unsigned char *eptr, robj *ele, double score)
zzlIsInLexRange	t_zset.c	/^int zzlIsInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f	signature:(unsigned char *zl, zlexrangespec *range)
zzlIsInRange	t_zset.c	/^int zzlIsInRange(unsigned char *zl, zrangespec *range) {$/;"	f	signature:(unsigned char *zl, zrangespec *range)
zzlLastInLexRange	t_zset.c	/^unsigned char *zzlLastInLexRange(unsigned char *zl, zlexrangespec *range) {$/;"	f	signature:(unsigned char *zl, zlexrangespec *range)
zzlLastInRange	t_zset.c	/^unsigned char *zzlLastInRange(unsigned char *zl, zrangespec *range) {$/;"	f	signature:(unsigned char *zl, zrangespec *range)
zzlLength	t_zset.c	/^unsigned int zzlLength(unsigned char *zl) {$/;"	f	signature:(unsigned char *zl)
zzlLexValueGteMin	t_zset.c	/^static int zzlLexValueGteMin(unsigned char *p, zlexrangespec *spec) {$/;"	f	file:	signature:(unsigned char *p, zlexrangespec *spec)
zzlLexValueLteMax	t_zset.c	/^static int zzlLexValueLteMax(unsigned char *p, zlexrangespec *spec) {$/;"	f	file:	signature:(unsigned char *p, zlexrangespec *spec)
zzlNext	redis.h	/^void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);$/;"	p	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
zzlNext	t_zset.c	/^void zzlNext(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
zzlPrev	redis.h	/^void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr);$/;"	p	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
zzlPrev	t_zset.c	/^void zzlPrev(unsigned char *zl, unsigned char **eptr, unsigned char **sptr) {$/;"	f	signature:(unsigned char *zl, unsigned char **eptr, unsigned char **sptr)
